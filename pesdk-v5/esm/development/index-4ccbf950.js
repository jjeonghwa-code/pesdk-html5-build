import React, { forwardRef, Component, PureComponent, createElement, Children } from 'react';
import ReactDOM, { unstable_batchedUpdates, findDOMNode as findDOMNode$1 } from 'react-dom';
import { isRGBAArray, isRGBAObject, isRGBArray, isRGBObject, LegacyEngineAdapter, ConversionUtils, ExportFormat as ExportFormat$1, EngineEvent } from './engine.development.js';
import styled, { css, keyframes, ThemeProvider } from 'styled-components';
import { renderToStaticMarkup } from 'react-dom/server';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}

/**
 * Currently differentiation between Custom Item and Existing Item is based on
 * availability of attribute name
 */
function isExistingItem(item) {
    return !Object.prototype.hasOwnProperty.call(item, 'name');
}
/**
 * Currently differentiation between Custom Category and Existing Category is based on
 * availability of attribute name
 */
function isExistingCategory(category) {
    return !Object.prototype.hasOwnProperty.call(category, 'name');
}

var CanvasAction;
(function (CanvasAction) {
    CanvasAction["UNDO"] = "undo";
    CanvasAction["REDO"] = "redo";
    CanvasAction["DELETE"] = "delete";
    CanvasAction["BRING_TO_FRONT"] = "bringtofront";
    CanvasAction["EDIT"] = "edit";
    CanvasAction["DUPLICATE"] = "duplicate";
    CanvasAction["ADD"] = "add";
    CanvasAction["FLIP"] = "flip";
    CanvasAction["INVERT"] = "invert";
    CanvasAction["CLOSE"] = "close";
    CanvasAction["EXPORT"] = "export";
})(CanvasAction || (CanvasAction = {}));

/** List of Image editing tools. */
var Tool;
(function (Tool) {
    /** A tool to add a default list of input images. */
    Tool["LIBRARY"] = "library";
    Tool["ART_FILTER"] = "artFilter";
    /** A tool to apply an transformation, such as cropping or rotation. */
    Tool["TRANSFORM"] = "transform";
    /** A tool to apply an image filter effect. */
    Tool["FILTER"] = "filter";
    /** A tool to apply an image filter effect. */
    Tool["ADJUSTMENT"] = "adjustment";
    /** A tool to add blur. */
    Tool["FOCUS"] = "focus";
    /** A tool to add stickers. */
    Tool["STICKER"] = "sticker";
    /** A tool to add texts. */
    Tool["TEXT"] = "text";
    /** A tool to add text designs. */
    Tool["TEXT_DESIGN"] = "textdesign";
    /** A tool to add an overlay. */
    Tool["OVERLAY"] = "overlay";
    /** A tool to add a frame. */
    Tool["FRAME"] = "frame";
    /** A tool to add a frame. */
    Tool["BRUSH"] = "brush";
})(Tool || (Tool = {}));

var PositionSnapping = /** @class */ (function () {
    function PositionSnapping() {
        /**
         * Whether sprites should snap to specific positions during pan interactions.
         * This switch enables or disables position snapping.
         * @example // Defaults to:
         * true
         */
        this.enabled = true;
        /**
         * This threshold defines the distance of a pan gesture where snapping at a snap point occurs.
         * It is measured in pixels.
         * @example // Defaults to:
         * 20
         */
        this.threshold = 20;
        /**
         * If enabled a sprite's center snaps to the horizontal line through the center of the edited image.
         * @example // Defaults to:
         * true
         */
        this.snapToHorizontalCenter = true;
        /**
         * If enabled a sprite's center snaps to the vertical line through the center of the edited image.
         * @example // Defaults to:
         * true
         */
        this.snapToVerticalCenter = true;
        /**
         * The left side of a sprite's bounding box snaps to a vertical line which is shifted by this value
         * from the left side of the edited image towards its center. This value is measured in normalized
         * coordinates relative to the smaller side of the edited image.
         * If this value is explicitly set to `null` this snapping line is disabled.
         * @example // Defaults to:
         * 0.1
         */
        this.snapToLeft = 0.1;
        /**
         * The right side of a sprite's bounding box snaps to a vertical line which is shifted by this value
         * from the right side of the edited image towards its center. This value is measured in normalized
         * coordinates relative to the smaller side of the edited image.
         * If this value is explicitly set to `null` this snapping line is disabled.
         * @example // Defaults to:
         * 0.1
         */
        this.snapToRight = 0.1;
        /**
         * The top side of a sprite's bounding box snaps to a horizontal line which is shifted by this value
         * from the top side of the edited image towards its center. This value is measured in normalized
         * coordinates relative to the smaller side of the edited image.
         * If this value is explicitly set to `null` this snapping line is disabled.
         * @example // Defaults to:
         * 0.1
         */
        this.snapToTop = 0.1;
        /**
         * The bottom side of a sprite's bounding box snaps to a horizontal line which is shifted by this value
         * from the bottom side of the edited image towards its center. This value is measured in normalized
         * coordinates relative to the smaller side of the edited image.
         * If this value is explicitly set to `null` this snapping line is disabled.
         * @example // Defaults to:
         * 0.1
         */
        this.snapToBottom = 0.1;
    }
    return PositionSnapping;
}());
var RotationSnapping = /** @class */ (function () {
    function RotationSnapping() {
        /**
         * Whether sprites should snap to specific orientations during rotation interactions.
         * This switch enables or disables rotation snapping.
         * @example // Defaults to:
         * true
         */
        this.enabled = true;
        /**
         * This threshold defines the arc length of a rotation gesture where snapping at a snap angle occurs.
         * It is measured in pixels.
         * @example // Defaults to:
         * 20
         */
        this.threshold = 20;
        /**
         * Enabled snapping angles in degrees for rotating a sprite. The rotation angle is defined clockwise.
         * @example // Defaults to:
         * [0, 45, 90, 135, 180, 225, 270, 315]
         */
        this.angles = [0, 45, 90, 135, 180, 225, 270, 315];
    }
    return RotationSnapping;
}());
var SnappingConfiguration = /** @class */ (function () {
    function SnappingConfiguration() {
        /**
         * Snapping options for positioning sprites.
         */
        this.position = new PositionSnapping();
        /**
         * Snapping options for rotating sprites.
         */
        this.rotation = new RotationSnapping();
    }
    return SnappingConfiguration;
}());

/** A video format. */
var VideoFormat;
(function (VideoFormat) {
    VideoFormat["MP4"] = "video/mp4";
    VideoFormat["MOV"] = "video/quicktime";
})(VideoFormat || (VideoFormat = {}));
/** A video codec. */
var VideoCodec;
(function (VideoCodec) {
    VideoCodec["H264"] = "h264";
    VideoCodec["HEVC"] = "hevc";
})(VideoCodec || (VideoCodec = {}));
/** A serialization export type. */
var SerializationExportType;
(function (SerializationExportType) {
    /** The exported serialization is saved to a file and the corresponding file URL is returned. */
    // FILE_URL = 'file-url',
    /** The exported serialization is returned as an object. */
    SerializationExportType["OBJECT"] = "object";
})(SerializationExportType || (SerializationExportType = {}));
var ExportConfiguration = /** @class */ (function () {
    function ExportConfiguration() {
    }
    return ExportConfiguration;
}());

var ExportFormat;
(function (ExportFormat) {
    ExportFormat["IMAGE"] = "image";
    ExportFormat["DATA_URL"] = "data-url";
    ExportFormat["BLOB"] = "blob";
    ExportFormat["MSBLOB"] = "ms-blob";
})(ExportFormat || (ExportFormat = {}));

var ImageFormat;
(function (ImageFormat) {
    ImageFormat["PNG"] = "image/png";
    ImageFormat["JPEG"] = "image/jpeg";
    // @ifndef WEBPACK
    ImageFormat["RAW"] = "raw";
    // @endif
})(ImageFormat || (ImageFormat = {}));

/**
 * Configuration options and asset definitions for image and video editing tasks.
 */
var Configuration = /** @class */ (function () {
    function Configuration() {
        /** relevant only for AdvancedUI */
        this.order = 'default';
        /**
         * Defines the language that should be used to label the user interface.
         * @example // Defaults to:
         * 'en'
         */
        this.language = 'en';
        /**
         * Defines the theme that should be used to style the user interface.
         * @example // Defaults to:
         * 'dark'
         */
        this.theme = 'dark';
        /**
         * The base URL for all assets. Should be the absolute path to your assets directory
         * @example // Defaults to:
         * assets/
         */
        this.assetBaseUrl = 'assets/';
        /** Should a message be displayed when the image has been scaled down for performance reasons */
        this.displayResizeWarning = true;
        /** Should a message be displayed when when Photoeditor SDK is exited with close event */
        this.displayCloseWarning = true;
        /**
         * When set to `true`, the user is forced to crop the asset to one of the allowed crop ratios in
         * `transform.items` before being able to use other features of the editor.
         * The transform tool will only be presented if the image does not already fit one of the allowed
         * aspect ratios. It will be presented automatically, if the user changes the orientation of the asset
         * and the result does not match an allowed aspect ratio.
         *
         * @example // Defaults to:
         * false
         */
        this.forceCrop = false;
        /**
         * Controls if the user can zoom the preview image.
         * @example // Defaults to:
         * true
         */
        this.enableZoom = true;
        /**
         * Applicable only to Advanced UI
         * decides which tool to keep open at the beginning
         * @example // Defaults to:
         * Tool.FILTER
         */
        this.defaultTool = Tool.FILTER;
    }
    return Configuration;
}());
Tool.FILTER, Tool.FOCUS, Tool.ADJUSTMENT, Tool.LIBRARY, Tool.OVERLAY, Tool.STICKER, Tool.TEXT, Tool.TEXT_DESIGN, Tool.FRAME, Tool.BRUSH, Tool.TRANSFORM;

var AdjustmentIdentifier;
(function (AdjustmentIdentifier) {
    AdjustmentIdentifier["BRIGHTNESS"] = "brightness";
    AdjustmentIdentifier["CONTRAST"] = "contrast";
    AdjustmentIdentifier["SATURATION"] = "saturation";
    AdjustmentIdentifier["CLARITY"] = "clarity";
    AdjustmentIdentifier["SHADOWS"] = "shadows";
    AdjustmentIdentifier["HIGHLIGHTS"] = "highlights";
    AdjustmentIdentifier["EXPOSURE"] = "exposure";
    AdjustmentIdentifier["GAMMA"] = "gamma";
    AdjustmentIdentifier["BLACKS"] = "blacks";
    AdjustmentIdentifier["WHITES"] = "whites";
    AdjustmentIdentifier["TEMPERATURE"] = "temperature";
    AdjustmentIdentifier["SHARPNESS"] = "sharpness";
})(AdjustmentIdentifier || (AdjustmentIdentifier = {}));

var AdjustmentConfiguration = /** @class */ (function () {
    function AdjustmentConfiguration() {
        /**
         * Defines all allowed adjustment tools. The adjustment tool buttons are always shown in the given order.
         * @example // Defaults to:
         * [{
         *    identifier: 'basic',
         *    items: [
         *      {identifier: AdjustmentIdentifier.BRIGHTNESS}, {identifier: AdjustmentIdentifier.SATURATION},
         *      {identifier: AdjustmentIdentifier.CONTRAST}, {identifier: AdjustmentIdentifier.GAMMA},
         *    ]
         * }, {
         *    identifier: 'refinements',
         *    items: [
         *      {identifier: AdjustmentIdentifier.CLARITY}, {identifier: AdjustmentIdentifier.EXPOSURE},
         *      {identifier: AdjustmentIdentifier.SHADOWS}, {identifier: AdjustmentIdentifier.HIGHLIGHTS},
         *      {identifier: AdjustmentIdentifier.WHITES}, {identifier: AdjustmentIdentifier.BLACKS},
         *      {identifier: AdjustmentIdentifier.TEMPERATURE}, {identifier: AdjustmentIdentifier.SHARPNESS},
         *    ],
         * }]
         */
        this.categories = [];
    }
    return AdjustmentConfiguration;
}());

var FilterConfiguration = /** @class */ (function () {
    function FilterConfiguration() {
        /**
         * Defines all available filters. Each filter must be assigned to a category.
         * `NONE` is always added in Basic UI
         * New items and categories can be mixed and matched with existing predefined ones.
         * @example // Defaults to:
         * [
         *   { identifier: "imgly_filter_category_duotone", items: [
         *     { identifier: "imgly_duotone_desert" },
         *     { identifier: "imgly_duotone_peach" },
         *     { identifier: "imgly_duotone_clash" },
         *     { identifier: "imgly_duotone_plum" },
         *     { identifier: "imgly_duotone_breezy" },
         *     { identifier: "imgly_duotone_deepblue" },
         *     { identifier: "imgly_duotone_frog" },
         *     { identifier: "imgly_duotone_sunset" },
         *   ]},
         *   { identifier: "imgly_filter_category_bw", items: [
         *     { identifier: "imgly_lut_ad1920" },
         *     { identifier: "imgly_lut_bw" },
         *     { identifier: "imgly_lut_x400" },
         *     { identifier: "imgly_lut_litho" },
         *     { identifier: "imgly_lut_sepiahigh" },
         *     { identifier: "imgly_lut_plate" },
         *     { identifier: "imgly_lut_sin" },
         *   ]},
         *   { identifier: "imgly_filter_category_vintage", items: [
         *     { identifier: "imgly_lut_blues" },
         *     { identifier: "imgly_lut_front" },
         *     { identifier: "imgly_lut_texas" },
         *     { identifier: "imgly_lut_celsius" },
         *     { identifier: "imgly_lut_cool" },
         *   ]},
         *   { identifier: "imgly_filter_category_smooth", items: [
         *     { identifier: "imgly_lut_chest" },
         *     { identifier: "imgly_lut_winter" },
         *     { identifier: "imgly_lut_kdynamic" },
         *     { identifier: "imgly_lut_fall" },
         *     { identifier: "imgly_lut_lenin" },
         *     { identifier: "imgly_lut_pola669" },
         *   ]},
         *   { identifier: "imgly_filter_category_cold", items: [
         *     { identifier: "imgly_lut_elder" },
         *     { identifier: "imgly_lut_orchid" },
         *     { identifier: "imgly_lut_bleached" },
         *     { identifier: "imgly_lut_bleachedblue" },
         *     { identifier: "imgly_lut_breeze" },
         *     { identifier: "imgly_lut_blueshadows" },
         *   ]},
         *   { identifier: "imgly_filter_category_warm", items: [
         *     { identifier: "imgly_lut_sunset" },
         *     { identifier: "imgly_lut_eighties" },
         *     { identifier: "imgly_lut_evening" },
         *     { identifier: "imgly_lut_k2" },
         *     { identifier: "imgly_lut_nogreen" },
         *   ]},
         *   { identifier: "imgly_filter_category_legacy", items: [
         *     { identifier: "imgly_lut_ancient" },
         *     { identifier: "imgly_lut_cottoncandy" },
         *     { identifier: "imgly_lut_classic" },
         *     { identifier: "imgly_lut_colorful" },
         *     { identifier: "imgly_lut_creamy" },
         *     { identifier: "imgly_lut_fixie" },
         *     { identifier: "imgly_lut_food" },
         *     { identifier: "imgly_lut_fridge" },
         *     { identifier: "imgly_lut_glam" },
         *     { identifier: "imgly_lut_gobblin" },
         *     { identifier: "imgly_lut_highcontrast" },
         *     { identifier: "imgly_lut_highcarb" },
         *     { identifier: "imgly_lut_k1" },
         *     { identifier: "imgly_lut_k6" },
         *     { identifier: "imgly_lut_keen" },
         *     { identifier: "imgly_lut_lomo" },
         *     { identifier: "imgly_lut_lomo100" },
         *     { identifier: "imgly_lut_lucid" },
         *     { identifier: "imgly_lut_mellow" },
         *     { identifier: "imgly_lut_neat" },
         *     { identifier: "imgly_lut_pale" },
         *     { identifier: "imgly_lut_pitched" },
         *     { identifier: "imgly_lut_polasx" },
         *     { identifier: "imgly_lut_pro400" },
         *     { identifier: "imgly_lut_quozi" },
         *     { identifier: "imgly_lut_settled" },
         *     { identifier: "imgly_lut_seventies" },
         *     { identifier: "imgly_lut_soft" },
         *     { identifier: "imgly_lut_steel" },
         *     { identifier: "imgly_lut_summer" },
         *     { identifier: "imgly_lut_tender" },
         *     { identifier: "imgly_lut_twilight" },
         *   ]},
         * ]
         */
        this.categories = [];
        /**
         * Whether categories should be flattened which effectively hides the categories.
         * If this is enabled all filters will be shown in the top-level of the filter selection tool
         * orderes according to their parent category.
         * @example // Defaults to:
         * false
         */
        this.flattenCategories = false;
        /**
         * Controls if the user can load the preview thumbnail for every filter.
         * @example // Defaults to:
         * true
         */
        this.enablePreviewThumbnails = false;
    }
    return FilterConfiguration;
}());

function isDuoToneFilterAsset(asset) {
    return asset.lightColor !== undefined;
}
function isLUTFilterAsset(asset) {
    return asset.lutURI !== undefined;
}

var FocusConfiguration = /** @class */ (function () {
    function FocusConfiguration() {
        /**
         * Defines all allowed focus tools. The focus tool buttons are shown in the given order.
         * `NONE` is always added in Basic UI
         * @example // Defaults to:
         * [
         *  { identifier: FocusTool.RADIAL },
         *  { identifier: FocusTool.MIRRORED },
         *  { identifier: FocusTool.LINEAR },
         *  { identifier: FocusTool.GAUSSIAN },
         * ]
         */
        this.items = [];
    }
    return FocusConfiguration;
}());

var FocusIdentifier;
(function (FocusIdentifier) {
    FocusIdentifier["RADIAL"] = "radial";
    FocusIdentifier["LINEAR"] = "linear";
    FocusIdentifier["MIRRORED"] = "mirrored";
    FocusIdentifier["GAUSSIAN"] = "gaussian";
})(FocusIdentifier || (FocusIdentifier = {}));

var FrameConfiguration = /** @class */ (function () {
    function FrameConfiguration() {
        /**
         * Defines all available frames.
         * New items can be mixed and matched with existing predefined ones.
         * `NONE` is always added for Basic UI
         * @example // Defaults to:
         * [
         *    { identifier: "imgly_frame_dia" },
         *    { identifier: "imgly_frame_art_decor" },
         *    { identifier: "imgly_frame_black_passepartout" },
         *    { identifier: "imgly_frame_wood_passepartout" },
         *    { identifier: "imgly_frame_lowpoly_shadow" },
         * ]
         */
        this.items = [];
    }
    return FrameConfiguration;
}());

var LibraryCategory = /** @class */ (function () {
    function LibraryCategory(image) {
        this.name = image.name;
        this.coverImageUrl = image.coverImageUrl;
    }
    LibraryCategory.prototype.loadCoverImage = function (crossOrigin) {
        var _this = this;
        if (crossOrigin === void 0) { crossOrigin = 'anonymous'; }
        return new Promise(function (resolve, reject) {
            var image = new Image();
            image.addEventListener('load', function () {
                resolve(image);
            });
            image.addEventListener('error', function () {
                reject(new Error("Failed to load image at " + _this.coverImage));
            });
            image.crossOrigin = crossOrigin;
            image.src = _this.coverImageUrl;
            _this.coverImage = image;
        });
    };
    return LibraryCategory;
}());

var LibraryImage = /** @class */ (function () {
    function LibraryImage(image) {
        this.category = image.title;
        this.thumbUrl = image.thumbUrl;
        this.rawUrl = image.rawUrl;
    }
    LibraryImage.prototype.loadThumbImage = function (crossOrigin) {
        var _this = this;
        if (crossOrigin === void 0) { crossOrigin = 'anonymous'; }
        return new Promise(function (resolve, reject) {
            var image = new Image();
            image.addEventListener('load', function () {
                resolve(image);
            });
            image.addEventListener('error', function () {
                reject(new Error("Failed to load image at " + _this.thumbUrl));
            });
            image.crossOrigin = crossOrigin;
            image.src = _this.thumbUrl;
            _this.thumbImage = image;
        });
    };
    LibraryImage.prototype.getThumbImage = function () {
        return this.thumbUrl;
    };
    return LibraryImage;
}());

var LibraryConfiguration = /** @class */ (function () {
    function LibraryConfiguration() {
        this.enableWebcam = false;
        this.enableUpload = false;
    }
    return LibraryConfiguration;
}());

var JSONLoader = /** @class */ (function () {
    function JSONLoader() {
    }
    // eslint-disable-next-line class-methods-use-this
    JSONLoader.prototype.getData = function (url) {
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = 'json';
            xhr.onload = function () {
                var status = xhr.status;
                if (status === 200) {
                    resolve(xhr.response);
                }
                else {
                    reject(new Error("HTTP Status " + status));
                }
            };
            xhr.send();
        });
    };
    return JSONLoader;
}());

/* eslint-disable class-methods-use-this */
var LibraryProvider = /** @class */ (function () {
    function LibraryProvider(data) {
        this.data = {};
        this.data = data;
    }
    LibraryProvider.prototype.loadJSON = function (url) {
        var loader = new JSONLoader();
        return loader.getData(url);
    };
    LibraryProvider.prototype.getCategories = function () {
        return Promise.resolve([]);
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    LibraryProvider.prototype.searchImages = function (_) {
        return Promise.resolve([]);
    };
    return LibraryProvider;
}());

var OverlayConfiguration = /** @class */ (function () {
    function OverlayConfiguration() {
        /**
         * Defines all available overlays.
         * New items can be mixed and matched with existing predefined ones.
         * `NONE` is always added in Basic UI
         * @example // Defaults to:
         * [
         *   { identifier: "imgly_overlay_golden" },
         *   { identifier: "imgly_overlay_lightleak1" },
         *   { identifier: "imgly_overlay_rain" },
         *   { identifier: "imgly_overlay_mosaic" },
         *   { identifier: "imgly_overlay_vintage" },
         *   { identifier: "imgly_overlay_paper" },
         *   { identifier: "imgly_overlay_bokeh" },
         *   { identifier: "imgly_overlay_hearts" },
         *   { identifier: "imgly_overlay_lightleak2" },
         *   { identifier: "imgly_overlay_wood" },
         *   { identifier: "imgly_overlay_chop" },
         *   { identifier: "imgly_overlay_metal" },
         *   { identifier: "imgly_overlay_painting" },
         *   { identifier: "imgly_overlay_grain" },
         *   { identifier: "imgly_overlay_clouds" },
         *   { identifier: "imgly_overlay_wall1" },
         *   { identifier: "imgly_overlay_wall2" },
         * ]
         */
        this.items = [];
    }
    return OverlayConfiguration;
}());

var BlendMode;
(function (BlendMode) {
    BlendMode["NORMAL"] = "normal";
    BlendMode["OVERLAY"] = "overlay";
    BlendMode["SOFT_LIGHT"] = "softLight";
    BlendMode["HARD_LIGHT"] = "hardLight";
    BlendMode["MULTIPLY"] = "multiply";
    BlendMode["DARKEN"] = "darken";
    BlendMode["COLOR_BURN"] = "colorBurn";
    BlendMode["SCREEN"] = "screen";
    BlendMode["LIGHTEN"] = "lighten";
})(BlendMode || (BlendMode = {}));

var StickerConfiguration = /** @class */ (function () {
    function StickerConfiguration() {
        /**
         * Defines all available stickers. Each sticker must be assigned to a category.
         * New items and categories can be mixed and matched with existing predefined ones.
         * @example // Defaults to:
         * [
         *   { identifier: "imgly_sticker_category_emoticons", items: [
         *     { identifier: "imgly_sticker_emoticons_grin" },
         *     { identifier: "imgly_sticker_emoticons_laugh" },
         *     { identifier: "imgly_sticker_emoticons_smile" },
         *     { identifier: "imgly_sticker_emoticons_wink" },
         *     { identifier: "imgly_sticker_emoticons_tongue_out_wink" },
         *     { identifier: "imgly_sticker_emoticons_angel" },
         *     { identifier: "imgly_sticker_emoticons_kisses" },
         *     { identifier: "imgly_sticker_emoticons_loving" },
         *     { identifier: "imgly_sticker_emoticons_kiss" },
         *     { identifier: "imgly_sticker_emoticons_wave" },
         *     { identifier: "imgly_sticker_emoticons_nerd" },
         *     { identifier: "imgly_sticker_emoticons_cool" },
         *     { identifier: "imgly_sticker_emoticons_blush" },
         *     { identifier: "imgly_sticker_emoticons_duckface" },
         *     { identifier: "imgly_sticker_emoticons_furious" },
         *     { identifier: "imgly_sticker_emoticons_angry" },
         *     { identifier: "imgly_sticker_emoticons_steaming_furious" },
         *     { identifier: "imgly_sticker_emoticons_sad" },
         *     { identifier: "imgly_sticker_emoticons_anxious" },
         *     { identifier: "imgly_sticker_emoticons_cry" },
         *     { identifier: "imgly_sticker_emoticons_sobbing" },
         *     { identifier: "imgly_sticker_emoticons_loud_cry" },
         *     { identifier: "imgly_sticker_emoticons_wide_grin" },
         *     { identifier: "imgly_sticker_emoticons_impatient" },
         *     { identifier: "imgly_sticker_emoticons_tired" },
         *     { identifier: "imgly_sticker_emoticons_asleep" },
         *     { identifier: "imgly_sticker_emoticons_sleepy" },
         *     { identifier: "imgly_sticker_emoticons_deceased" },
         *     { identifier: "imgly_sticker_emoticons_attention" },
         *     { identifier: "imgly_sticker_emoticons_question" },
         *     { identifier: "imgly_sticker_emoticons_not_speaking_to_you" },
         *     { identifier: "imgly_sticker_emoticons_sick" },
         *     { identifier: "imgly_sticker_emoticons_pumpkin" },
         *     { identifier: "imgly_sticker_emoticons_boxer" },
         *     { identifier: "imgly_sticker_emoticons_idea" },
         *     { identifier: "imgly_sticker_emoticons_smoking" },
         *     { identifier: "imgly_sticker_emoticons_beer" },
         *     { identifier: "imgly_sticker_emoticons_skateboard" },
         *     { identifier: "imgly_sticker_emoticons_guitar" },
         *     { identifier: "imgly_sticker_emoticons_music" },
         *     { identifier: "imgly_sticker_emoticons_sunbathing" },
         *     { identifier: "imgly_sticker_emoticons_hippie" },
         *     { identifier: "imgly_sticker_emoticons_humourous" },
         *     { identifier: "imgly_sticker_emoticons_hitman" },
         *     { identifier: "imgly_sticker_emoticons_harry_potter" },
         *     { identifier: "imgly_sticker_emoticons_business" },
         *     { identifier: "imgly_sticker_emoticons_batman" },
         *     { identifier: "imgly_sticker_emoticons_skull" },
         *     { identifier: "imgly_sticker_emoticons_ninja" },
         *     { identifier: "imgly_sticker_emoticons_masked" },
         *     { identifier: "imgly_sticker_emoticons_alien" },
         *     { identifier: "imgly_sticker_emoticons_wrestler" },
         *     { identifier: "imgly_sticker_emoticons_devil" },
         *     { identifier: "imgly_sticker_emoticons_star" },
         *     { identifier: "imgly_sticker_emoticons_baby_chicken" },
         *     { identifier: "imgly_sticker_emoticons_rabbit" },
         *     { identifier: "imgly_sticker_emoticons_pig" },
         *     { identifier: "imgly_sticker_emoticons_chicken" },
         *   ]},
         *   { identifier: "imgly_sticker_category_shapes", items: [
         *     { identifier: "imgly_sticker_shapes_badge_01" },
         *     { identifier: "imgly_sticker_shapes_badge_04" },
         *     { identifier: "imgly_sticker_shapes_badge_12" },
         *     { identifier: "imgly_sticker_shapes_badge_06" },
         *     { identifier: "imgly_sticker_shapes_badge_13" },
         *     { identifier: "imgly_sticker_shapes_badge_36" },
         *     { identifier: "imgly_sticker_shapes_badge_08" },
         *     { identifier: "imgly_sticker_shapes_badge_11" },
         *     { identifier: "imgly_sticker_shapes_badge_35" },
         *     { identifier: "imgly_sticker_shapes_badge_28" },
         *     { identifier: "imgly_sticker_shapes_badge_32" },
         *     { identifier: "imgly_sticker_shapes_badge_15" },
         *     { identifier: "imgly_sticker_shapes_badge_20" },
         *     { identifier: "imgly_sticker_shapes_badge_18" },
         *     { identifier: "imgly_sticker_shapes_badge_19" },
         *     { identifier: "imgly_sticker_shapes_arrow_02" },
         *     { identifier: "imgly_sticker_shapes_arrow_03" },
         *     { identifier: "imgly_sticker_shapes_spray_01" },
         *     { identifier: "imgly_sticker_shapes_spray_04" },
         *     { identifier: "imgly_sticker_shapes_spray_03" },
         *   ]},
         * ]
         */
        this.categories = [];
        /**
         * Defines all allowed actions for the sticker tool menu. Only buttons
         * for allowed actions are visible and shown in the given order.
         * @example // Defaults to:
         * [CanvasAction.BRING_TO_FRONT, CanvasAction.DUPLICATE, CanvasAction.DELETE]
         */
        this.canvasActions = [CanvasAction.BRING_TO_FRONT, CanvasAction.FLIP, CanvasAction.DUPLICATE, CanvasAction.DELETE];
        this.enableCustomUpload = true;
        this.customStickerTintMode = 'none';
    }
    return StickerConfiguration;
}());

function isStickerAssetDynamic(sticker) {
    return sticker.sticker !== undefined;
}
function isStickerCategoryDynamic(sticker) {
    return sticker.thumbnail !== undefined;
}

var TextConfiguration = /** @class */ (function () {
    function TextConfiguration() {
        /**
         * Defines all available fonts.
         * New items can be mixed and matched with existing predefined ones.
         * @example // Defaults to:
         * [
         *   { identifier: "imgly_font_open_sans_bold" },
         *   { identifier: "imgly_font_aleo_bold" },
         *   { identifier: "imgly_font_amaticsc" },
         *   { identifier: "imgly_font_bernier_regular" },
         *   { identifier: "imgly_font_cheque_regular" },
         *   { identifier: "imgly_font_gagalin_regular" },
         *   { identifier: "imgly_font_hagin_caps_thin" },
         *   { identifier: "imgly_font_intro_inline" },
         *   { identifier: "imgly_font_lobster" },
         *   { identifier: "imgly_font_nexa_script" },
         *   { identifier: "imgly_font_ostrich_sans_black" },
         *   { identifier: "imgly_font_ostrich_sans_bold" },
         *   { identifier: "imgly_font_panton_blackitalic_caps" },
         *   { identifier: "imgly_font_panton_lightitalic_caps" },
         *   { identifier: "imgly_font_perfograma" },
         *   { identifier: "imgly_font_trash_hand" },
         * ]
         */
        this.fonts = [];
        /**
         * Defines all allowed actions for the sticker tool menu. Only buttons
         * for allowed actions are visible and shown in the given order.
         * @example // Defaults to:
         * [CanvasAction.EDIT, CanvasAction.BRING_TO_FRONT, CanvasAction.DUPLICATE, CanvasAction.DELETE]
         */
        this.canvasActions = [CanvasAction.EDIT, CanvasAction.BRING_TO_FRONT, CanvasAction.DUPLICATE, CanvasAction.DELETE];
    }
    return TextConfiguration;
}());

function isWebFontAsset(asset) {
    return asset.provider === undefined || asset.provider === 'file';
}
function isGoogleFontAsset(asset) {
    return asset.provider === 'google';
}

var BrushConfiguration = /** @class */ (function () {
    function BrushConfiguration() {
    }
    return BrushConfiguration;
}());

var TextDesignConfiguration = /** @class */ (function () {
    function TextDesignConfiguration() {
        /**
         * Defines all available text designs.
         * New items can be mixed and matched with existing predefined ones.
         * @example // Defaults to:
         * [
         *   { identifier: "imgly_text_design_blocks" },
         *   { identifier: "imgly_text_design_rotated" },
         *   { identifier: "imgly_text_design_blocks_light" },
         *   { identifier: "imgly_text_design_equal_width" },
         *   { identifier: "imgly_text_design_masked" },
         *   { identifier: "imgly_text_design_celebrate" },
         *   { identifier: "imgly_text_design_sunshine" },
         *   { identifier: "imgly_text_design_masked_badge" },
         *   { identifier: "imgly_text_design_blocks_condensed" },
         *   { identifier: "imgly_text_design_celebrate_simple" },
         *   { identifier: "imgly_text_design_equal_width_fat" },
         *   { identifier: "imgly_text_design_watercolor" },
         *   { identifier: "imgly_text_design_particles" },
         *   { identifier: "imgly_text_design_masked_speech_bubble" },
         *   { identifier: "imgly_text_design_masked_speech_bubble_comic" },
         *   { identifier: "imgly_text_design_multiline" },
         * ]
         */
        this.items = [];
        /**
         * Defines all allowed actions for the sticker tool menu. Only buttons
         * for allowed actions are visible and shown in the given order.
         * @example // Defaults to:
         * [CanvasAction.EDIT, CanvasAction.DUPLICATE, CanvasAction.DELETE, CanvasAction.INVERT]
         */
        this.canvasActions = [CanvasAction.EDIT, CanvasAction.BRING_TO_FRONT, CanvasAction.INVERT, CanvasAction.DUPLICATE, CanvasAction.DELETE];
    }
    return TextDesignConfiguration;
}());

var TransformConfiguration = /** @class */ (function () {
    function TransformConfiguration() {
        /**
         * Defines all allowed crop aspect ratios. The crop ratio cards are shown in the given order.
         * @example // Defaults to:
         *[{
         *  "identifier": "imgly_transforms_common",
         *  "items": [
         *    { "identifier": "imgly_transform_common_custom" },
         *    { "identifier": "imgly_transform_common_square" },
         *    { "identifier": "imgly_transform_common_4" },
         *    { "identifier": "imgly_transform_common_16" },
         *    { "identifier": "imgly_transform_common_3" },
         *    { "identifier": "imgly_transform_common_9" },
         *  ]
         *}, {
         *  "identifier": "imgly_transforms_facebook",
         *    "items": [
         *      { "identifier": "imgly_transform_facebook_profile" },
         *      { "identifier": "imgly_transform_facebook_title" },
         *      { "identifier": "imgly_transform_facebook_post" },
         *  ]
         *}, {
         *  "identifier": "imgly_transforms_instagram",
         *    "items": [
         *      { "identifier": "imgly_transform_instagram_story" },
         *      { "identifier": "imgly_transform_instagram_landscape" },
         *      { "identifier": "imgly_transform_instagram_portrait" },
         *      { "identifier": "imgly_transform_instagram_square" },
         *  ]
         *}, {
         *  "identifier": "imgly_transforms_twitter",
         *    "items": [
         *      { "identifier": "imgly_transform_twitter_profile" },
         *      { "identifier": "imgly_transform_twitter_title" },
         *      { "identifier": "imgly_transform_twitter_post" },
         *  ]
         *}]
         */
        this.categories = [];
        /**
         * Decides whether rotation is enabled
         * @example // Defaults to:
         * true
         */
        this.enableRotation = true;
        /**
         * Decides whether flip is enabled
         * @example // Defaults to:
         * true
         */
        this.enableFlip = true;
    }
    return TransformConfiguration;
}());

var TransformIdentifier;
(function (TransformIdentifier) {
    TransformIdentifier["CommonCategory"] = "imgly_transforms_common";
    TransformIdentifier["FacebookCategory"] = "imgly_transforms_facebook";
    TransformIdentifier["TwitterCategory"] = "imgly_transforms_twitter";
    TransformIdentifier["InstagramCategory"] = "imgly_transforms_instagram";
    TransformIdentifier["Custom"] = "imgly_transform_common_custom";
    TransformIdentifier["Square"] = "imgly_transform_common_square";
    TransformIdentifier["ThreeByFour"] = "imgly_transform_common_3";
    TransformIdentifier["FourByThree"] = "imgly_transform_common_4";
    TransformIdentifier["NineBySixteen"] = "imgly_transform_common_9";
    TransformIdentifier["SixteenByNine"] = "imgly_transform_common_16";
    TransformIdentifier["FacebookPost"] = "imgly_transform_facebook_post";
    TransformIdentifier["FacebookProfile"] = "imgly_transform_facebook_profile";
    TransformIdentifier["FacebookTitle"] = "imgly_transform_facebook_title";
    TransformIdentifier["InstagramLandscape"] = "imgly_transform_instagram_landscape";
    TransformIdentifier["InstagramPortrait"] = "imgly_transform_instagram_portrait";
    TransformIdentifier["InstagramSquare"] = "imgly_transform_instagram_square";
    TransformIdentifier["InstagramStory"] = "imgly_transform_instagram_story";
    TransformIdentifier["TwitterPost"] = "imgly_transform_twitter_post";
    TransformIdentifier["TwitterProfile"] = "imgly_transform_twitter_profile";
    TransformIdentifier["TwitterTitle"] = "imgly_transform_twitter_title";
})(TransformIdentifier || (TransformIdentifier = {}));

var UIEvent;
(function (UIEvent) {
    UIEvent["EXPORT"] = "export";
    UIEvent["CLOSE"] = "close";
    UIEvent["HISTORY_CHANGE"] = "historyChange";
    UIEvent["EDITOR_READY"] = "editorReady";
})(UIEvent || (UIEvent = {}));

/**
 * A class used to receive and emit events.
 */
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this.events = {};
    }
    /**
     * Adds the `listener` function to the end of the list of listeners for the specified `event`.
     * No checks are made to see if `listener` has already been added. Multiple calls passing the
     * same combination of `event` and `listener` will result in the `listener` being added, and
     * called, multiple times.
     * @param event The name of the event.
     * @param listener The callback function.
     */
    EventEmitter.prototype.addListener = function (event, listener) {
        var listeners = (this.events[event] || (this.events[event] = []));
        listeners.push(listener);
        return this;
    };
    /**
     * Removes the most recently added instance of `listener` from the list of listeners for the
     * specified `event`.
     *
     * Once an event has been emitted, all listeners attached to it at the time of emitting will
     * be called in order. This implies that any `removeListener` or `removeAllListeners` calls
     * after emitting and before the last listener finishes execution will not remove them from
     * `emit()` in progress. Subsequent events will behave as expected.
     * @param event The name of the event.
     * @param listener The callback function to be removed.
     */
    EventEmitter.prototype.removeListener = function (event, listener) {
        var listeners = this.events[event];
        if (!listeners) {
            return this;
        }
        var index = listeners.lastIndexOf(listener);
        if (index === -1) {
            return this;
        }
        listeners.splice(index, 1);
        return this;
    };
    /**
     * Removes all previously registered listeners for the specified `event`.
     * @param event The name of the event.
     */
    EventEmitter.prototype.removeAllListeners = function (event) {
        this.events[event] = undefined;
        return this;
    };
    /**
     * @see {@link addListener}
     */
    EventEmitter.prototype.on = function (event, listener) {
        return this.addListener(event, listener);
    };
    /**
     * @see {@link removeListener}
     */
    EventEmitter.prototype.off = function (event, listener) {
        return this.removeListener(event, listener);
    };
    /**
     * Emits the event to all of its registered listeners.
     * @param event The event to be emitted to its listeners.
     * @param args The arguments to be passed along with the event.
     * @returns `false` if there were no listeners for the emitted event.
     */
    EventEmitter.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var listeners = this.events[event];
        if (!listeners || !listeners.length) {
            return false;
        }
        // eslint-disable-next-line prefer-spread
        listeners.slice(0).forEach(function (fn) { return fn.apply(null, args); });
        return true;
    };
    return EventEmitter;
}());

var RectTransform = /** @class */ (function () {
    function RectTransform(position, scale, rotation) {
        if (scale === void 0) { scale = { x: 1, y: 1 }; }
        if (rotation === void 0) { rotation = 0; }
        this.position = position;
        this.scale = scale;
        this.rotation = rotation;
    }
    Object.defineProperty(RectTransform, "IDENTITY", {
        get: function () { return new RectTransform({ x: 0, y: 0 }); },
        enumerable: true,
        configurable: true
    });
    return RectTransform;
}());

var Vector2 = /** @class */ (function () {
    function Vector2(x, y) {
        if (typeof x === 'number') {
            this.x = x;
            this.y = y;
        }
        else {
            this.x = x.x;
            this.y = x.y;
        }
    }
    Vector2.fromSize = function (size) {
        return new Vector2(size.width, size.height);
    };
    /**
     * @returns The distance between two vectors.
     */
    Vector2.distance = function (lhs, rhs) {
        var dX = rhs.x - lhs.x;
        var dY = rhs.y - lhs.y;
        return Math.sqrt(dX * dX + dY * dY);
    };
    /**
     * @returns The dot product of two vectors.
     */
    Vector2.dot = function (lhs, rhs) {
        return lhs.x * rhs.x + lhs.y * rhs.y;
    };
    /**
     * Linearly interpolates between two vectors by t. t gets clamped to [0, 1].
     * When t === 0, returns lhs.
     * When t === 1, returns rhs.
     * @param t The interpolation weight
     */
    Vector2.lerp = function (lhs, rhs, t) {
        var w = Math.min(Math.max(t, 0), 1);
        return new Vector2(lhs.x * w + rhs.x * (1 - w), lhs.y * w + rhs.y * (1 - w));
    };
    /**
     * Linearly interpolates between two vectors by t.
     * When t === 0, returns lhs.
     * When t === 1, returns rhs.
     * @param t The interpolation weight
     */
    Vector2.lerpUnclamped = function (lhs, rhs, t) {
        return new Vector2(lhs.x * t + rhs.x * (1 - t), lhs.y * t + rhs.y * (1 - t));
    };
    /**
     * Calculates a proportionally scaled version of `toFit`, whose axis-aligned bounding
     * box (AABB) fits within the AABB spanned by `bounds`.
     * @param bounds A vector spanning a reference AABB, which the result should fit into.
     * @param toFit A vector that should be scaled to fit the AABB defined by `bounds`.
     */
    Vector2.proportionalFit = function (bounds, toFit) {
        var boundsAspect = bounds.x / bounds.y;
        var toFitAspect = toFit.x / toFit.y;
        if (boundsAspect > toFitAspect) {
            return toFit.multiply(bounds.y / toFit.y);
        }
        else {
            return toFit.multiply(bounds.x / toFit.x);
        }
    };
    Object.defineProperty(Vector2.prototype, "magnitude", {
        /**
         * @returns The euclidean length of this vector.
         */
        get: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector2.prototype, "normalized", {
        /**
         * @returns A unit-length vector which points in the same direction as this vector.
         */
        get: function () {
            var magn = this.magnitude;
            return new Vector2(this.x / magn, this.y / magn);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector2.prototype, "floored", {
        /**
         * @returns Both components of this vector floored.
         */
        get: function () {
            return new Vector2(Math.floor(this.x), Math.floor(this.y));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector2.prototype, "min", {
        /**
         * @returns The smaller of the two components.
         */
        get: function () {
            return Math.min(this.x, this.y);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector2.prototype, "max", {
        /**
         * @returns The larger of the two components.
         */
        get: function () {
            return Math.max(this.x, this.y);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector2.prototype, "abs", {
        /**
         * @returns A vector with absolute values of this vector's components.
         */
        get: function () {
            return new Vector2(Math.abs(this.x), Math.abs(this.y));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector2.prototype, "swapped", {
        /**
         * @returns A vector with swapped values of this vector's components.
         */
        get: function () {
            return new Vector2(this.y, this.x);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @returns A new copy of this vector.
     */
    Vector2.prototype.clone = function () {
        return new Vector2(this.x, this.y);
    };
    Vector2.prototype.add = function (x, y) {
        if (typeof x === 'number') {
            return new Vector2(this.x + x, this.y + y);
        }
        else {
            return new Vector2(this.x + x.x, this.y + x.y);
        }
    };
    Vector2.prototype.subtract = function (x, y) {
        if (typeof x === 'number') {
            return new Vector2(this.x - x, this.y - y);
        }
        else {
            return new Vector2(this.x - x.x, this.y - x.y);
        }
    };
    Vector2.prototype.multiply = function (x, y) {
        if (typeof x === 'number') {
            return new Vector2(this.x * x, this.y * (y === undefined ? x : y));
        }
        else {
            return new Vector2(this.x * x.x, this.y * x.y);
        }
    };
    Vector2.prototype.divide = function (x, y) {
        if (typeof x === 'number') {
            return new Vector2(this.x / x, this.y / (y === undefined ? x : y));
        }
        else {
            return new Vector2(this.x / x.x, this.y / x.y);
        }
    };
    /**
     * Checks whether the vector component are the same.
     * @param other The vector that this vector should be compared to.
     */
    Vector2.prototype.equals = function (other) {
        return this.x === other.x && this.y === other.y;
    };
    Vector2.ZERO = new Vector2(0, 0);
    Vector2.ONE = new Vector2(1, 1);
    Vector2.UP = new Vector2(0, 1);
    Vector2.DOWN = new Vector2(0, -1);
    Vector2.RIGHT = new Vector2(1, 0);
    Vector2.LEFT = new Vector2(-1, 0);
    return Vector2;
}());

var Rect = /** @class */ (function () {
    function Rect(origin, size, width, height) {
        if (typeof origin === 'number') {
            if (typeof size === 'number' && width !== undefined && height !== undefined) {
                this.origin = { x: origin, y: size };
                this.size = { width: width || 0, height: height || 0 };
            }
            else {
                throw new Error('Invalid arguments passed to Rect. Expected (number, number, number, number)');
            }
        }
        else {
            this.origin = origin;
            if (typeof size === 'number') {
                throw new Error('Invalid arguments passed to Rect. Expected (Float2, Size)');
            }
            this.size = size;
        }
    }
    /**
     * Checks whether the given point is within the rect.
     * @returns - True if `point` is within the bounds of `rect`
     */
    Rect.contains = function (rect, point) {
        return point.x >= rect.minX && point.x <= rect.maxX && point.y >= rect.minY && point.y <= rect.maxY;
    };
    Object.defineProperty(Rect.prototype, "minX", {
        get: function () {
            return this.origin.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "minY", {
        get: function () {
            return this.origin.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "midX", {
        get: function () {
            return this.origin.x + 0.5 * this.size.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "midY", {
        get: function () {
            return this.origin.y + 0.5 * this.size.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "maxX", {
        get: function () {
            return this.origin.x + this.size.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "maxY", {
        get: function () {
            return this.origin.y + this.size.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "width", {
        get: function () {
            return this.size.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rect.prototype, "height", {
        get: function () {
            return this.size.height;
        },
        enumerable: true,
        configurable: true
    });
    Rect.ZERO = new Rect({ x: 0, y: 0 }, { width: 0, height: 0 });
    return Rect;
}());

/**
 * A transformation matrix which can be used to rotate, scale,
 * translate or skew objects in 2D space.
 *
 * The transform is represented by a 3x3 matrix as follows:
 *
 *    a   b   tx
 *    c   d   ty
 *    0   0   1
 *
 * The last row is always [0 0 1], so it is not explicitly stored
 * by the AffineTransform.
 *
 * In order to transform a point p = (x, y, 1) with an
 * AffineTransform M it needs to be multiplied as follows:
 *
 *    p' = M * p
 */
var AffineTransform = /** @class */ (function () {
    function AffineTransform(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    }
    /**
     * Creates an AffineTransform from the given scale factors
     * @param scaleX - The scale component on the x-axis
     * @param scaleY - The scale component on the y-axis
     */
    AffineTransform.fromScale = function (scaleX, scaleY) {
        return new AffineTransform(scaleX, 0, 0, scaleY, 0, 0);
    };
    /**
     * Creates an AffineTransform from the given rotation in radians
     * @param rotation - The rotation in radians
     */
    AffineTransform.fromRotation = function (rotation) {
        var cosPhi = Math.cos(rotation);
        var sinPhi = Math.sin(rotation);
        return new AffineTransform(cosPhi, -sinPhi, sinPhi, cosPhi, 0, 0);
    };
    /**
     * Creates an AffineTransform from the given rotation in degrees
     * @param rotation - The rotation in degrees
     */
    AffineTransform.fromRotationDeg = function (rotation) {
        var rad = Math.PI * rotation / 180;
        return this.fromRotation(rad);
    };
    /**
     * Creates an AffineTransform from the given translation
     * @param tx - The translation component on the x-axis
     * @param ty - The translation component on the y-axis
     */
    AffineTransform.fromTranslation = function (tx, ty) {
        return new AffineTransform(1, 0, 0, 1, tx, ty);
    };
    /**
     * Creates an AffineTransform from the given translation,
     * rotation and scale. Applying this matrix will first
     * scale, then rotate and then translate.
     * @param tx - The translation component on the x-axis
     * @param ty - The translation component on the y-axis
     * @param rotation - The rotation in radians
     * @param sX - The scale component on the x-axis
     * @param sY - The scale component on the y-axis
     */
    AffineTransform.fromTRS = function (tx, ty, rotation, sx, sy) {
        var cosPhi = Math.cos(rotation);
        var sinPhi = Math.sin(rotation);
        return new AffineTransform(sx * cosPhi, -sy * sinPhi, sx * sinPhi, sy * cosPhi, tx, ty);
    };
    AffineTransform.multiply = function (lhs, rhs) {
        var a = lhs.a * rhs.a + lhs.b * rhs.c;
        var b = lhs.a * rhs.b + lhs.b * rhs.d;
        var c = lhs.c * rhs.a + lhs.d * rhs.c;
        var d = lhs.c * rhs.b + lhs.d * rhs.d;
        var tx = lhs.a * rhs.tx + lhs.b * rhs.ty + lhs.tx;
        var ty = lhs.c * rhs.tx + lhs.d * rhs.ty + lhs.ty;
        return new AffineTransform(a, b, c, d, tx, ty);
    };
    /**
     * Returns lhs * point
     * @param lhs - The transformation to be applied to the point
     * @param point - The 2D point to be transformed
     */
    AffineTransform.transformPoint = function (lhs, point) {
        return {
            x: lhs.a * point.x + lhs.b * point.y + lhs.tx,
            y: lhs.c * point.x + lhs.d * point.y + lhs.ty,
        };
    };
    /**
     * Returns an affine transformation matrix constructed by inverting
     * an existing affine transform.
     * @param transform - The existing affine transform
     * @returns - A new affine transform. If the specified affine transform
     * cannot be inverted, the original transform is returned
     */
    AffineTransform.getInverted = function (transform) {
        var determinant = transform.a * transform.d - transform.b * transform.c;
        // If the determinant is 0, then an inverted transform doesn't exist
        // and we just return the original transform
        if (determinant === 0) {
            return transform;
        }
        var invDet = 1 / determinant;
        var a = invDet * transform.d;
        var b = -invDet * transform.b;
        var c = -invDet * transform.c;
        var d = invDet * transform.a;
        var tx = invDet * (transform.b * transform.ty - transform.d * transform.tx);
        var ty = invDet * (transform.c * transform.tx - transform.a * transform.ty);
        return new AffineTransform(a, b, c, d, tx, ty);
    };
    /**
     * The identitiy transform
     */
    AffineTransform.IDENTITY = AffineTransform.fromScale(1, 1);
    return AffineTransform;
}());

function isNumber(val) {
    return typeof val === 'number';
}

/**
 * @returns A generated UUID string
 */
function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

var now = window.performance.now.bind(window.performance);

// Based on FontFaceObserver by Bram Stein
// Copyright (c) 2014 - Bram Stein
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
var FontFaceRuler = /** @class */ (function () {
    function FontFaceRuler(text) {
        this.text = text;
        this.lastOffsetWidth = -1;
        var style = 'max-width:none;' +
            'display:inline-block;' +
            'position:absolute;' +
            'height:100%;' +
            'width:100%;' +
            'overflow:scroll;' +
            'font-size:16px;';
        this.element = document.createElement('div');
        this.element.setAttribute('aria-hidden', 'true');
        this.element.appendChild(document.createTextNode(text));
        this.collapsible = document.createElement('span');
        this.expandable = document.createElement('span');
        this.collapsibleInner = document.createElement('span');
        this.expandableInner = document.createElement('span');
        this.collapsible.style.cssText = style;
        this.expandable.style.cssText = style;
        this.expandableInner.style.cssText = style;
        this.collapsibleInner.style.cssText = 'display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;';
        this.collapsible.appendChild(this.collapsibleInner);
        this.expandable.appendChild(this.expandableInner);
        this.element.appendChild(this.collapsible);
        this.element.appendChild(this.expandable);
    }
    FontFaceRuler.prototype.getElement = function () {
        return this.element;
    };
    FontFaceRuler.prototype.setFont = function (font) {
        this.element.style.cssText = 'max-width:none;' +
            'min-width:20px;' +
            'min-height:20px;' +
            'display:inline-block;' +
            'overflow:hidden;' +
            'position:absolute;' +
            'width:auto;' +
            'margin:0;' +
            'padding:0;' +
            'top:-999px;' +
            'white-space:nowrap;' +
            'font-synthesis:none;' +
            'font:' + font + ';';
    };
    FontFaceRuler.prototype.getWidth = function () {
        return this.element.offsetWidth;
    };
    FontFaceRuler.prototype.setWidth = function (width) {
        this.element.style.width = width + 'px';
    };
    FontFaceRuler.prototype.onResize = function (callback) {
        var _this = this;
        var onScroll = function () {
            _this.onScroll(callback);
        };
        this.collapsible.addEventListener('scroll', onScroll);
        this.expandable.addEventListener('scroll', onScroll);
        this.reset();
    };
    FontFaceRuler.prototype.reset = function () {
        var offsetWidth = this.getWidth();
        var width = offsetWidth + 100;
        this.expandableInner.style.width = width + 'px';
        this.expandable.scrollLeft = width;
        this.collapsible.scrollLeft = this.collapsible.scrollWidth + 100;
        if (this.lastOffsetWidth !== offsetWidth) {
            this.lastOffsetWidth = offsetWidth;
            return true;
        }
        else {
            return false;
        }
    };
    FontFaceRuler.prototype.onScroll = function (callback) {
        if (this.reset() && this.element.parentNode !== null) {
            callback(this.lastOffsetWidth);
        }
    };
    return FontFaceRuler;
}());

/* eslint-disable */
// Based on FontFaceObserver by Bram Stein
// Copyright (c) 2014 - Bram Stein
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
var FontFaceObserver = /** @class */ (function () {
    function FontFaceObserver(font) {
        this.font = __assign({ fontFamily: 'normal', fontStyle: 'normal', fontWeight: 'normal', fontStretch: 'normal' }, font);
    }
    FontFaceObserver.getUserAgent = function () {
        return window.navigator.userAgent;
    };
    FontFaceObserver.getNavigatorVendor = function () {
        return window.navigator.vendor;
    };
    /**
     * Returns true if this browser is WebKit and it has the fallback bug
     * which is present in WebKit 536.11 and earlier.
     */
    FontFaceObserver.hasWebKitFallbackBug = function () {
        if (FontFaceObserver.HAS_WEBKIT_FALLBACK_BUG === null) {
            var match = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(FontFaceObserver.getUserAgent());
            FontFaceObserver.HAS_WEBKIT_FALLBACK_BUG = !!match &&
                (parseInt(match[1], 10) < 536 ||
                    (parseInt(match[1], 10) === 536 &&
                        parseInt(match[2], 10) <= 11));
        }
        return FontFaceObserver.HAS_WEBKIT_FALLBACK_BUG;
    };
    /**
     * Returns true if the browser has the Safari 10 bugs. The
     * native font load API in Safari 10 has two bugs that cause
     * the document.fonts.load and FontFace.prototype.load methods
     * to return promises that don't reliably get settled.
     *
     * The bugs are described in more detail here:
     *  - https://bugs.webkit.org/show_bug.cgi?id=165037
     *  - https://bugs.webkit.org/show_bug.cgi?id=164902
     *
     * If the browser is made by Apple, and has native font
     * loading support, it is potentially affected. But the API
     * was fixed around AppleWebKit version 603, so any newer
     * versions that that does not contain the bug.
     */
    FontFaceObserver.hasSafari10Bug = function () {
        if (FontFaceObserver.HAS_SAFARI_10_BUG === null) {
            if (FontFaceObserver.supportsNativeFontLoading() && /Apple/.test(FontFaceObserver.getNavigatorVendor())) {
                var match = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(FontFaceObserver.getUserAgent());
                FontFaceObserver.HAS_SAFARI_10_BUG = !!match && parseInt(match[1], 10) < 603;
            }
            else {
                FontFaceObserver.HAS_SAFARI_10_BUG = false;
            }
        }
        return FontFaceObserver.HAS_SAFARI_10_BUG;
    };
    /**
     * Returns true if the browser supports the native font loading
     * API.
     */
    FontFaceObserver.supportsNativeFontLoading = function () {
        if (FontFaceObserver.SUPPORTS_NATIVE_FONT_LOADING === null) {
            FontFaceObserver.SUPPORTS_NATIVE_FONT_LOADING = !!document["fonts"];
        }
        return FontFaceObserver.SUPPORTS_NATIVE_FONT_LOADING;
    };
    /**
     * Returns true if the browser supports font-style in the font
     * short-hand syntax.
     */
    FontFaceObserver.supportsStretch = function () {
        if (FontFaceObserver.SUPPORTS_STRETCH === null) {
            var div = document.createElement('div');
            try {
                div.style.font = 'condensend 100px sans-serif';
            }
            catch (e) {
                FontFaceObserver.SUPPORTS_STRETCH = false;
            }
            FontFaceObserver.SUPPORTS_STRETCH = div.style.font !== '';
        }
        return FontFaceObserver.SUPPORTS_STRETCH;
    };
    FontFaceObserver.prototype.load = function (text, timeout) {
        var _this = this;
        var testString = 'BESbswy';
        var timeoutID = null;
        var timeoutValue = timeout || FontFaceObserver.DEFAULT_TIMEOUT;
        var start = this.getTime();
        return new Promise(function (resolve, reject) {
            if (FontFaceObserver.supportsNativeFontLoading() && !FontFaceObserver.hasSafari10Bug()) {
                var loader = new Promise(function (resolve2, reject2) {
                    var check = function () {
                        var now = _this.getTime();
                        if (now - start >= timeoutValue) {
                            reject2(new Error('' + timeoutValue + 'ms timeout exceeded'));
                        }
                        else {
                            document["fonts"].load(_this.getStyle("\"" + _this.font.fontFamily + "\""), testString).then(function (fonts) {
                                if (fonts.length >= 1) {
                                    resolve2();
                                }
                                else {
                                    setTimeout(check, 25);
                                }
                            }, reject);
                        }
                    };
                    check();
                });
                var timer = new Promise(function (resolve2, reject2) {
                    timeoutID = setTimeout(function () {
                        reject2(new Error(timeoutValue + " ms timeout exceeded"));
                    }, timeoutValue);
                });
                Promise.race([timer, loader]).then(function () {
                    clearTimeout(timeoutID);
                    resolve(_this);
                }, reject);
            }
            else {
                var rulerA_1 = new FontFaceRuler(testString);
                var rulerB_1 = new FontFaceRuler(testString);
                var rulerC_1 = new FontFaceRuler(testString);
                var widthA_1 = -1;
                var widthB_1 = -1;
                var widthC_1 = -1;
                var fallbackWidthA_1 = -1;
                var fallbackWidthB_1 = -1;
                var fallbackWidthC_1 = -1;
                var container_1 = document.createElement('div');
                var removeContainer_1 = function () {
                    if (container_1.parentNode !== null) {
                        container_1.parentNode.removeChild(container_1);
                    }
                };
                /**
                 * If metric compatible fonts are detected, one of the widths will be -1. This is
                 * because a metric compatible font won't trigger a scroll event. We work around
                 * this by considering a font loaded if at least two of the widths are the same.
                 * Because we have three widths, this still prevents false positives.
                 *
                 * Cases:
                 * 1) Font loads: both a, b and c are called and have the same value.
                 * 2) Font fails to load: resize callback is never called and timeout happens.
                 * 3) WebKit bug: both a, b and c are called and have the same value, but the
                 *    values are equal to one of the last resort fonts, we ignore this and
                 *    continue waiting until we get new values (or a timeout).
                 */
                var check_1 = function () {
                    if ((widthA_1 !== -1 && widthB_1 !== -1) || (widthA_1 !== -1 && widthC_1 !== -1) || (widthB_1 !== -1 && widthC_1 !== -1)) {
                        if (widthA_1 === widthB_1 || widthA_1 === widthC_1 || widthB_1 === widthC_1) {
                            // All values are the same, so the browser has most likely loaded the web font
                            if (FontFaceObserver.hasWebKitFallbackBug()) {
                                // Except if the browser has the WebKIT fallback bug, in which case we check to see
                                // if all values are set to one of the last resort fonts.
                                if (((widthA_1 === fallbackWidthA_1 && widthB_1 === fallbackWidthA_1 && widthC_1 === fallbackWidthA_1) ||
                                    (widthA_1 === fallbackWidthB_1 && widthB_1 === fallbackWidthB_1 && widthC_1 === fallbackWidthB_1) ||
                                    (widthA_1 === fallbackWidthC_1 && widthB_1 === fallbackWidthC_1 && widthC_1 === fallbackWidthC_1))) {
                                    // The width we got matches some of the known last resort fonts, so let's assume we're dealing with
                                    // the last resort font.
                                    return;
                                }
                            }
                            removeContainer_1();
                            clearTimeout(timeoutID);
                            resolve(_this);
                        }
                    }
                };
                // This ensures the scroll direction is correct
                container_1.dir = 'ltr';
                rulerA_1.setFont(_this.getStyle('sans-serif'));
                rulerB_1.setFont(_this.getStyle('serif'));
                rulerC_1.setFont(_this.getStyle('monospace'));
                container_1.appendChild(rulerA_1.getElement());
                container_1.appendChild(rulerB_1.getElement());
                container_1.appendChild(rulerC_1.getElement());
                document.body.appendChild(container_1);
                fallbackWidthA_1 = rulerA_1.getWidth();
                fallbackWidthB_1 = rulerB_1.getWidth();
                fallbackWidthC_1 = rulerC_1.getWidth();
                var checkForTimeout_1 = function () {
                    var now = _this.getTime();
                    if (now - start >= timeoutValue) {
                        removeContainer_1();
                        reject(new Error(timeoutValue + " ms timeout exceeded"));
                    }
                    else {
                        var hidden = document.hidden;
                        if (hidden === true || hidden === undefined) {
                            widthA_1 = rulerA_1.getWidth();
                            widthB_1 = rulerB_1.getWidth();
                            widthC_1 = rulerC_1.getWidth();
                            check_1();
                        }
                        timeoutID = setTimeout(checkForTimeout_1, 50);
                    }
                };
                checkForTimeout_1();
                rulerA_1.onResize(function (width) {
                    widthA_1 = width;
                    check_1();
                });
                rulerA_1.setFont(_this.getStyle("\"" + _this.font.fontFamily + "\",sans-serif"));
                rulerB_1.onResize(function (width) {
                    widthB_1 = width;
                    check_1();
                });
                rulerB_1.setFont(_this.getStyle("\"" + _this.font.fontFamily + "\",serif"));
                rulerC_1.onResize(function (width) {
                    widthC_1 = width;
                    check_1();
                });
                rulerC_1.setFont(_this.getStyle("\"" + _this.font.fontFamily + "\",monospace"));
            }
        });
    };
    FontFaceObserver.prototype.getStyle = function (family) {
        return [
            this.font.fontStyle,
            this.font.fontWeight,
            FontFaceObserver.supportsStretch() ? this.font.fontStretch : '',
            '100px',
            family,
        ].join(' ');
    };
    /**
     * Returns the current time in milliseconds
     */
    FontFaceObserver.prototype.getTime = function () {
        return new Date().getTime();
    };
    FontFaceObserver.HAS_WEBKIT_FALLBACK_BUG = null;
    FontFaceObserver.HAS_SAFARI_10_BUG = null;
    FontFaceObserver.SUPPORTS_STRETCH = null;
    FontFaceObserver.SUPPORTS_NATIVE_FONT_LOADING = null;
    FontFaceObserver.DEFAULT_TIMEOUT = 3000;
    return FontFaceObserver;
}());

function isMobile() {
    if (typeof navigator === 'undefined') {
        return false;
    }
    var a = navigator.userAgent || navigator.vendor || window.opera;
    /* eslint-disable */
    return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)));
    /* eslint-enable */
}

var ImageResizerEvent;
(function (ImageResizerEvent) {
    ImageResizerEvent["BEGAN_IMAGE_DOWNSCALING"] = "beganImageDownscaling";
    ImageResizerEvent["IMAGE_DOWNSCALED"] = "imageDownscaled";
})(ImageResizerEvent || (ImageResizerEvent = {}));
/**
 * This class uses Canvas2D in order to downscale an image if it exceeds the
 * limits.
 *
 * This ignores EXIF orientation data and directly uses
 * the input dimensions for checking the downscaling conditions, so
 * EXIF checks and orientation adjustments should happen before using
 * this image resizer.
 */
var ImageResizer = /** @class */ (function (_super) {
    __extends(ImageResizer, _super);
    function ImageResizer(image, options) {
        var _this = _super.call(this) || this;
        _this.image = image;
        _this.options = options;
        return _this;
    }
    /**
     * @returns Whether or not the image should be downscaled.
     */
    ImageResizer.prototype.needsResize = function () {
        var resizedDimensions = this.resizedDimensions();
        return resizedDimensions.x < this.image.width || resizedDimensions.y < this.image.height;
    };
    /**
     * The dimensions of the optionally resized output.
     */
    ImageResizer.prototype.resizedDimensions = function () {
        var options = this.options;
        var sourceDimensions = { width: this.image.width, height: this.image.height };
        // There can be two bounding boxes which describe dimension limits:
        // One given by the megapixel limit - this one has the same aspect
        // ratio as the image.
        // Another bounding box is given by the maxDimensions limit. The
        // intersection of both bounding boxes defines the final bounding box
        // which the input should be downscaled into.
        // We don't want to upscale the input, so we have the input dimensions as
        // the upper bound.
        var maxMegaPixelBounds = Vector2.fromSize(sourceDimensions);
        var maxDimensionBounds = Vector2.fromSize(sourceDimensions);
        var maxMegaPixels = options.maxMegaPixels;
        if (maxMegaPixels) {
            var maxPixels = (isMobile() ? maxMegaPixels.mobile : maxMegaPixels.desktop) * 1000000;
            var ratioHV = sourceDimensions.width / sourceDimensions.height;
            var ratioVH = sourceDimensions.height / sourceDimensions.width;
            var maxPixelBounds = new Vector2(Math.floor(Math.sqrt(maxPixels * ratioHV)), Math.floor(Math.sqrt(maxPixels * ratioVH)));
            if (maxPixelBounds.x <= sourceDimensions.width && maxPixelBounds.y <= sourceDimensions.height) {
                maxMegaPixelBounds = maxPixelBounds;
            }
        }
        var maxOutputDimensions = options.maxDimensions;
        if (maxOutputDimensions) {
            if (maxOutputDimensions.height < sourceDimensions.height || maxOutputDimensions.width < sourceDimensions.width) {
                maxDimensionBounds = new Vector2(maxOutputDimensions.width, maxOutputDimensions.height);
            }
        }
        var intersectionAABB = new Vector2(Math.min(maxMegaPixelBounds.x, maxDimensionBounds.x), Math.min(maxMegaPixelBounds.y, maxDimensionBounds.y));
        return Vector2.proportionalFit(intersectionAABB, Vector2.fromSize(sourceDimensions)).floored;
    };
    /**
     * If the conditions for downscaling are met, the source image is
     * resized and a canvas element is returned, otherwise, the source
     * is returned without modifications.
     */
    ImageResizer.prototype.downscaleIfNecessary = function () {
        var resizedDimensions = this.resizedDimensions();
        var needsResize = resizedDimensions.x < this.image.width || resizedDimensions.y < this.image.height;
        if (!needsResize) {
            return this.image;
        }
        this.emit(ImageResizerEvent.BEGAN_IMAGE_DOWNSCALING, this.image);
        var canvas = document.createElement('canvas');
        canvas.width = resizedDimensions.x;
        canvas.height = resizedDimensions.y;
        var context = canvas.getContext('2d');
        var image = this.image;
        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, resizedDimensions.x, resizedDimensions.y);
        this.emit(ImageResizerEvent.IMAGE_DOWNSCALED);
        return canvas;
    };
    ImageResizer.prototype.downscaleImageIfNecessary = function () {
        var thisImage = this.image;
        var resizedDimensions = this.resizedDimensions();
        var needsResize = resizedDimensions.x < this.image.width || resizedDimensions.y < this.image.height;
        if (!needsResize) {
            return thisImage;
        }
        this.emit(ImageResizerEvent.BEGAN_IMAGE_DOWNSCALING, thisImage);
        var image = new Image();
        image.width = resizedDimensions.x;
        image.height = resizedDimensions.y;
        image.src = thisImage.src;
        this.emit(ImageResizerEvent.IMAGE_DOWNSCALED);
        return image;
    };
    return ImageResizer;
}(EventEmitter));

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
function resolve() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : '/';

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
}
// path.normalize(path)
// posix version
function normalize(path) {
  var isPathAbsolute = isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
}
// posix version
function isAbsolute(path) {
  return path.charAt(0) === '/';
}

// posix version
function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
}


// path.relative(from, to)
// posix version
function relative(from, to) {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
}

var sep = '/';
var delimiter = ':';

function dirname(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}


function extname(path) {
  return splitPath(path)[3];
}
var path = {
  extname: extname,
  basename: basename,
  dirname: dirname,
  sep: sep,
  delimiter: delimiter,
  relative: relative,
  join: join,
  isAbsolute: isAbsolute,
  normalize: normalize,
  resolve: resolve
};
function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b' ?
    function (str, start, len) { return str.substr(start, len) } :
    function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

var metadata = [
    {
        identifier: 'imgly_overlay_golden',
        name: 'Golden',
        defaultBlendMode: BlendMode.LIGHTEN,
        overlayURI: './items/imgly_overlay_golden.jpg',
        thumbnailURI: './items/imgly_overlay_golden_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_lightleak1',
        name: 'Lightleak',
        defaultBlendMode: BlendMode.SCREEN,
        overlayURI: './items/imgly_overlay_lightleak1.jpg',
        thumbnailURI: './items/imgly_overlay_lightleak1_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_rain',
        name: 'Rain',
        defaultBlendMode: BlendMode.OVERLAY,
        overlayURI: './items/imgly_overlay_rain.jpg',
        thumbnailURI: './items/imgly_overlay_rain_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_mosaic',
        name: 'Mosaic',
        defaultBlendMode: BlendMode.MULTIPLY,
        overlayURI: './items/imgly_overlay_mosaic.jpg',
        thumbnailURI: './items/imgly_overlay_mosaic_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_vintage',
        name: 'Vintage',
        defaultBlendMode: BlendMode.DARKEN,
        overlayURI: './items/imgly_overlay_vintage.jpg',
        thumbnailURI: './items/imgly_overlay_vintage_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_paper',
        name: 'Paper',
        defaultBlendMode: BlendMode.MULTIPLY,
        overlayURI: './items/imgly_overlay_paper.jpg',
        thumbnailURI: './items/imgly_overlay_paper_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_bokeh',
        name: 'Bokeh',
        defaultBlendMode: BlendMode.LIGHTEN,
        overlayURI: './items/imgly_overlay_bokeh.jpg',
        thumbnailURI: './items/imgly_overlay_bokeh_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_hearts',
        name: 'Hearts',
        defaultBlendMode: BlendMode.SCREEN,
        overlayURI: './items/imgly_overlay_hearts.jpg',
        thumbnailURI: './items/imgly_overlay_hearts_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_lightleak2',
        name: 'Lightleak 2',
        defaultBlendMode: BlendMode.LIGHTEN,
        overlayURI: './items/imgly_overlay_lightleak2.jpg',
        thumbnailURI: './items/imgly_overlay_lightleak2_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_wood',
        name: 'Wood',
        defaultBlendMode: BlendMode.MULTIPLY,
        overlayURI: './items/imgly_overlay_wood.jpg',
        thumbnailURI: './items/imgly_overlay_wood_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_chop',
        name: 'Chop',
        defaultBlendMode: BlendMode.MULTIPLY,
        overlayURI: './items/imgly_overlay_chop.jpg',
        thumbnailURI: './items/imgly_overlay_chop_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_metal',
        name: 'Metal',
        defaultBlendMode: BlendMode.OVERLAY,
        overlayURI: './items/imgly_overlay_metal.jpg',
        thumbnailURI: './items/imgly_overlay_metal_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_painting',
        name: 'Painting',
        defaultBlendMode: BlendMode.OVERLAY,
        overlayURI: './items/imgly_overlay_painting.jpg',
        thumbnailURI: './items/imgly_overlay_painting_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_grain',
        name: 'Grain',
        defaultBlendMode: BlendMode.OVERLAY,
        overlayURI: './items/imgly_overlay_grain.jpg',
        thumbnailURI: './items/imgly_overlay_grain_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_clouds',
        name: 'Clouds',
        defaultBlendMode: BlendMode.SOFT_LIGHT,
        overlayURI: './items/imgly_overlay_clouds.jpg',
        thumbnailURI: './items/imgly_overlay_clouds_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_wall1',
        name: 'Wall',
        defaultBlendMode: BlendMode.LIGHTEN,
        overlayURI: './items/imgly_overlay_wall1.jpg',
        thumbnailURI: './items/imgly_overlay_wall1_thumb.jpg',
    },
    {
        identifier: 'imgly_overlay_wall2',
        name: 'Wall 2',
        defaultBlendMode: BlendMode.OVERLAY,
        overlayURI: './items/imgly_overlay_wall2.jpg',
        thumbnailURI: './items/imgly_overlay_wall2_thumb.jpg',
    },
];

var metadata$1 = [
    {
        identifier: 'imgly_filter_category_duotone',
        name: 'DuoTone',
        thumbnailURI: './categories/duotone.jpg',
        items: [
            {
                identifier: 'imgly_duotone_desert',
                name: 'Desert',
                thumbnailURI: './items/imgly_duotone_desert.jpg',
                lightColor: '#e1de9a',
                darkColor: '#cb2129',
                defaultIntensity: 0.5,
            },
            {
                identifier: 'imgly_duotone_peach',
                name: 'Peach',
                thumbnailURI: './items/imgly_duotone_peach.jpg',
                lightColor: '#e9abb8',
                darkColor: '#0040ff',
                defaultIntensity: 0.5,
            },
            {
                identifier: 'imgly_duotone_clash',
                name: 'Clash',
                thumbnailURI: './items/imgly_duotone_clash.jpg',
                lightColor: '#f41a0f',
                darkColor: '#23007c',
                defaultIntensity: 0.5,
            },
            {
                identifier: 'imgly_duotone_plum',
                name: 'Plum',
                thumbnailURI: './items/imgly_duotone_plum.jpg',
                lightColor: '#74d7ff',
                darkColor: '#23007c',
                defaultIntensity: 0.5,
            },
            {
                identifier: 'imgly_duotone_breezy',
                name: 'Breezy',
                thumbnailURI: './items/imgly_duotone_breezy.jpg',
                lightColor: '#68fdff',
                darkColor: '#c20000',
                defaultIntensity: 0.5,
            },
            {
                identifier: 'imgly_duotone_deepblue',
                name: 'Deep Blue',
                thumbnailURI: './items/imgly_duotone_deepblue.jpg',
                lightColor: '#2de9eb',
                darkColor: '#58007c',
                defaultIntensity: 0.5,
            },
            {
                identifier: 'imgly_duotone_frog',
                name: 'Frog',
                thumbnailURI: './items/imgly_duotone_frog.jpg',
                lightColor: '#5bff60',
                darkColor: '#7f23a9',
                defaultIntensity: 0.5,
            },
            {
                identifier: 'imgly_duotone_sunset',
                name: 'Sunset',
                thumbnailURI: './items/imgly_duotone_sunset.jpg',
                lightColor: '#f8ea46',
                darkColor: '#c400be',
                defaultIntensity: 0.5,
            },
        ],
    },
    {
        identifier: 'imgly_filter_category_bw',
        name: 'B & W',
        thumbnailURI: './categories/b&w.jpg',
        items: [
            {
                identifier: 'imgly_lut_ad1920',
                name: '1920 A.D.',
                thumbnailURI: './items/imgly_lut_ad1920.jpg',
                lutURI: './items/imgly_lut_ad1920_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_bw',
                name: 'Greyed',
                thumbnailURI: './items/imgly_lut_bw.jpg',
                lutURI: './items/imgly_lut_bw_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_x400',
                name: 'Dusty',
                thumbnailURI: './items/imgly_lut_x400.jpg',
                lutURI: './items/imgly_lut_dusty_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_litho',
                name: 'Litho',
                thumbnailURI: './items/imgly_lut_litho.jpg',
                lutURI: './items/imgly_lut_litho_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_sepiahigh',
                name: 'Sepia',
                thumbnailURI: './items/imgly_lut_sepiahigh.jpg',
                lutURI: './items/imgly_lut_sepia_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_plate',
                name: 'Weathered',
                thumbnailURI: './items/imgly_lut_plate.jpg',
                lutURI: './items/imgly_lut_weathered_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_sin',
                name: 'Hard Stuff',
                thumbnailURI: './items/imgly_lut_sin.jpg',
                lutURI: './items/imgly_lut_hard_stuff_8_8_512.png',
                defaultIntensity: 1,
                horizontalTileCount: 8,
                verticalTileCount: 8,
            },
        ],
    },
    {
        identifier: 'imgly_filter_category_vintage',
        name: 'Vintage',
        thumbnailURI: './categories/vintage.jpg',
        items: [
            {
                identifier: 'imgly_lut_blues',
                name: 'Polaroid',
                thumbnailURI: './items/imgly_lut_blues.jpg',
                lutURI: './items/imgly_lut_polaroid_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_front',
                name: 'Sunny 70s',
                thumbnailURI: './items/imgly_lut_front.jpg',
                lutURI: './items/imgly_lut_sunny_70s_8_8_512.png',
                defaultIntensity: 1,
                horizontalTileCount: 8,
                verticalTileCount: 8,
            },
            {
                identifier: 'imgly_lut_texas',
                name: 'Oldtimer',
                thumbnailURI: './items/imgly_lut_texas.jpg',
                lutURI: './items/imgly_lut_oldtimer_8_8_512.png',
                defaultIntensity: 1,
                horizontalTileCount: 8,
                verticalTileCount: 8,
            },
            {
                identifier: 'imgly_lut_celsius',
                name: 'Inferno',
                thumbnailURI: './items/imgly_lut_celsius.jpg',
                lutURI: './items/imgly_lut_inferno_8_8_512.png',
                defaultIntensity: 1,
                horizontalTileCount: 8,
                verticalTileCount: 8,
            },
            {
                identifier: 'imgly_lut_cool',
                name: 'Snappy',
                thumbnailURI: './items/imgly_lut_cool.jpg',
                lutURI: './items/imgly_lut_snappy_5_5_128.png',
                defaultIntensity: 1,
            },
        ],
    },
    {
        identifier: 'imgly_filter_category_smooth',
        name: 'Smooth',
        thumbnailURI: './categories/smooth.jpg',
        items: [
            {
                identifier: 'imgly_lut_chest',
                name: 'Chestnut',
                thumbnailURI: './items/imgly_lut_chest.jpg',
                lutURI: './items/imgly_lut_chestnut_8_8_512.png',
                defaultIntensity: 1,
                horizontalTileCount: 8,
                verticalTileCount: 8,
            },
            {
                identifier: 'imgly_lut_winter',
                name: 'Softy',
                thumbnailURI: './items/imgly_lut_winter.jpg',
                lutURI: './items/imgly_lut_softly_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_kdynamic',
                name: 'Pebble',
                thumbnailURI: './items/imgly_lut_kdynamic.jpg',
                lutURI: './items/imgly_lut_pebble_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_fall',
                name: 'Moss',
                thumbnailURI: './items/imgly_lut_fall.jpg',
                lutURI: './items/imgly_lut_moss_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_lenin',
                name: 'Lemon',
                thumbnailURI: './items/imgly_lut_lenin.jpg',
                lutURI: './items/imgly_lut_lemon_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_pola669',
                name: 'Green Gap',
                thumbnailURI: './items/imgly_lut_pola669.jpg',
                lutURI: './items/imgly_lut_green_gap_5_5_128.png',
                defaultIntensity: 1,
            },
        ],
    },
    {
        identifier: 'imgly_filter_category_cold',
        name: 'Cold',
        thumbnailURI: './categories/cold.jpg',
        items: [
            {
                identifier: 'imgly_lut_elder',
                name: 'Colla',
                thumbnailURI: './items/imgly_lut_elder.jpg',
                lutURI: './items/imgly_lut_colla_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_orchid',
                name: 'Solanus',
                thumbnailURI: './items/imgly_lut_orchid.jpg',
                lutURI: './items/imgly_lut_solanus_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_bleached',
                name: 'Kalmen',
                thumbnailURI: './items/imgly_lut_bleached.jpg',
                lutURI: './items/imgly_lut_kalmen_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_bleachedblue',
                name: 'Joran',
                thumbnailURI: './items/imgly_lut_bleachedblue.jpg',
                lutURI: './items/imgly_lut_joran_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_breeze',
                name: 'Levante',
                thumbnailURI: './items/imgly_lut_breeze.jpg',
                lutURI: './items/imgly_lut_levante_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_blueshadows',
                name: 'Zephyr',
                thumbnailURI: './items/imgly_lut_blueshadows.jpg',
                lutURI: './items/imgly_lut_zephyr_5_5_128.png',
                defaultIntensity: 1,
            },
        ],
    },
    {
        identifier: 'imgly_filter_category_warm',
        name: 'Warm',
        thumbnailURI: './categories/warm.jpg',
        items: [
            {
                identifier: 'imgly_lut_sunset',
                name: 'Golden',
                thumbnailURI: './items/imgly_lut_sunset.jpg',
                lutURI: './items/imgly_lut_golden_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_eighties',
                name: 'Low Fire',
                thumbnailURI: './items/imgly_lut_eighties.jpg',
                lutURI: './items/imgly_lut_low_fire_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_evening',
                name: 'Sunrise',
                thumbnailURI: './items/imgly_lut_evening.jpg',
                lutURI: './items/imgly_lut_sunrise_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_k2',
                name: 'Flat Black',
                thumbnailURI: './items/imgly_lut_k2.jpg',
                lutURI: './items/imgly_lut_flat_black_8_8_512.png',
                defaultIntensity: 1,
                horizontalTileCount: 8,
                verticalTileCount: 8,
            },
            {
                identifier: 'imgly_lut_nogreen',
                name: 'Pumpkin',
                thumbnailURI: './items/imgly_lut_nogreen.jpg',
                lutURI: './items/imgly_lut_pumpkin_5_5_128.png',
                defaultIntensity: 1,
            },
        ],
    },
    {
        identifier: 'imgly_filter_category_legacy',
        name: 'Legacy',
        thumbnailURI: './categories/legacy.jpg',
        items: [
            {
                identifier: 'imgly_lut_ancient',
                name: 'Ancient',
                thumbnailURI: './items/imgly_lut_ancient.jpg',
                lutURI: './items/imgly_lut_ancient_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_cottoncandy',
                name: 'Candy',
                thumbnailURI: './items/imgly_lut_cottoncandy.jpg',
                lutURI: './items/imgly_lut_cottoncandy_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_classic',
                name: 'Classic',
                thumbnailURI: './items/imgly_lut_classic.jpg',
                lutURI: './items/imgly_lut_classic_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_colorful',
                name: 'Colorful',
                thumbnailURI: './items/imgly_lut_colorful.jpg',
                lutURI: './items/imgly_lut_colorful_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_creamy',
                name: 'Creamy',
                thumbnailURI: './items/imgly_lut_creamy.jpg',
                lutURI: './items/imgly_lut_creamy_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_fixie',
                name: 'Fixie',
                thumbnailURI: './items/imgly_lut_fixie.jpg',
                lutURI: './items/imgly_lut_fixie_8_8_512.png',
                defaultIntensity: 1,
                horizontalTileCount: 8,
                verticalTileCount: 8,
            },
            {
                identifier: 'imgly_lut_food',
                name: 'Food',
                thumbnailURI: './items/imgly_lut_food.jpg',
                lutURI: './items/imgly_lut_food_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_fridge',
                name: 'Fridge',
                thumbnailURI: './items/imgly_lut_fridge.jpg',
                lutURI: './items/imgly_lut_fridge_8_8_512.png',
                defaultIntensity: 1,
                horizontalTileCount: 8,
                verticalTileCount: 8,
            },
            {
                identifier: 'imgly_lut_glam',
                name: 'Glam',
                thumbnailURI: './items/imgly_lut_glam.jpg',
                lutURI: './items/imgly_lut_glam_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_gobblin',
                name: 'Gobblin',
                thumbnailURI: './items/imgly_lut_gobblin.jpg',
                lutURI: './items/imgly_lut_gobblin_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_highcontrast',
                name: 'Hicon',
                thumbnailURI: './items/imgly_lut_highcontrast.jpg',
                lutURI: './items/imgly_lut_highcontrast_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_highcarb',
                name: 'High Carb',
                thumbnailURI: './items/imgly_lut_highcarb.jpg',
                lutURI: './items/imgly_lut_highcarb_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_k1',
                name: 'K1',
                thumbnailURI: './items/imgly_lut_k1.jpg',
                lutURI: './items/imgly_lut_k1_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_k6',
                name: 'K6',
                thumbnailURI: './items/imgly_lut_k6.jpg',
                lutURI: './items/imgly_lut_k6_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_keen',
                name: 'Keen',
                thumbnailURI: './items/imgly_lut_keen.jpg',
                lutURI: './items/imgly_lut_keen_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_lomo',
                name: 'Lomo',
                thumbnailURI: './items/imgly_lut_lomo.jpg',
                lutURI: './items/imgly_lut_lomo_8_8_512.png',
                defaultIntensity: 1,
                horizontalTileCount: 8,
                verticalTileCount: 8,
            },
            {
                identifier: 'imgly_lut_lomo100',
                name: 'Lomo 100',
                thumbnailURI: './items/imgly_lut_lomo100.jpg',
                lutURI: './items/imgly_lut_lomo100_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_lucid',
                name: 'Lucid',
                thumbnailURI: './items/imgly_lut_lucid.jpg',
                lutURI: './items/imgly_lut_lucid_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_mellow',
                name: 'Mellow',
                thumbnailURI: './items/imgly_lut_mellow.jpg',
                lutURI: './items/imgly_lut_mellow_8_8_512.png',
                defaultIntensity: 1,
                horizontalTileCount: 8,
                verticalTileCount: 8,
            },
            {
                identifier: 'imgly_lut_neat',
                name: 'Neat',
                thumbnailURI: './items/imgly_lut_neat.jpg',
                lutURI: './items/imgly_lut_neat_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_pale',
                name: 'Pale',
                thumbnailURI: './items/imgly_lut_pale.jpg',
                lutURI: './items/imgly_lut_pale_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_pitched',
                name: 'Pitched',
                thumbnailURI: './items/imgly_lut_pitched.jpg',
                lutURI: './items/imgly_lut_pitched_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_polasx',
                name: 'Pola SX',
                thumbnailURI: './items/imgly_lut_polasx.jpg',
                lutURI: './items/imgly_lut_polasx_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_pro400',
                name: 'Pro 400',
                thumbnailURI: './items/imgly_lut_pro400.jpg',
                lutURI: './items/imgly_lut_pro400_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_quozi',
                name: 'Quozi',
                thumbnailURI: './items/imgly_lut_quozi.jpg',
                lutURI: './items/imgly_lut_quozi_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_settled',
                name: 'Settled',
                thumbnailURI: './items/imgly_lut_settled.jpg',
                lutURI: './items/imgly_lut_settled_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_seventies',
                name: 'Seventies',
                thumbnailURI: './items/imgly_lut_seventies.jpg',
                lutURI: './items/imgly_lut_seventies_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_soft',
                name: 'Soft',
                thumbnailURI: './items/imgly_lut_soft.jpg',
                lutURI: './items/imgly_lut_soft_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_steel',
                name: 'Steel',
                thumbnailURI: './items/imgly_lut_steel.jpg',
                lutURI: './items/imgly_lut_steel_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_summer',
                name: 'Summer',
                thumbnailURI: './items/imgly_lut_summer.jpg',
                lutURI: './items/imgly_lut_summer_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_tender',
                name: 'Tender',
                thumbnailURI: './items/imgly_lut_tender.jpg',
                lutURI: './items/imgly_lut_tender_5_5_128.png',
                defaultIntensity: 1,
            },
            {
                identifier: 'imgly_lut_twilight',
                name: 'Twilight',
                thumbnailURI: './items/imgly_lut_twilight.jpg',
                lutURI: './items/imgly_lut_twilight_5_5_128.png',
                defaultIntensity: 1,
            },
        ],
    },
];

var metadata$2 = [
    {
        identifier: 'imgly_font_open_sans_bold',
        fontFamily: 'Open Sans',
        fontWeight: 'bold',
        fontURI: './fonts/imgly_font_open_sans_bold.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2189,
            descender: -640,
        },
    },
    {
        identifier: 'imgly_font_aleo_bold',
        fontFamily: 'Aleo',
        fontWeight: 'bold',
        fontURI: './fonts/imgly_font_aleo_bold.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1919,
            descender: -409,
        },
    },
    {
        identifier: 'imgly_font_amaticsc',
        fontFamily: 'Amaticsc',
        fontWeight: 'normal',
        fontURI: './fonts/imgly_font_amaticsc.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2332,
            descender: -583,
        },
    },
    {
        identifier: 'imgly_font_bernier_regular',
        fontFamily: 'Bernier',
        fontWeight: 'normal',
        fontURI: './fonts/imgly_font_bernier_regular.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2007,
            descender: -552,
        },
    },
    {
        identifier: 'imgly_font_cheque_regular',
        fontFamily: 'Cheque',
        fontWeight: 'normal',
        fontURI: './fonts/imgly_font_cheque_regular.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2007,
            descender: -552,
        },
    },
    {
        identifier: 'imgly_font_gagalin_regular',
        fontFamily: 'Gagalin',
        fontWeight: 'normal',
        fontURI: './fonts/imgly_font_gagalin_regular.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1987,
            descender: -628,
        },
    },
    {
        identifier: 'imgly_font_hagin_caps_thin',
        fontFamily: 'Hagin Caps',
        fontWeight: 200,
        fontURI: './fonts/imgly_font_hagin_caps_thin.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1964,
            descender: -482,
        },
    },
    {
        identifier: 'imgly_font_intro_inline',
        fontFamily: 'Intro Inline',
        fontWeight: 'normal',
        fontURI: './fonts/imgly_font_intro_inline.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1944,
            descender: -548,
        },
    },
    {
        identifier: 'imgly_font_lobster',
        fontFamily: 'Lobster',
        fontWeight: 'normal',
        fontURI: './fonts/imgly_font_lobster.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2048,
            descender: -552,
        },
    },
    {
        identifier: 'imgly_font_nexa_script',
        fontFamily: 'Nexa Script',
        fontWeight: 'normal',
        fontURI: './fonts/imgly_font_nexa_script.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1835,
            descender: -663,
        },
    },
    {
        identifier: 'imgly_font_panton_blackitalic_caps',
        fontFamily: 'Panton',
        fontWeight: 800,
        fontStyle: 'italic',
        fontURI: './fonts/imgly_font_panton_blackitalic_caps.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2033,
            descender: -572,
        },
    },
    {
        identifier: 'imgly_font_panton_lightitalic_caps',
        fontFamily: 'Panton',
        fontWeight: 200,
        fontStyle: 'italic',
        fontURI: './fonts/imgly_font_panton_lightitalic_caps.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1961,
            descender: -556,
        },
    },
    {
        identifier: 'imgly_font_perfograma',
        fontFamily: 'Perfograma',
        fontWeight: 'normal',
        fontURI: './fonts/imgly_font_perfograma.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1982,
            descender: -842,
        },
    },
    {
        identifier: 'imgly_font_trash_hand',
        fontFamily: 'Trash Hand',
        fontWeight: 'normal',
        fontURI: './fonts/imgly_font_trash_hand.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1554,
            descender: -663,
        },
    },
    {
        identifier: 'imgly_font_abril_fatface_regular',
        fontFamily: 'Abril Fatface',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_abril_fatface_regular.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 1058,
            descender: -291,
        },
    },
    {
        identifier: 'imgly_font_montserrat_light',
        fontFamily: 'Montserrat Light',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_montserrat_light.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 968,
            descender: -251,
        },
    },
    {
        identifier: 'imgly_font_wolesbro',
        fontFamily: 'Wolesbro',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_wolesbro.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1849,
            descender: -1123,
        },
    },
    {
        identifier: 'imgly_font_permanent_marker',
        fontFamily: 'Permanent Marker',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_permanent_marker.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2272,
            descender: -686,
        },
    },
    {
        identifier: 'imgly_font_panton_light_italic_caps',
        fontFamily: 'Panton Caps',
        fontWeight: 'lighter',
        fontStyle: 'italic',
        fontURI: './fonts/imgly_font_panton_light_italic_caps.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 940,
            descender: -260,
        },
    },
    {
        identifier: 'imgly_font_panton_black_italic_caps',
        fontFamily: 'Panton Caps',
        fontWeight: 800,
        fontStyle: 'italic',
        fontURI: './fonts/imgly_font_panton_black_italic_caps.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 940,
            descender: -260,
        },
    },
    {
        identifier: 'imgly_font_panton_light_caps',
        fontFamily: 'Panton Caps',
        fontWeight: 'lighter',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_panton_light_caps.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 940,
            descender: -260,
        },
    },
    {
        identifier: 'imgly_font_panton_black_caps',
        fontFamily: 'Panton Caps',
        fontWeight: 800,
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_panton_black_caps.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 940,
            descender: -260,
        },
    },
    {
        identifier: 'imgly_font_amberlight',
        fontFamily: 'Amberlight',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_amberlight.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 750,
            descender: -250,
        },
    },
    {
        identifier: 'imgly_font_ultra',
        fontFamily: 'Ultra',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_ultra.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2066,
            descender: -561,
        },
    },
    {
        identifier: 'imgly_font_galano_grotesque_bold',
        fontFamily: 'Galano Grotesque',
        fontWeight: 'bold',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_galano_grotesque_bold.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 800,
            descender: -200,
        },
    },
    {
        identifier: 'imgly_font_bungee_inline',
        fontFamily: 'Bungee Inline',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_bungee_inline.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 860,
            descender: -140,
        },
    },
    {
        identifier: 'imgly_font_petit_formal_script',
        fontFamily: 'Petit Formal Script',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_petit_formal_script.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2033,
            descender: -527,
        },
    },
    {
        identifier: 'imgly_font_summer_font_light',
        fontFamily: 'Summer Font',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_summer_font_light.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2189,
            descender: -600,
        },
    },
    {
        identifier: 'imgly_font_handycheera_regular',
        fontFamily: 'Handycheera',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_handycheera_regular.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 2199,
            descender: -808,
        },
    },
    {
        identifier: 'imgly_font_rasa_regular',
        fontFamily: 'Rasa',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_rasa_regular.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2750,
            ascender: 2300,
            descender: -1050,
        },
    },
    {
        identifier: 'imgly_font_rasa_500',
        fontFamily: 'Rasa',
        fontWeight: 500,
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_rasa_500.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2750,
            ascender: 2300,
            descender: -1050,
        },
    },
    {
        identifier: 'imgly_font_campton_bold',
        fontFamily: 'Campton Book',
        fontWeight: 'bold',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_campton_bold.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 770,
            descender: -294,
        },
    },
    {
        identifier: 'imgly_font_ostrich_sans_black',
        fontFamily: 'Ostrich',
        fontWeight: 800,
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_ostrich_sans_black.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1513,
            descender: -235,
        },
    },
    {
        identifier: 'imgly_font_ostrich_sans_bold',
        fontFamily: 'Ostrich',
        fontWeight: 'bold',
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_ostrich_sans_bold.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 2048,
            ascender: 1513,
            descender: -235,
        },
    },
    {
        identifier: 'imgly_font_ostrich_sans_heavy',
        fontFamily: 'Ostrich',
        fontWeight: 900,
        fontStyle: 'normal',
        fontURI: './fonts/imgly_font_ostrich_sans_heavy.woff',
        format: 'woff',
        textMetrics: {
            unitsPerEm: 1000,
            ascender: 674,
            descender: 0,
        },
    },
];

var metadata$3 = [
    {
        identifier: FocusIdentifier.RADIAL,
        thumbnailURI: './items/radial.png',
    },
    {
        identifier: FocusIdentifier.MIRRORED,
        thumbnailURI: './items/mirrored.png',
    },
    {
        identifier: FocusIdentifier.LINEAR,
        thumbnailURI: './items/linear.png',
    },
    {
        identifier: FocusIdentifier.GAUSSIAN,
        thumbnailURI: './items/gaussian.png',
    },
];

var metadata$4 = [
    {
        identifier: 'basics',
        name: 'Basics',
        items: [
            {
                identifier: AdjustmentIdentifier.BRIGHTNESS,
            },
            {
                identifier: AdjustmentIdentifier.CONTRAST,
            },
            {
                identifier: AdjustmentIdentifier.SATURATION,
            },
            {
                identifier: AdjustmentIdentifier.GAMMA,
            },
        ],
    },
    {
        identifier: 'refinements',
        name: 'Refinements',
        items: [
            {
                identifier: AdjustmentIdentifier.CLARITY,
            },
            {
                identifier: AdjustmentIdentifier.SHADOWS,
            },
            {
                identifier: AdjustmentIdentifier.HIGHLIGHTS,
            },
            {
                identifier: AdjustmentIdentifier.EXPOSURE,
            },
            {
                identifier: AdjustmentIdentifier.BLACKS,
            },
            {
                identifier: AdjustmentIdentifier.WHITES,
            },
            {
                identifier: AdjustmentIdentifier.TEMPERATURE,
            },
            {
                identifier: AdjustmentIdentifier.SHARPNESS,
            },
        ],
    },
];

var metadata$5 = [
    {
        identifier: 'imgly_sticker_emoticons',
        name: 'Emoticons',
        thumbnailURI: './categories/emoticons.png',
        items: [
            {
                identifier: 'imgly_sticker_emoticons_grin',
                stickerURI: './emoticons/imgly_sticker_emoticons_grin.svg',
                tintMode: 'none',
                name: 'Grin',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_laugh',
                stickerURI: './emoticons/imgly_sticker_emoticons_laugh.svg',
                tintMode: 'none',
                name: 'Laugh',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_smile',
                stickerURI: './emoticons/imgly_sticker_emoticons_smile.svg',
                tintMode: 'none',
                name: 'Smile',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_wink',
                stickerURI: './emoticons/imgly_sticker_emoticons_wink.svg',
                tintMode: 'none',
                name: 'Wink',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_tongue_out_wink',
                stickerURI: './emoticons/imgly_sticker_emoticons_tongue_out_wink.svg',
                tintMode: 'none',
                name: 'Tongue out wink',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_angel',
                stickerURI: './emoticons/imgly_sticker_emoticons_angel.svg',
                tintMode: 'none',
                name: 'Angel',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_kisses',
                stickerURI: './emoticons/imgly_sticker_emoticons_kisses.svg',
                tintMode: 'none',
                name: 'Kisses',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_loving',
                stickerURI: './emoticons/imgly_sticker_emoticons_loving.svg',
                tintMode: 'none',
                name: 'Loving',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_kiss',
                stickerURI: './emoticons/imgly_sticker_emoticons_kiss.svg',
                tintMode: 'none',
                name: 'Kiss',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_wave',
                stickerURI: './emoticons/imgly_sticker_emoticons_wave.svg',
                tintMode: 'none',
                name: 'Wave',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_nerd',
                stickerURI: './emoticons/imgly_sticker_emoticons_nerd.svg',
                tintMode: 'none',
                name: 'Nerd',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_cool',
                stickerURI: './emoticons/imgly_sticker_emoticons_cool.svg',
                tintMode: 'none',
                name: 'Cool',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_blush',
                stickerURI: './emoticons/imgly_sticker_emoticons_blush.svg',
                tintMode: 'none',
                name: 'Blush',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_duckface',
                stickerURI: './emoticons/imgly_sticker_emoticons_duckface.svg',
                tintMode: 'none',
                name: 'Duckface',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_furious',
                stickerURI: './emoticons/imgly_sticker_emoticons_furious.svg',
                tintMode: 'none',
                name: 'Furious',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_angry',
                stickerURI: './emoticons/imgly_sticker_emoticons_angry.svg',
                tintMode: 'none',
                name: 'Angry',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_steaming_furious',
                stickerURI: './emoticons/imgly_sticker_emoticons_steaming_furious.svg',
                tintMode: 'none',
                name: 'Steaming Furious',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_sad',
                stickerURI: './emoticons/imgly_sticker_emoticons_sad.svg',
                tintMode: 'none',
                name: 'Sad',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_anxious',
                stickerURI: './emoticons/imgly_sticker_emoticons_anxious.svg',
                tintMode: 'none',
                name: 'Anxious',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_cry',
                stickerURI: './emoticons/imgly_sticker_emoticons_cry.svg',
                tintMode: 'none',
                name: 'Cry',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_sobbing',
                stickerURI: './emoticons/imgly_sticker_emoticons_sobbing.svg',
                tintMode: 'none',
                name: 'Sobbing',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_loud_cry',
                stickerURI: './emoticons/imgly_sticker_emoticons_loud_cry.svg',
                tintMode: 'none',
                name: 'Loud Cry',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_wide_grin',
                stickerURI: './emoticons/imgly_sticker_emoticons_wide_grin.svg',
                tintMode: 'none',
                name: 'Wide grin',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_impatient',
                stickerURI: './emoticons/imgly_sticker_emoticons_impatient.svg',
                tintMode: 'none',
                name: 'Impatient',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_tired',
                stickerURI: './emoticons/imgly_sticker_emoticons_tired.svg',
                tintMode: 'none',
                name: 'Tired',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_asleep',
                stickerURI: './emoticons/imgly_sticker_emoticons_asleep.svg',
                tintMode: 'none',
                name: 'Asleep',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_sleepy',
                stickerURI: './emoticons/imgly_sticker_emoticons_sleepy.svg',
                tintMode: 'none',
                name: 'Sleepy',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_deceased',
                stickerURI: './emoticons/imgly_sticker_emoticons_deceased.svg',
                tintMode: 'none',
                name: 'Deceased',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_attention',
                stickerURI: './emoticons/imgly_sticker_emoticons_attention.svg',
                tintMode: 'none',
                name: 'Attention',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_question',
                stickerURI: './emoticons/imgly_sticker_emoticons_question.svg',
                tintMode: 'none',
                name: 'Question',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_not_speaking_to_you',
                stickerURI: './emoticons/imgly_sticker_emoticons_not_speaking_to_you.svg',
                tintMode: 'none',
                name: 'Not speaking to you',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_sick',
                stickerURI: './emoticons/imgly_sticker_emoticons_sick.svg',
                tintMode: 'none',
                name: 'Sick',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_pumpkin',
                stickerURI: './emoticons/imgly_sticker_emoticons_pumpkin.svg',
                tintMode: 'none',
                name: 'Pumpkin',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_boxer',
                stickerURI: './emoticons/imgly_sticker_emoticons_boxer.svg',
                tintMode: 'none',
                name: 'Boxer',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_idea',
                stickerURI: './emoticons/imgly_sticker_emoticons_idea.svg',
                tintMode: 'none',
                name: 'Idea',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_smoking',
                stickerURI: './emoticons/imgly_sticker_emoticons_smoking.svg',
                tintMode: 'none',
                name: 'Smoking',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_beer',
                stickerURI: './emoticons/imgly_sticker_emoticons_beer.svg',
                tintMode: 'none',
                name: 'Beer',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_skateboard',
                stickerURI: './emoticons/imgly_sticker_emoticons_skateboard.svg',
                tintMode: 'none',
                name: 'Skateboard',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_guitar',
                stickerURI: './emoticons/imgly_sticker_emoticons_guitar.svg',
                tintMode: 'none',
                name: 'Guitar',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_music',
                stickerURI: './emoticons/imgly_sticker_emoticons_music.svg',
                tintMode: 'none',
                name: 'Music',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_sunbathing',
                stickerURI: './emoticons/imgly_sticker_emoticons_sunbathing.svg',
                tintMode: 'none',
                name: 'Sunbathing',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_hippie',
                stickerURI: './emoticons/imgly_sticker_emoticons_hippie.svg',
                tintMode: 'none',
                name: 'Hippie',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_humourous',
                stickerURI: './emoticons/imgly_sticker_emoticons_humourous.svg',
                tintMode: 'none',
                name: 'Humourous',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_hitman',
                stickerURI: './emoticons/imgly_sticker_emoticons_hitman.svg',
                tintMode: 'none',
                name: 'Hitman',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_harry_potter',
                stickerURI: './emoticons/imgly_sticker_emoticons_harry_potter.svg',
                tintMode: 'none',
                name: 'Harry Potter',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_business',
                stickerURI: './emoticons/imgly_sticker_emoticons_business.svg',
                tintMode: 'none',
                name: 'Business',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_batman',
                stickerURI: './emoticons/imgly_sticker_emoticons_batman.svg',
                tintMode: 'none',
                name: 'Batman',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_skull',
                stickerURI: './emoticons/imgly_sticker_emoticons_skull.svg',
                tintMode: 'none',
                name: 'Skull',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_ninja',
                stickerURI: './emoticons/imgly_sticker_emoticons_ninja.svg',
                tintMode: 'none',
                name: 'Ninja',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_masked',
                stickerURI: './emoticons/imgly_sticker_emoticons_masked.svg',
                tintMode: 'none',
                name: 'Masked',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_alien',
                stickerURI: './emoticons/imgly_sticker_emoticons_alien.svg',
                tintMode: 'none',
                name: 'Alien',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_wrestler',
                stickerURI: './emoticons/imgly_sticker_emoticons_wrestler.svg',
                tintMode: 'none',
                name: 'Wrestler',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_devil',
                stickerURI: './emoticons/imgly_sticker_emoticons_devil.svg',
                tintMode: 'none',
                name: 'Devil',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_star',
                stickerURI: './emoticons/imgly_sticker_emoticons_star.svg',
                tintMode: 'none',
                name: 'Star',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_baby_chicken',
                stickerURI: './emoticons/imgly_sticker_emoticons_baby_chicken.svg',
                tintMode: 'none',
                name: 'Baby Chicken',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_rabbit',
                stickerURI: './emoticons/imgly_sticker_emoticons_rabbit.svg',
                tintMode: 'none',
                name: 'Rabbit',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_pig',
                stickerURI: './emoticons/imgly_sticker_emoticons_pig.svg',
                tintMode: 'none',
                name: 'Pig',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_emoticons_chicken',
                stickerURI: './emoticons/imgly_sticker_emoticons_chicken.svg',
                tintMode: 'none',
                name: 'Chicken',
                resizeMode: 'keepAspect',
            },
        ],
    },
    {
        identifier: 'imgly_sticker_shapes',
        name: 'Shapes',
        thumbnailURI: './categories/shapes.png',
        items: [
            {
                identifier: 'imgly_sticker_shapes_badge_01',
                stickerURI: './shapes/imgly_sticker_shapes_badge_01.svg',
                tintMode: 'solid',
                name: 'Shape Badge 01',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_04',
                stickerURI: './shapes/imgly_sticker_shapes_badge_04.svg',
                tintMode: 'solid',
                name: 'Shape Badge 04',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_12',
                stickerURI: './shapes/imgly_sticker_shapes_badge_12.svg',
                tintMode: 'solid',
                name: 'Shape Badge 12',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_06',
                stickerURI: './shapes/imgly_sticker_shapes_badge_06.svg',
                tintMode: 'solid',
                name: 'Shape Badge 06',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_13',
                stickerURI: './shapes/imgly_sticker_shapes_badge_13.svg',
                tintMode: 'solid',
                name: 'Shape Badge 13',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_36',
                stickerURI: './shapes/imgly_sticker_shapes_badge_36.svg',
                tintMode: 'solid',
                name: 'Shape Badge 36',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_08',
                stickerURI: './shapes/imgly_sticker_shapes_badge_08.svg',
                tintMode: 'solid',
                name: 'Shape Badge 08',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_11',
                stickerURI: './shapes/imgly_sticker_shapes_badge_11.svg',
                tintMode: 'solid',
                name: 'Shape Badge 11',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_35',
                stickerURI: './shapes/imgly_sticker_shapes_badge_35.svg',
                tintMode: 'solid',
                name: 'Shape Badge 35',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_28',
                stickerURI: './shapes/imgly_sticker_shapes_badge_28.svg',
                tintMode: 'solid',
                name: 'Shape Badge 28',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_32',
                stickerURI: './shapes/imgly_sticker_shapes_badge_32.svg',
                tintMode: 'solid',
                name: 'Shape Badge 32',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_15',
                stickerURI: './shapes/imgly_sticker_shapes_badge_15.svg',
                tintMode: 'solid',
                name: 'Shape Badge 15',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_20',
                stickerURI: './shapes/imgly_sticker_shapes_badge_20.svg',
                tintMode: 'solid',
                name: 'Shape Badge 20',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_18',
                stickerURI: './shapes/imgly_sticker_shapes_badge_18.svg',
                tintMode: 'solid',
                name: 'Shape Badge 18',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_badge_19',
                stickerURI: './shapes/imgly_sticker_shapes_badge_19.svg',
                tintMode: 'solid',
                name: 'Shape Badge 19',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_arrow_02',
                stickerURI: './shapes/imgly_sticker_shapes_arrow_02.svg',
                tintMode: 'solid',
                name: 'Shape Arrow 02',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_arrow_03',
                stickerURI: './shapes/imgly_sticker_shapes_arrow_03.svg',
                tintMode: 'solid',
                name: 'Shape Arrow 03',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_spray_01',
                stickerURI: './shapes/imgly_sticker_shapes_spray_01.svg',
                tintMode: 'solid',
                name: 'Shape Spray 01',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_spray_04',
                stickerURI: './shapes/imgly_sticker_shapes_spray_04.svg',
                tintMode: 'solid',
                name: 'Shape Spray 04',
                resizeMode: 'keepAspect',
            },
            {
                identifier: 'imgly_sticker_shapes_spray_03',
                stickerURI: './shapes/imgly_sticker_shapes_spray_03.svg',
                tintMode: 'solid',
                name: 'Shape Spray 03',
                resizeMode: 'keepAspect',
            },
        ],
    },
];

var metadata$6 = [
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_thislayoutisgreat.png',
        identifier: 'imgly_text_design_blocks',
        name: 'Blocks',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_fatandfast.png',
        identifier: 'imgly_text_design_rotated',
        name: 'Rotated',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_summerfeeling.png',
        identifier: 'imgly_text_design_blocks_light',
        name: 'Blocks Light',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_typewithstyle.png',
        identifier: 'imgly_text_design_equal_width',
        name: 'Equal Width',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_inthebox.png',
        identifier: 'imgly_text_design_masked',
        name: 'Masked',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_bluefriday.png',
        identifier: 'imgly_text_design_celebrate',
        name: 'Celebrate',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_decorative.png',
        identifier: 'imgly_text_design_sunshine',
        name: 'Sunshine',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_specialdeals.png',
        identifier: 'imgly_text_design_masked_badge',
        name: 'Masked Badge',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_doublelines.png',
        identifier: 'imgly_text_design_blocks_condensed',
        name: 'Blocks Condensed',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_celebrate.png',
        identifier: 'imgly_text_design_celebrate_simple',
        name: 'Celebrate Simple',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_beerandburger.png',
        identifier: 'imgly_text_design_equal_width_fat',
        name: 'Equal Width Fat',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_watercolor.png',
        identifier: 'imgly_text_design_watercolor',
        name: 'Watercolor',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_particle.png',
        identifier: 'imgly_text_design_particles',
        name: 'Particles',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_yeah.png',
        identifier: 'imgly_text_design_masked_speech_bubble',
        name: 'Masked Speech Bubble',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_thisisadream.png',
        identifier: 'imgly_text_design_masked_speech_bubble_comic',
        name: 'Masked Speech Bubble Comic',
    },
    {
        thumbnailURI: './items/dark/imgly_text_design_icon_fatface.png',
        identifier: 'imgly_text_design_multiline',
        name: 'Multiline',
    },
];

var metadata$7 = [
    {
        thumbnailURI: './items/light/imgly_text_design_icon_thislayoutisgreat.png',
        identifier: 'imgly_text_design_blocks',
        name: 'Blocks',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_fatandfast.png',
        identifier: 'imgly_text_design_rotated',
        name: 'Rotated',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_summerfeeling.png',
        identifier: 'imgly_text_design_blocks_light',
        name: 'Blocks Light',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_typewithstyle.png',
        identifier: 'imgly_text_design_equal_width',
        name: 'Equal Width',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_inthebox.png',
        identifier: 'imgly_text_design_masked',
        name: 'Masked',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_bluefriday.png',
        identifier: 'imgly_text_design_celebrate',
        name: 'Celebrate',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_decorative.png',
        identifier: 'imgly_text_design_sunshine',
        name: 'Sunshine',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_specialdeals.png',
        identifier: 'imgly_text_design_masked_badge',
        name: 'Masked Badge',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_doublelines.png',
        identifier: 'imgly_text_design_blocks_condensed',
        name: 'Blocks Condensed',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_celebrate.png',
        identifier: 'imgly_text_design_celebrate_simple',
        name: 'Celebrate Simple',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_beerandburger.png',
        identifier: 'imgly_text_design_equal_width_fat',
        name: 'Equal Width Fat',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_watercolor.png',
        identifier: 'imgly_text_design_watercolor',
        name: 'Watercolor',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_particle.png',
        identifier: 'imgly_text_design_particles',
        name: 'Particles',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_yeah.png',
        identifier: 'imgly_text_design_masked_speech_bubble',
        name: 'Masked Speech Bubble',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_thisisadream.png',
        identifier: 'imgly_text_design_masked_speech_bubble_comic',
        name: 'Masked Speech Bubble Comic',
    },
    {
        thumbnailURI: './items/light/imgly_text_design_icon_fatface.png',
        identifier: 'imgly_text_design_multiline',
        name: 'Multiline',
    },
];

var metadata$8 = [
    {
        identifier: 'imgly_frame_dia',
        name: 'Dia',
        layoutMode: 'horizontal-inside',
        thumbnailURI: './items/imgly_frame_dia/imgly_frame_dia_thumb.png',
        imageGroups: {
            top: {
                mid: {
                    image: './items/imgly_frame_dia/imgly_frame_dia_top.png',
                    mode: 'repeat',
                },
            },
            left: {
                start: './items/imgly_frame_dia/imgly_frame_dia_top_corner_left.png',
                mid: './items/imgly_frame_dia/imgly_frame_dia_left.png',
                end: './items/imgly_frame_dia/imgly_frame_dia_bottom_corner_left.png',
            },
            right: {
                start: './items/imgly_frame_dia/imgly_frame_dia_top_corner_right.png',
                mid: './items/imgly_frame_dia/imgly_frame_dia_right.png',
                end: './items/imgly_frame_dia/imgly_frame_dia_bottom_corner_right.png',
            },
            bottom: {
                mid: {
                    image: './items/imgly_frame_dia/imgly_frame_dia_bottom.png',
                    mode: 'repeat',
                },
            },
        },
    },
    {
        identifier: 'imgly_frame_art_decor',
        name: 'Art Decor',
        tintable: true,
        layoutMode: 'horizontal-inside',
        thumbnailURI: './items/imgly_frame_art_decor/imgly_frame_art_decor_thumb.png',
        imageGroups: {
            top: {
                start: './items/imgly_frame_art_decor/imgly_frame_art_decor_top_corner_left.png',
                mid: {
                    image: './items/imgly_frame_art_decor/imgly_frame_art_decor_top.png',
                    mode: 'stretch',
                },
                end: './items/imgly_frame_art_decor/imgly_frame_art_decor_top_corner_right.png',
            },
            left: {
                mid: {
                    image: './items/imgly_frame_art_decor/imgly_frame_art_decor_left.png',
                    mode: 'stretch',
                },
            },
            right: {
                mid: {
                    image: './items/imgly_frame_art_decor/imgly_frame_art_decor_right.png',
                    mode: 'stretch',
                },
            },
            bottom: {
                start: './items/imgly_frame_art_decor/imgly_frame_art_decor_bottom_corner_left.png',
                mid: {
                    image: './items/imgly_frame_art_decor/imgly_frame_art_decor_bottom.png',
                    mode: 'stretch',
                },
                end: './items/imgly_frame_art_decor/imgly_frame_art_decor_bottom_corner_right.png',
            },
        },
    },
    {
        identifier: 'imgly_frame_black_passepartout',
        name: 'Black Passepartout',
        layoutMode: 'horizontal-inside',
        thumbnailURI: './items/imgly_frame_black_passepartout/imgly_frame_black_passepartout_thumb.png',
        imageGroups: {
            top: {
                start: './items/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top_corner_left.png',
                mid: {
                    image: './items/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top.png',
                    mode: 'stretch',
                },
                end: './items/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top_corner_right.png',
            },
            left: {
                mid: {
                    image: './items/imgly_frame_black_passepartout/imgly_frame_black_passepartout_left.png',
                    mode: 'stretch',
                },
            },
            right: {
                mid: {
                    image: './items/imgly_frame_black_passepartout/imgly_frame_black_passepartout_right.png',
                    mode: 'stretch',
                },
            },
            bottom: {
                start: './items/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom_corner_left.png',
                mid: {
                    image: './items/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom.png',
                    mode: 'stretch',
                },
                end: './items/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom_corner_right.png',
            },
        },
    },
    {
        identifier: 'imgly_frame_wood_passepartout',
        name: 'Wood Passepartout',
        layoutMode: 'horizontal-inside',
        thumbnailURI: './items/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_thumb.png',
        imageGroups: {
            top: {
                start: './items/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top_corner_left.png',
                mid: {
                    image: './items/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top.png',
                    mode: 'stretch',
                },
                end: './items/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top_corner_right.png',
            },
            left: {
                mid: {
                    image: './items/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_left.png',
                    mode: 'stretch',
                },
            },
            right: {
                mid: {
                    image: './items/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_right.png',
                    mode: 'stretch',
                },
            },
            bottom: {
                start: './items/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom_corner_left.png',
                mid: {
                    image: './items/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom.png',
                    mode: 'stretch',
                },
                end: './items/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom_corner_right.png',
            },
        },
    },
    {
        identifier: 'imgly_frame_lowpoly_shadow',
        name: 'Low Poly',
        layoutMode: 'horizontal-inside',
        thumbnailURI: './items/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_thumb.png',
        imageGroups: {
            top: {
                start: './items/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top_corner_left.png',
                mid: {
                    image: './items/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top.png',
                    mode: 'stretch',
                },
                end: './items/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top_corner_right.png',
            },
            left: {
                mid: {
                    image: './items/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_left.png',
                    mode: 'stretch',
                },
            },
            right: {
                mid: {
                    image: './items/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_right.png',
                    mode: 'stretch',
                },
            },
            bottom: {
                start: './items/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom_corner_left.png',
                mid: {
                    image: './items/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom.png',
                    mode: 'stretch',
                },
                end: './items/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom_corner_right.png',
            },
        },
    },
];

var metadata$9 = [
    {
        identifier: 'imgly_transforms_common',
        name: 'Common',
        items: [
            {
                identifier: 'imgly_transform_common_custom',
                name: 'Custom',
                thumbnailURI: '',
                ratio: '*',
            },
            {
                identifier: 'imgly_transform_common_square',
                name: 'Square',
                thumbnailURI: '',
                ratio: 1,
            },
            {
                identifier: 'imgly_transform_common_4',
                name: '4:3',
                thumbnailURI: '',
                ratio: 1.33,
            },
            {
                identifier: 'imgly_transform_common_16',
                name: '16:9',
                thumbnailURI: '',
                ratio: 1.77,
            },
            {
                identifier: 'imgly_transform_common_3',
                name: '3:4',
                thumbnailURI: '',
                ratio: 0.75,
            },
            {
                identifier: 'imgly_transform_common_9',
                name: '9:16',
                thumbnailURI: '',
                ratio: 0.56,
            },
        ],
    },
    {
        identifier: 'imgly_transforms_facebook',
        name: 'Facebook',
        items: [
            {
                identifier: 'imgly_transform_facebook_profile',
                name: 'Profile',
                thumbnailURI: '',
                dimensions: {
                    x: 300,
                    y: 300,
                },
                forceDimensions: true,
                lockDimensions: true,
            },
            {
                identifier: 'imgly_transform_facebook_title',
                name: 'Title',
                thumbnailURI: '',
                dimensions: {
                    x: 1200,
                    y: 627,
                },
                forceDimensions: true,
                lockDimensions: true,
            },
            {
                identifier: 'imgly_transform_facebook_post',
                name: 'Post',
                thumbnailURI: '',
                dimensions: {
                    x: 940,
                    y: 788,
                },
                forceDimensions: true,
                lockDimensions: true,
            },
        ],
    },
    {
        identifier: 'imgly_transforms_instagram',
        name: 'Instagram',
        items: [
            {
                identifier: 'imgly_transform_instagram_landscape',
                name: 'Landscape',
                thumbnailURI: '',
                dimensions: {
                    x: 1080,
                    y: 566,
                },
                forceDimensions: true,
                lockDimensions: true,
            },
            {
                identifier: 'imgly_transform_instagram_portrait',
                name: 'Portrait',
                thumbnailURI: '',
                dimensions: {
                    x: 1080,
                    y: 1350,
                },
                forceDimensions: true,
                lockDimensions: true,
            },
            {
                identifier: 'imgly_transform_instagram_square',
                name: 'Square',
                thumbnailURI: '',
                dimensions: {
                    x: 1080,
                    y: 1080,
                },
                forceDimensions: true,
                lockDimensions: true,
            },
            {
                identifier: 'imgly_transform_instagram_story',
                name: 'Story',
                thumbnailURI: '',
                dimensions: {
                    x: 1080,
                    y: 1920,
                },
                forceDimensions: true,
                lockDimensions: true,
            },
        ],
    },
    {
        identifier: 'imgly_transforms_twitter',
        name: 'Twitter',
        items: [
            {
                identifier: 'imgly_transform_twitter_post',
                name: 'Post',
                thumbnailURI: '',
                dimensions: {
                    x: 1024,
                    y: 512,
                },
                forceDimensions: true,
                lockDimensions: true,
            },
            {
                identifier: 'imgly_transform_twitter_profile',
                name: 'Profile',
                thumbnailURI: '',
                dimensions: {
                    x: 400,
                    y: 400,
                },
                forceDimensions: true,
                lockDimensions: true,
            },
            {
                identifier: 'imgly_transform_twitter_title',
                name: 'Title',
                thumbnailURI: '',
                dimensions: {
                    x: 1500,
                    y: 500,
                },
                forceDimensions: true,
                lockDimensions: true,
            },
        ],
    },
];

/**
 *  The font identifiers of the fonts supported by the text tool
 */
var textFontIDs = [
    'imgly_font_open_sans_bold',
    'imgly_font_aleo_bold',
    'imgly_font_amaticsc',
    'imgly_font_bernier_regular',
    'imgly_font_cheque_regular',
    'imgly_font_gagalin_regular',
    'imgly_font_hagin_caps_thin',
    'imgly_font_intro_inline',
    'imgly_font_lobster',
    'imgly_font_nexa_script',
    'imgly_font_ostrich_sans_black',
    'imgly_font_ostrich_sans_bold',
    'imgly_font_panton_blackitalic_caps',
    'imgly_font_panton_lightitalic_caps',
    'imgly_font_perfograma',
    'imgly_font_trash_hand',
];
var textDesignFontIds = [
    'imgly_font_abril_fatface_regular',
    'imgly_font_montserrat_light',
    'imgly_font_wolesbro',
    'imgly_font_permanent_marker',
    'imgly_font_panton_light_italic_caps',
    'imgly_font_panton_black_italic_caps',
    'imgly_font_panton_light_caps',
    'imgly_font_panton_black_caps',
    'imgly_font_amberlight',
    'imgly_font_ultra',
    'imgly_font_galano_grotesque_bold',
    'imgly_font_bungee_inline',
    'imgly_font_petit_formal_script',
    'imgly_font_summer_font_light',
    'imgly_font_handycheera_regular',
    'imgly_font_rasa_regular',
    'imgly_font_rasa_500',
    'imgly_font_campton_bold',
    'imgly_font_ostrich_sans_bold',
    'imgly_font_ostrich_sans_heavy',
];

var FontManager = /** @class */ (function () {
    function FontManager(assetManager) {
        this.assetManager = assetManager;
        /**
         * A map of all fonts that have already been injected into the head as link or style tags.
         * Not all of these fonts have necessarily been issued to load yet.
         */
        this.injectedFonts = {};
        /**
         * A map of all fonts that have been confirmed to be loaded by the browser.
         */
        this.loadedFonts = {};
    }
    /** For Web fonts, woff format */
    /**
     * Creates the font-face CSS declarations for all given fonts.
     * @param allFonts The Web fonts.
     * @param getAbsolutePath A function that resolves the absolute path for each font asset.
     */
    FontManager.createFontFacesCSS = function (allFonts, getAbsolutePath) {
        return allFonts.map(function (font) {
            var fontPath = getAbsolutePath(font.fontURI);
            return ("@font-face {\n        font-family: \"" + font.fontFamily + "\";\n        src: url('" + fontPath + "') format('" + (font.format || 'woff') + "');\n        font-weight: " + (font.fontWeight || 'normal') + ";\n        font-style: " + (font.fontStyle || 'normal') + ";\n      }");
        });
    };
    /**
     * Returns the font variation with the given identifier.
     * Throws an error if the such a font does not exist.
     * @param identifier The identifier of the font variation
     */
    FontManager.prototype.getFontWithId = function (identifier) {
        var font = this.assetManager.getFontAsset(identifier);
        if (!font) {
            throw new Error('The requested font does not exist as an asset.');
        }
        return font;
    };
    /**
     * Returns whether or not the specified font is currently loaded.
     * @param identifier The font identifier.
     */
    FontManager.prototype.isFontLoaded = function (identifier) {
        return this.loadedFonts[identifier] !== undefined;
    };
    /**
     * Injects declarations for all fonts of the AssetManager into the page.
     * This does not automatically load the fonts. Use {@link loadAllFonts} instead
     * to both inject and immediately start loading the fonts.
     */
    FontManager.prototype.injectAllFonts = function () {
        var allFonts = this.assetManager.getFontAssets();
        this.injectFonts(allFonts);
    };
    /**
     * Injects and loads all fonts of the AssetManager into the page.
     * The promise resolves once all fonts have finished loading.
     */
    FontManager.prototype.loadAllFonts = function () {
        return __awaiter(this, void 0, void 0, function () {
            var allFonts;
            return __generator(this, function (_a) {
                allFonts = this.assetManager.getFontAssets();
                return [2 /*return*/, this.loadFonts(allFonts)];
            });
        });
    };
    /**
     * Loads all fonts with the given identifiers.
     * The promise resolves once all fonts have finished loading.
     * @param identifiers The font identifiers.
     */
    FontManager.prototype.loadFontsWithIdentifiers = function (identifiers) {
        return __awaiter(this, void 0, void 0, function () {
            var fonts;
            var _this = this;
            return __generator(this, function (_a) {
                fonts = identifiers.map(function (id) { return _this.getFontWithId(id); });
                return [2 /*return*/, this.loadFonts(fonts)];
            });
        });
    };
    /**
     * Loads all of the specified fonts.
     * The promise resolves once all fonts have finished loading.
     * @param fonts The fonts to be loaded.
     */
    FontManager.prototype.loadFonts = function (fonts) {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            var _this = this;
            return __generator(this, function (_a) {
                this.injectFonts(fonts);
                promises = new Array();
                fonts.forEach(function (f) {
                    promises.push(_this.loadFont(f, false));
                });
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        Promise.all(promises).then(function () { return resolve(); }).catch(function (e) { return reject(e); });
                    })];
            });
        });
    };
    /**
     * Loads the specified font.
     * The promise resolves once the font has finished loading and is ready to be used
     * for rendering operations.
     * @param font The font to be loaded
     * @param inject Whether the font should be attempted to be injected.
     * Set to false if you know that the font has already been injected into the page.
     */
    FontManager.prototype.loadFont = function (font, inject) {
        if (inject === void 0) { inject = true; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (_this.isFontLoaded(font.identifier)) {
                            resolve();
                        }
                        if (inject) {
                            _this.injectFonts([font]);
                        }
                        // Try to figure out when the font is actually loaded by the browser
                        // and ready to be used
                        var observer = new FontFaceObserver(font);
                        observer.load().then(function () {
                            _this.loadedFonts[font.identifier] = font;
                            resolve();
                        }).catch(function (e) {
                            reject(e);
                        });
                    })];
            });
        });
    };
    /**
     * Loads the font with the specified identifier. Throws an error if no such font exists.
     * @param identifier The identifier of the font to be loaded.
     * @param inject Whether the font should be attempted to be injected.
     * Set to false if you know that the font has already been injected into the page.
     */
    FontManager.prototype.loadFontWithIdentifier = function (identifier, inject) {
        if (inject === void 0) { inject = true; }
        return __awaiter(this, void 0, void 0, function () {
            var font;
            return __generator(this, function (_a) {
                font = this.assetManager.getFontAsset(identifier);
                if (!font) {
                    throw new Error("The requested font asset with identifier " + identifier + " does not exist!");
                }
                return [2 /*return*/, this.loadFont(font, inject)];
            });
        });
    };
    /**
     * Injects the specified fonts into the page without loading them.
     * @param fonts The fonts to be injected.
     */
    FontManager.prototype.injectFonts = function (fonts, getAbsolutePath) {
        if (getAbsolutePath === void 0) { getAbsolutePath = this.assetManager.getAbsolutePathForCategory('font'); }
        var googleFonts = fonts.filter(isGoogleFontAsset);
        var webFonts = fonts.filter(isWebFontAsset);
        if (googleFonts.length > 0) {
            this.addGoogleFontLinks(googleFonts);
        }
        if (webFonts.length > 0) {
            this.addWebFontCSS(webFonts, getAbsolutePath);
        }
    };
    /**
     * Adds a single link element that references all of the given Google fonts
     * to the head of the page.
     * @param allFonts The Google fonts to be injected into the page.
     */
    FontManager.prototype.addGoogleFontLinks = function (allFonts) {
        var _this = this;
        // Make sure we are not adding the same link multiple times
        var fonts = allFonts.filter(function (f) { return !_this.injectedFonts[f.identifier]; });
        if (fonts.length === 0) {
            return;
        }
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = "https://fonts.googleapis.com/css?family=" + fonts.map(function (f) { return f.fontFamily; }).join(',');
        var head = document.getElementsByTagName('head')[0];
        head.appendChild(link);
        allFonts.forEach(function (f) {
            _this.injectedFonts[f.identifier] = f;
        });
    };
    /**
     * Adds a style element that declares all of the specified Web fonts to the head
     * of the page.
     * @param allFonts The fonts to be injected.
     * @param getAbsolutePath A function that resolves the absolute path to each font asset.
     */
    FontManager.prototype.addWebFontCSS = function (allFonts, getAbsolutePath) {
        var _this = this;
        // Make sure we are not adding the same link multiple times
        var fonts = allFonts.filter(function (f) { return !_this.injectedFonts[f.identifier]; });
        if (fonts.length === 0) {
            return;
        }
        var fontFaces = FontManager.createFontFacesCSS(fonts, getAbsolutePath);
        var css = "\n      /* Injected by PhotoEditorSDK */\n      " + fontFaces.join('\n') + "\n    ";
        var styleTag = document.createElement('style');
        styleTag.innerHTML = css;
        document.head.appendChild(styleTag);
        allFonts.forEach(function (f) {
            _this.injectedFonts[f.identifier] = f;
        });
    };
    return FontManager;
}());

var AssetManager = /** @class */ (function () {
    function AssetManager(config) {
        var _this = this;
        this.basePath = 'assets/';
        /** For Editor / UI */
        this.getAssets = function (category) {
            switch (category) {
                case 'overlay':
                    return _this.overlayAssets;
                case 'filter':
                    return _this.filterCategories;
                case 'font':
                    return _this.fontAssets;
                case 'focus':
                    return _this.focusAssets;
                case 'adjustment':
                    return _this.adjustmentCategories;
                case 'sticker':
                    return _this.stickerCategories;
                case 'textdesign':
                    return _this.textDesignAssets;
                case 'frame':
                    return _this.frameAssets;
                case 'transform':
                    return _this.transformCategories;
            }
            return [];
        };
        this.getAbsolutePath = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var assetPath = path.join.apply(path, __spread(args));
            // Don't prepend baseUrl to absolute urls
            if (_this.basePath.match(/(ftp|http|https):\/\//)) {
                var length_1 = _this.basePath.length;
                if (_this.basePath[length_1 - 1] !== '/') {
                    _this.basePath = _this.basePath + '/';
                }
                return _this.basePath + assetPath;
            }
            return path.join(_this.basePath, assetPath);
        };
        this.getAbsolutePathForCategory = function (assetCategory) {
            return function () {
                var path1 = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    path1[_i] = arguments[_i];
                }
                return _this.getAbsolutePath.apply(_this, __spread([assetCategory], path1));
            };
        };
        this.addCustomStickerAsset = function (stickerAssets, customStickerCategoryIdentifier, customStickerLabel) {
            stickerAssets.forEach(function (stickerAsset) {
                var thumbnailURI = stickerAsset.thumbnailURI, name = stickerAsset.name, image = stickerAsset.sticker, identifier = stickerAsset.identifier, tintMode = stickerAsset.tintMode, resizeMode = stickerAsset.resizeMode;
                var custom = _this.stickerCategories.find(function (s) { return s.identifier === customStickerCategoryIdentifier; });
                var newAsset = {
                    identifier: identifier,
                    name: name,
                    thumbnailURI: thumbnailURI,
                    sticker: image,
                    tintMode: tintMode,
                    resizeMode: resizeMode,
                };
                if (custom && isStickerCategoryDynamic(custom)) {
                    custom.items.push(newAsset);
                }
                else {
                    /**
                     * There's no specified thumbnail for custom stickers,
                     * so first uploaded image gets to be the thumbnail
                     */
                    var newCategory = {
                        identifier: customStickerCategoryIdentifier,
                        name: customStickerLabel,
                        thumbnail: thumbnailURI,
                        items: [newAsset],
                    };
                    _this.stickerCategories = __spread([newCategory], _this.stickerCategories);
                }
            });
            _this.stickerAssets = _this.stickerCategories.reduce(_this.allOptions, []);
        };
        this.getPath = function (source, identifier, key) {
            var item = source.find(function (option) { return option.identifier === identifier; });
            return item ? item[key] || item.path || '' : '';
        };
        this.isNonExistingFont = function (configuredFont) { return !metadata$2.find(function (f) { return f.identifier === configuredFont.identifier; }); };
        if (config && config.basePath) {
            this.basePath = config.basePath;
        }
        /** Filters */
        var allFilters = metadata$1.reduce(this.allOptions, []);
        if (config && config.filter) {
            this.filterCategories = this.configuredCategory(metadata$1, config.filter, allFilters);
        }
        else {
            this.filterCategories = metadata$1;
        }
        this.lutFilterAssets = this.filterCategories
            .reduce(this.allOptions, [])
            .filter(function (f) { return isLUTFilterAsset(f); });
        this.duoToneFilterAssets = this.filterCategories
            .reduce(this.allOptions, [])
            .filter(function (f) { return isDuoToneFilterAsset(f); });
        // /** Adjustments */
        var allAdjustments = metadata$4.reduce(this.allOptions, []);
        if (config && config.adjustment) {
            this.adjustmentCategories = this.configuredCategory(metadata$4, config.adjustment, allAdjustments);
        }
        else {
            this.adjustmentCategories = metadata$4;
        }
        /** Text */
        this.fontAssets = metadata$2.reduce(this.allOptions, []);
        var textToolFontAssets = textFontIDs.map(function (identifier) { return _this.getFontAsset(identifier); });
        if (config && config.text && config.text.fonts) {
            var nonDefaultFonts = config.text.fonts.filter(this.isNonExistingFont);
            textToolFontAssets = config.text.fonts ? __spread(textToolFontAssets, nonDefaultFonts) : textToolFontAssets;
            this.fontAssets = config.text.fonts ? __spread(this.fontAssets, nonDefaultFonts) : this.fontAssets;
        }
        this.textToolFontAssets = textToolFontAssets;
        /** Focus */
        var configuredFocus = config && config.focus && config.focus.items && config.focus.items.length
            ? config.focus.items.map(function (f) { return metadata$3.find(function (i) { return i.identifier === f.identifier; }); })
            : metadata$3;
        this.focusAssets = configuredFocus;
        /** Overlay */
        if (config && config.overlay && config.overlay.items) {
            this.overlayAssets = this.configuredItem(config.overlay.items, metadata, metadata);
        }
        else {
            this.overlayAssets = metadata;
        }
        /** Frame */
        if (config && config.frame && config.frame.items) {
            this.frameAssets = this.configuredItem(config.frame.items, metadata$8, metadata$8);
        }
        else {
            this.frameAssets = metadata$8;
        }
        /** Stickers */
        var allStickers = metadata$5.reduce(this.allOptions, []);
        if (config && config.sticker) {
            this.stickerCategories = this.configuredCategory(metadata$5, config.sticker, allStickers);
        }
        else {
            this.stickerCategories = metadata$5;
        }
        this.stickerAssets = this.stickerCategories.reduce(this.allOptions, []);
        var textdesignConfig = metadata$6;
        if (config && config.theme === 'light') {
            textdesignConfig = metadata$7;
        }
        /** TextDesign */
        this.textDesignAssets =
            config && config.textdesign && config.textdesign.items && config.textdesign.items.length
                ? config.textdesign.items.map(function (f) { return textdesignConfig.find(function (i) { return i.identifier === f.identifier; }); })
                : textdesignConfig;
        this.textDesignToolFontAssets = textDesignFontIds.map(function (identifier) { return _this.getFontAsset(identifier); });
        /** Transform */
        var allRatios = metadata$9.reduce(this.allOptions, []);
        if (config && config.transform) {
            this.transformCategories = this.configuredCategory(metadata$9, config.transform, allRatios);
        }
        else {
            this.transformCategories = metadata$9;
        }
        this.transformAssets = this.transformCategories.reduce(this.allOptions, []);
        this.fontManager = new FontManager(this);
    }
    AssetManager.prototype.getFontManager = function () {
        return this.fontManager;
    };
    /**
     * For Engine
     * TODO: Filter identifier comes with a resolution postfix
     */
    AssetManager.prototype.getAssetSource = function (category, identifier) {
        switch (category) {
            case 'filter':
                var lutFilter = this.getLUTFilterAsset(identifier);
                if (lutFilter) {
                    return this.getAbsolutePath(category, this.getPath(this.lutFilterAssets, identifier, 'lutURI'));
                }
                break;
            case 'overlay':
                return this.getAbsolutePath(category, this.getPath(this.overlayAssets, identifier, 'overlayURI'));
            case 'font':
                return this.getAbsolutePath(category, this.getPath(this.fontAssets, identifier, 'fontURI'));
            case 'sticker':
                var stickerAsset = this.stickerAssets.find(function (s) { return s.identifier === identifier; });
                if (stickerAsset) {
                    if (isStickerAssetDynamic(stickerAsset)) {
                        return stickerAsset.sticker;
                    }
                    else {
                        return this.getAbsolutePath(category, this.getPath(this.stickerAssets, identifier, 'stickerURI'));
                    }
                }
                throw new Error('Cannot resolve this type of sticker asset yet');
            case 'textdesign':
                return this.getAbsolutePath(category, 'engine', identifier);
            case 'frame':
                // Here, identifier is the combination of frame + patch
                return this.getAbsolutePath(category, identifier);
        }
        throw new Error('Cannot resolve this type of asset yet');
    };
    AssetManager.prototype.getDuotoneFilterAsset = function (identifier) {
        return this.duoToneFilterAssets.filter(function (f) { return f.identifier === identifier; })[0];
    };
    AssetManager.prototype.getLUTFilterAsset = function (identifier) {
        return this.lutFilterAssets.filter(function (f) { return f.identifier === identifier; })[0];
    };
    AssetManager.prototype.getOverlayAsset = function (identifier) {
        return this.overlayAssets.filter(function (o) { return o.identifier === identifier; })[0];
    };
    AssetManager.prototype.getStickerAsset = function (identifier) {
        return this.stickerAssets.filter(function (s) { return s.identifier === identifier; })[0];
    };
    AssetManager.prototype.getFontAsset = function (identifier) {
        return this.fontAssets.filter(function (f) { return f.identifier === identifier; })[0];
    };
    AssetManager.prototype.getTextDesignAssets = function (identifier) {
        return this.textDesignAssets.filter(function (t) { return t.identifier === identifier; })[0];
    };
    AssetManager.prototype.getFrameAsset = function (identifier) {
        return this.frameAssets.filter(function (f) { return f.identifier === identifier; })[0];
    };
    AssetManager.prototype.getFontAssets = function () {
        return this.fontAssets;
    };
    AssetManager.prototype.getFontAssetsForText = function () {
        return this.textToolFontAssets;
    };
    AssetManager.prototype.getFontAssetsForTextDesign = function () {
        return this.textDesignToolFontAssets;
    };
    AssetManager.prototype.getFrameAssets = function () {
        return this.frameAssets;
    };
    AssetManager.prototype.allOptions = function (acc, category) {
        if (category.hasOwnProperty('items')) {
            return __spread(acc, category.items);
        }
        return __spread(acc, [category]);
    };
    AssetManager.prototype.configuredCategory = function (categories, configured, allItems) {
        var _this = this;
        if (configured.categories && configured.categories.length) {
            return configured.categories.map(function (configuredCategory) {
                var existing = categories.find(function (c) { return c.identifier === configuredCategory.identifier; });
                if (existing) {
                    /** If the category is existing, ie, the identifier exists, merge it with the current category */
                    return __assign({}, existing, configuredCategory, { items: _this.configuredItem(configuredCategory.items, allItems, existing.items).filter(Boolean) });
                }
                return __assign({}, configuredCategory, { items: _this.configuredItem(configuredCategory.items, allItems, configuredCategory.items).filter(Boolean) });
            });
        }
        return categories;
    };
    AssetManager.prototype.configuredItem = function (items, allItems, defaultItems) {
        if (items && items.length) {
            return items
                .map(function (item) {
                var existing = allItems.find(function (i) { return i.identifier === item.identifier; });
                if (existing) {
                    /** If the item is existing, ie, the identifier exists, merge it with the current item */
                    return __assign({}, existing, item);
                }
                return item;
            })
                .filter(Boolean);
        }
        return defaultItems;
    };
    return AssetManager;
}());

var rgbToHex = function (r) {
    var hex = Number(r).toString(16);
    if (hex.length < 2) {
        hex = "0" + hex;
    }
    return hex;
};
var fullColorHex = function (r, g, b) {
    var red = rgbToHex(r * 255);
    var green = rgbToHex(g * 255);
    var blue = rgbToHex(b * 255);
    return "#" + red + green + blue;
};
var convertToColorString = function (color) {
    if (isRGBAArray(color)) {
        var _a = __read(color, 4), r = _a[0], g = _a[1], b = _a[2], a = _a[3];
        return "rgba(" + r * 255 + ", " + g * 255 + ", " + b * 255 + ", " + a + ")";
    }
    if (isRGBAObject(color)) {
        var r = color.r, g = color.g, b = color.b, a = color.a;
        return "rgba(" + r * 255 + ", " + g * 255 + ", " + b * 255 + ", " + a + ")";
    }
    if (isRGBArray(color)) {
        var _b = __read(color, 3), r = _b[0], g = _b[1], b = _b[2];
        return fullColorHex(r, g, b);
    }
    if (isRGBObject(color)) {
        var r = color.r, g = color.g, b = color.b;
        return fullColorHex(r, g, b);
    }
    return color;
};
var ColorObject = {
    black: [0 / 255, 0 / 255, 0 / 255, 1],
    white: [255 / 255, 255 / 255, 255 / 255, 1],
    gray: [191 / 255, 191 / 255, 191 / 255, 1],
    blue: [102 / 255, 134 / 255, 255 / 255, 1],
    skyBlue: [102 / 255, 204 / 255, 255 / 255, 1],
    red: [231 / 255, 80 / 255, 80 / 255, 1],
    orange: [242 / 255, 136 / 255, 85 / 255, 1],
    yellow: [255 / 255, 247 / 255, 99 / 255, 1],
};
var BackgroundColorObject = {
    transparent: [0 / 255, 0 / 255, 0 / 255, 0],
    black: [0 / 255, 0 / 255, 0 / 255, 1],
    white: [255 / 255, 255 / 255, 255 / 255, 1],
    blue: [102 / 255, 134 / 255, 255 / 255, 1],
    skyBlue: [102 / 255, 204 / 255, 255 / 255, 1],
    red: [231 / 255, 80 / 255, 80 / 255, 1],
    orange: [242 / 255, 136 / 255, 85 / 255, 1],
    yellow: [255 / 255, 247 / 255, 99 / 255, 1],
};

var DefaultTools = [
    Tool.LIBRARY,
    [Tool.TRANSFORM, Tool.FILTER, Tool.ADJUSTMENT],
    [Tool.FOCUS, Tool.FRAME, Tool.OVERLAY],
    [Tool.TEXT, Tool.TEXT_DESIGN, Tool.STICKER, Tool.BRUSH],
];

var defaultConfig = {
    license: '',
    order: 'default',
    language: 'en',
    theme: 'dark',
    layout: 'advanced',
    mainCanvasActions: [CanvasAction.UNDO, CanvasAction.REDO, CanvasAction.EXPORT, CanvasAction.CLOSE],
    displayResizeWarning: true,
    displayCloseWarning: true,
    engine: {
        crossOrigin: 'anonymous',
        downscaleOptions: {
            maxMegaPixels: {
                desktop: 10,
                mobile: 5,
            },
        },
    },
    enableZoom: true,
    forceCrop: false,
    assetBaseUrl: 'assets/',
    defaultTool: Tool.FILTER,
    tools: DefaultTools,
    snapping: new SnappingConfiguration(),
    filter: new FilterConfiguration(),
    focus: new FocusConfiguration(),
    adjustment: new AdjustmentConfiguration(),
    library: new LibraryConfiguration(),
    overlay: new OverlayConfiguration(),
    sticker: new StickerConfiguration(),
    text: new TextConfiguration(),
    textdesign: new TextDesignConfiguration(),
    frame: new FrameConfiguration(),
    brush: new BrushConfiguration(),
    transform: new TransformConfiguration(),
    export: {
        image: {
            exportType: ExportFormat.IMAGE,
            format: ImageFormat.PNG,
            quality: 0.9,
            enableDownload: true,
        },
        filename: 'photoeditorsdk-export',
    },
    custom: {},
};

var CardType;
(function (CardType) {
    CardType["LARGE"] = "large";
    CardType["MEDIUM"] = "medium";
    CardType["SMALL"] = "small";
})(CardType || (CardType = {}));

var ModalType;
(function (ModalType) {
    ModalType["ERROR"] = "error";
    ModalType["WARNING"] = "warning";
    ModalType["INFO"] = "info";
    ModalType["TEXT_EDIT"] = "textEdit";
})(ModalType || (ModalType = {}));

var _a;
var adjustmentsInitialState = (_a = {},
    _a[AdjustmentIdentifier.BRIGHTNESS] = 0,
    _a[AdjustmentIdentifier.SATURATION] = 0,
    _a[AdjustmentIdentifier.CONTRAST] = 0,
    _a[AdjustmentIdentifier.GAMMA] = 0,
    _a[AdjustmentIdentifier.CLARITY] = 0,
    _a[AdjustmentIdentifier.EXPOSURE] = 0,
    _a[AdjustmentIdentifier.SHADOWS] = 0,
    _a[AdjustmentIdentifier.HIGHLIGHTS] = 0,
    _a[AdjustmentIdentifier.WHITES] = 0,
    _a[AdjustmentIdentifier.BLACKS] = 0,
    _a[AdjustmentIdentifier.TEMPERATURE] = 0,
    _a[AdjustmentIdentifier.SHARPNESS] = 0,
    _a);

/** MobX - (c) Michel Weststrate 2015 - 2020 - MIT Licensed */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$1 = function(d, b) {
    extendStatics$1 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics$1(d, b);
};

function __extends$1(d, b) {
    extendStatics$1(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

function __read$1(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread$1() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read$1(arguments[i]));
    return ar;
}

var OBFUSCATED_ERROR = "An invariant failed, however the error is obfuscated because this is an production build.";
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var mockGlobal = {};
function getGlobal() {
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    return mockGlobal;
}
function getNextId() {
    return ++globalState.mobxGuid;
}
function fail(message) {
    invariant(false, message);
    throw "X"; // unreachable
}
function invariant(check, message) {
    if (!check)
        throw new Error("[mobx] " + (message || OBFUSCATED_ERROR));
}
/**
 * Prints a deprecation message, but only one time.
 * Returns false if the deprecated message was already printed before
 */
var deprecatedMessages = [];
function deprecated(msg, thing) {
    if (process.env.NODE_ENV === "production")
        return false;
    if (thing) {
        return deprecated("'" + msg + "', use '" + thing + "' instead.");
    }
    if (deprecatedMessages.indexOf(msg) !== -1)
        return false;
    deprecatedMessages.push(msg);
    console.error("[mobx] Deprecated: " + msg);
    return true;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */
function once(func) {
    var invoked = false;
    return function () {
        if (invoked)
            return;
        invoked = true;
        return func.apply(this, arguments);
    };
}
var noop = function () { };
function unique(list) {
    var res = [];
    list.forEach(function (item) {
        if (res.indexOf(item) === -1)
            res.push(item);
    });
    return res;
}
function isObject(value) {
    return value !== null && typeof value === "object";
}
function isPlainObject(value) {
    if (value === null || typeof value !== "object")
        return false;
    var proto = Object.getPrototypeOf(value);
    return proto === Object.prototype || proto === null;
}
function convertToMap(dataStructure) {
    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
        return dataStructure;
    }
    else if (Array.isArray(dataStructure)) {
        return new Map(dataStructure);
    }
    else if (isPlainObject(dataStructure)) {
        return new Map(Object.entries(dataStructure));
    }
    else {
        return fail("Cannot convert to map from '" + dataStructure + "'");
    }
}
function makeNonEnumerable(object, propNames) {
    for (var i = 0; i < propNames.length; i++) {
        addHiddenProp(object, propNames[i], object[propNames[i]]);
    }
}
function addHiddenProp(object, propName, value) {
    Object.defineProperty(object, propName, {
        enumerable: false,
        writable: true,
        configurable: true,
        value: value
    });
}
function addHiddenFinalProp(object, propName, value) {
    Object.defineProperty(object, propName, {
        enumerable: false,
        writable: false,
        configurable: true,
        value: value
    });
}
function isPropertyConfigurable(object, prop) {
    var descriptor = Object.getOwnPropertyDescriptor(object, prop);
    return !descriptor || (descriptor.configurable !== false && descriptor.writable !== false);
}
function assertPropertyConfigurable(object, prop) {
    if (process.env.NODE_ENV !== "production" && !isPropertyConfigurable(object, prop))
        fail("Cannot make property '" + prop + "' observable, it is not configurable and writable in the target object");
}
function createInstanceofPredicate(name, clazz) {
    var propName = "isMobX" + name;
    clazz.prototype[propName] = true;
    return function (x) {
        return isObject(x) && x[propName] === true;
    };
}
function areBothNaN(a, b) {
    return typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
function isES6Map(thing) {
    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map)
        return true;
    return false;
}
function isES6Set(thing) {
    return thing instanceof Set;
}
// use Array.from in Mobx 5
function iteratorToArray(it) {
    var res = [];
    while (true) {
        var r = it.next();
        if (r.done)
            break;
        res.push(r.value);
    }
    return res;
}
function primitiveSymbol() {
    // es-disable-next-line
    return (typeof Symbol === "function" && Symbol.toPrimitive) || "@@toPrimitive";
}
function toPrimitive(value) {
    return value === null ? null : typeof value === "object" ? "" + value : value;
}

function iteratorSymbol() {
    return (typeof Symbol === "function" && Symbol.iterator) || "@@iterator";
}
function declareIterator(prototType, iteratorFactory) {
    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);
}
function makeIterable(iterator) {
    iterator[iteratorSymbol()] = getSelf;
    return iterator;
}
function toStringTagSymbol() {
    return (typeof Symbol === "function" && Symbol.toStringTag) || "@@toStringTag";
}
function getSelf() {
    return this;
}

/**
 * Anything that can be used to _store_ state is an Atom in mobx. Atoms have two important jobs
 *
 * 1) detect when they are being _used_ and report this (using reportObserved). This allows mobx to make the connection between running functions and the data they used
 * 2) they should notify mobx whenever they have _changed_. This way mobx can re-run any functions (derivations) that are using this atom.
 */
var Atom = /** @class */ (function () {
    /**
     * Create a new atom. For debugging purposes it is recommended to give it a name.
     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
     */
    function Atom(name) {
        if (name === void 0) { name = "Atom@" + getNextId(); }
        this.name = name;
        this.isPendingUnobservation = false; // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed
        this.isBeingObserved = false;
        this.observers = [];
        this.observersIndexes = {};
        this.diffValue = 0;
        this.lastAccessedBy = 0;
        this.lowestObserverState = IDerivationState.NOT_TRACKING;
    }
    Atom.prototype.onBecomeUnobserved = function () {
        // noop
    };
    Atom.prototype.onBecomeObserved = function () {
        /* noop */
    };
    /**
     * Invoke this method to notify mobx that your atom has been used somehow.
     * Returns true if there is currently a reactive context.
     */
    Atom.prototype.reportObserved = function () {
        return reportObserved(this);
    };
    /**
     * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
     */
    Atom.prototype.reportChanged = function () {
        startBatch();
        propagateChanged(this);
        endBatch();
    };
    Atom.prototype.toString = function () {
        return this.name;
    };
    return Atom;
}());
var isAtom = createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; }
    if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; }
    var atom = new Atom(name);
    onBecomeObserved(atom, onBecomeObservedHandler);
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
    return atom;
}

function identityComparer(a, b) {
    return a === b;
}
function structuralComparer(a, b) {
    return deepEqual(a, b);
}
function shallowComparer(a, b) {
    return deepEqual(a, b, 1);
}
function defaultComparer(a, b) {
    return areBothNaN(a, b) || identityComparer(a, b);
}
var comparer = {
    identity: identityComparer,
    structural: structuralComparer,
    default: defaultComparer,
    shallow: shallowComparer
};

var enumerableDescriptorCache = {};
var nonEnumerableDescriptorCache = {};
function createPropertyInitializerDescriptor(prop, enumerable) {
    var cache = enumerable ? enumerableDescriptorCache : nonEnumerableDescriptorCache;
    return (cache[prop] ||
        (cache[prop] = {
            configurable: true,
            enumerable: enumerable,
            get: function () {
                initializeInstance(this);
                return this[prop];
            },
            set: function (value) {
                initializeInstance(this);
                this[prop] = value;
            }
        }));
}
function initializeInstance(target) {
    if (target.__mobxDidRunLazyInitializers === true)
        return;
    var decorators = target.__mobxDecorators;
    if (decorators) {
        addHiddenProp(target, "__mobxDidRunLazyInitializers", true);
        for (var key in decorators) {
            var d = decorators[key];
            d.propertyCreator(target, d.prop, d.descriptor, d.decoratorTarget, d.decoratorArguments);
        }
    }
}
function createPropDecorator(propertyInitiallyEnumerable, propertyCreator) {
    return function decoratorFactory() {
        var decoratorArguments;
        var decorator = function decorate(target, prop, descriptor, applyImmediately
        // This is a special parameter to signal the direct application of a decorator, allow extendObservable to skip the entire type decoration part,
        // as the instance to apply the decorator to equals the target
        ) {
            if (applyImmediately === true) {
                propertyCreator(target, prop, descriptor, target, decoratorArguments);
                return null;
            }
            if (process.env.NODE_ENV !== "production" && !quacksLikeADecorator(arguments))
                fail("This function is a decorator, but it wasn't invoked like a decorator");
            if (!Object.prototype.hasOwnProperty.call(target, "__mobxDecorators")) {
                var inheritedDecorators = target.__mobxDecorators;
                addHiddenProp(target, "__mobxDecorators", __assign$1({}, inheritedDecorators));
            }
            target.__mobxDecorators[prop] = {
                prop: prop,
                propertyCreator: propertyCreator,
                descriptor: descriptor,
                decoratorTarget: target,
                decoratorArguments: decoratorArguments
            };
            return createPropertyInitializerDescriptor(prop, propertyInitiallyEnumerable);
        };
        if (quacksLikeADecorator(arguments)) {
            // @decorator
            decoratorArguments = EMPTY_ARRAY;
            return decorator.apply(null, arguments);
        }
        else {
            // @decorator(args)
            decoratorArguments = Array.prototype.slice.call(arguments);
            return decorator;
        }
    };
}
function quacksLikeADecorator(args) {
    return (((args.length === 2 || args.length === 3) && typeof args[1] === "string") ||
        (args.length === 4 && args[3] === true));
}

function deepEnhancer(v, _, name) {
    // it is an observable already, done
    if (isObservable(v))
        return v;
    // something that can be converted and mutated?
    if (Array.isArray(v))
        return observable.array(v, { name: name });
    if (isPlainObject(v))
        return observable.object(v, undefined, { name: name });
    if (isES6Map(v))
        return observable.map(v, { name: name });
    if (isES6Set(v))
        return observable.set(v, { name: name });
    return v;
}
function shallowEnhancer(v, _, name) {
    if (v === undefined || v === null)
        return v;
    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v))
        return v;
    if (Array.isArray(v))
        return observable.array(v, { name: name, deep: false });
    if (isPlainObject(v))
        return observable.object(v, undefined, { name: name, deep: false });
    if (isES6Map(v))
        return observable.map(v, { name: name, deep: false });
    if (isES6Set(v))
        return observable.set(v, { name: name, deep: false });
    return fail(process.env.NODE_ENV !== "production" &&
        "The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(newValue) {
    // never turn into an observable
    return newValue;
}
function refStructEnhancer(v, oldValue, name) {
    if (process.env.NODE_ENV !== "production" && isObservable(v))
        throw "observable.struct should not be used with observable values";
    if (deepEqual(v, oldValue))
        return oldValue;
    return v;
}

function createDecoratorForEnhancer(enhancer) {
    invariant(enhancer);
    var decorator = createPropDecorator(true, function (target, propertyName, descriptor, _decoratorTarget, decoratorArgs) {
        if (process.env.NODE_ENV !== "production") {
            invariant(!descriptor || !descriptor.get, "@observable cannot be used on getter (property \"" + propertyName + "\"), use @computed instead.");
        }
        var initialValue = descriptor
            ? descriptor.initializer
                ? descriptor.initializer.call(target)
                : descriptor.value
            : undefined;
        defineObservableProperty(target, propertyName, initialValue, enhancer);
    });
    var res = 
    // Extra process checks, as this happens during module initialization
    typeof process !== "undefined" && process.env && process.env.NODE_ENV !== "production"
        ? function observableDecorator() {
            // This wrapper function is just to detect illegal decorator invocations, deprecate in a next version
            // and simply return the created prop decorator
            if (arguments.length < 2)
                return fail("Incorrect decorator invocation. @observable decorator doesn't expect any arguments");
            return decorator.apply(null, arguments);
        }
        : decorator;
    res.enhancer = enhancer;
    return res;
}

// Predefined bags of create observable options, to avoid allocating temporarily option objects
// in the majority of cases
var defaultCreateObservableOptions = {
    deep: true,
    name: undefined,
    defaultDecorator: undefined
};
var shallowCreateObservableOptions = {
    deep: false,
    name: undefined,
    defaultDecorator: undefined
};
Object.freeze(defaultCreateObservableOptions);
Object.freeze(shallowCreateObservableOptions);
function assertValidOption(key) {
    if (!/^(deep|name|equals|defaultDecorator)$/.test(key))
        fail("invalid option for (extend)observable: " + key);
}
function asCreateObservableOptions(thing) {
    if (thing === null || thing === undefined)
        return defaultCreateObservableOptions;
    if (typeof thing === "string")
        return { name: thing, deep: true };
    if (process.env.NODE_ENV !== "production") {
        if (typeof thing !== "object")
            return fail("expected options object");
        Object.keys(thing).forEach(assertValidOption);
    }
    return thing;
}
function getEnhancerFromOptions(options) {
    return options.defaultDecorator
        ? options.defaultDecorator.enhancer
        : options.deep === false
            ? referenceEnhancer
            : deepEnhancer;
}
var deepDecorator = createDecoratorForEnhancer(deepEnhancer);
var shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);
var refDecorator = createDecoratorForEnhancer(referenceEnhancer);
var refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */
function createObservable(v, arg2, arg3) {
    // @observable someProp;
    if (typeof arguments[1] === "string") {
        return deepDecorator.apply(null, arguments);
    }
    // it is an observable already, done
    if (isObservable(v))
        return v;
    // something that can be converted and mutated?
    var res = isPlainObject(v)
        ? observable.object(v, arg2, arg3)
        : Array.isArray(v)
            ? observable.array(v, arg2)
            : isES6Map(v)
                ? observable.map(v, arg2)
                : isES6Set(v)
                    ? observable.set(v, arg2)
                    : v;
    // this value could be converted to a new observable data structure, return it
    if (res !== v)
        return res;
    // otherwise, just box it
    fail(process.env.NODE_ENV !== "production" &&
        "The provided value could not be converted into an observable. If you want just create an observable reference to the object use 'observable.box(value)'");
}
var observableFactories = {
    box: function (value, options) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("box");
        var o = asCreateObservableOptions(options);
        return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
    },
    shallowBox: function (value, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("shallowBox");
        deprecated("observable.shallowBox", "observable.box(value, { deep: false })");
        return observable.box(value, { name: name, deep: false });
    },
    array: function (initialValues, options) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("array");
        var o = asCreateObservableOptions(options);
        return new ObservableArray(initialValues, getEnhancerFromOptions(o), o.name);
    },
    shallowArray: function (initialValues, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("shallowArray");
        deprecated("observable.shallowArray", "observable.array(values, { deep: false })");
        return observable.array(initialValues, { name: name, deep: false });
    },
    map: function (initialValues, options) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("map");
        var o = asCreateObservableOptions(options);
        return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
    },
    shallowMap: function (initialValues, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("shallowMap");
        deprecated("observable.shallowMap", "observable.map(values, { deep: false })");
        return observable.map(initialValues, { name: name, deep: false });
    },
    set: function (initialValues, options) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("set");
        var o = asCreateObservableOptions(options);
        return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
    },
    object: function (props, decorators, options) {
        if (typeof arguments[1] === "string")
            incorrectlyUsedAsDecorator("object");
        var o = asCreateObservableOptions(options);
        return extendObservable({}, props, decorators, o);
    },
    shallowObject: function (props, name) {
        if (typeof arguments[1] === "string")
            incorrectlyUsedAsDecorator("shallowObject");
        deprecated("observable.shallowObject", "observable.object(values, {}, { deep: false })");
        return observable.object(props, {}, { name: name, deep: false });
    },
    ref: refDecorator,
    shallow: shallowDecorator,
    deep: deepDecorator,
    struct: refStructDecorator
};
var observable = createObservable;
// weird trick to keep our typings nicely with our funcs, and still extend the observable function
Object.keys(observableFactories).forEach(function (name) { return (observable[name] = observableFactories[name]); });
function incorrectlyUsedAsDecorator(methodName) {
    fail(
    // process.env.NODE_ENV !== "production" &&
    "Expected one or two arguments to observable." + methodName + ". Did you accidentally try to use observable." + methodName + " as decorator?");
}

var computedDecorator = createPropDecorator(false, function (instance, propertyName, descriptor, decoratorTarget, decoratorArgs) {
    var get = descriptor.get, set = descriptor.set; // initialValue is the descriptor for get / set props
    // Optimization: faster on decorator target or instance? Assuming target
    // Optimization: find out if declaring on instance isn't just faster. (also makes the property descriptor simpler). But, more memory usage..
    // Forcing instance now, fixes hot reloadig issues on React Native:
    var options = decoratorArgs[0] || {};
    defineComputedProperty(instance, propertyName, __assign$1({ get: get, set: set }, options));
});
var computedStructDecorator = computedDecorator({ equals: comparer.structural });
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */
var computed = function computed(arg1, arg2, arg3) {
    if (typeof arg2 === "string") {
        // @computed
        return computedDecorator.apply(null, arguments);
    }
    if (arg1 !== null && typeof arg1 === "object" && arguments.length === 1) {
        // @computed({ options })
        return computedDecorator.apply(null, arguments);
    }
    // computed(expr, options?)
    if (process.env.NODE_ENV !== "production") {
        invariant(typeof arg1 === "function", "First argument to `computed` should be an expression.");
        invariant(arguments.length < 3, "Computed takes one or two arguments if used as function");
    }
    var opts = typeof arg2 === "object" ? arg2 : {};
    opts.get = arg1;
    opts.set = typeof arg2 === "function" ? arg2 : opts.set;
    opts.name = opts.name || arg1.name || ""; /* for generated name */
    return new ComputedValue(opts);
};
computed.struct = computedStructDecorator;

var IDerivationState;
(function (IDerivationState) {
    // before being run or (outside batch and not being observed)
    // at this point derivation is not holding any data about dependency tree
    IDerivationState[IDerivationState["NOT_TRACKING"] = -1] = "NOT_TRACKING";
    // no shallow dependency changed since last computation
    // won't recalculate derivation
    // this is what makes mobx fast
    IDerivationState[IDerivationState["UP_TO_DATE"] = 0] = "UP_TO_DATE";
    // some deep dependency changed, but don't know if shallow dependency changed
    // will require to check first if UP_TO_DATE or POSSIBLY_STALE
    // currently only ComputedValue will propagate POSSIBLY_STALE
    //
    // having this state is second big optimization:
    // don't have to recompute on every dependency change, but only when it's needed
    IDerivationState[IDerivationState["POSSIBLY_STALE"] = 1] = "POSSIBLY_STALE";
    // A shallow dependency has changed since last computation and the derivation
    // will need to recompute when it's needed next.
    IDerivationState[IDerivationState["STALE"] = 2] = "STALE";
})(IDerivationState || (IDerivationState = {}));
var TraceMode;
(function (TraceMode) {
    TraceMode[TraceMode["NONE"] = 0] = "NONE";
    TraceMode[TraceMode["LOG"] = 1] = "LOG";
    TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = /** @class */ (function () {
    function CaughtException(cause) {
        this.cause = cause;
        // Empty
    }
    return CaughtException;
}());
function isCaughtException(e) {
    return e instanceof CaughtException;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */
function shouldCompute(derivation) {
    switch (derivation.dependenciesState) {
        case IDerivationState.UP_TO_DATE:
            return false;
        case IDerivationState.NOT_TRACKING:
        case IDerivationState.STALE:
            return true;
        case IDerivationState.POSSIBLY_STALE: {
            // state propagation can occur outside of action/reactive context #2195
            var prevAllowStateReads = allowStateReadsStart(true);
            var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.
            var obs = derivation.observing, l = obs.length;
            for (var i = 0; i < l; i++) {
                var obj = obs[i];
                if (isComputedValue(obj)) {
                    if (globalState.disableErrorBoundaries) {
                        obj.get();
                    }
                    else {
                        try {
                            obj.get();
                        }
                        catch (e) {
                            // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                            untrackedEnd(prevUntracked);
                            allowStateReadsEnd(prevAllowStateReads);
                            return true;
                        }
                    }
                    // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
                    // and `derivation` is an observer of `obj`
                    // invariantShouldCompute(derivation)
                    if (derivation.dependenciesState === IDerivationState.STALE) {
                        untrackedEnd(prevUntracked);
                        allowStateReadsEnd(prevAllowStateReads);
                        return true;
                    }
                }
            }
            changeDependenciesStateTo0(derivation);
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return false;
        }
    }
}
function checkIfStateModificationsAreAllowed(atom) {
    var hasObservers = atom.observers.length > 0;
    // Should never be possible to change an observed observable from inside computed, see #798
    if (globalState.computationDepth > 0 && hasObservers)
        fail(process.env.NODE_ENV !== "production" &&
            "Computed values are not allowed to cause side effects by changing observables that are already being observed. Tried to modify: " + atom.name);
    // Should not be possible to change observed state outside strict mode, except during initialization, see #563
    if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "strict"))
        fail(process.env.NODE_ENV !== "production" &&
            (globalState.enforceActions
                ? "Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: "
                : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: ") +
                atom.name);
}
function checkIfStateReadsAreAllowed(observable) {
    if (process.env.NODE_ENV !== "production" &&
        !globalState.allowStateReads &&
        globalState.observableRequiresReaction) {
        console.warn("[mobx] Observable " + observable.name + " being read outside a reactive context");
    }
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */
function trackDerivedFunction(derivation, f, context) {
    var prevAllowStateReads = allowStateReadsStart(true);
    // pre allocate array allocation + room for variation in deps
    // array will be trimmed by bindDependencies
    changeDependenciesStateTo0(derivation);
    derivation.newObserving = new Array(derivation.observing.length + 100);
    derivation.unboundDepsCount = 0;
    derivation.runId = ++globalState.runId;
    var prevTracking = globalState.trackingDerivation;
    globalState.trackingDerivation = derivation;
    var result;
    if (globalState.disableErrorBoundaries === true) {
        result = f.call(context);
    }
    else {
        try {
            result = f.call(context);
        }
        catch (e) {
            result = new CaughtException(e);
        }
    }
    globalState.trackingDerivation = prevTracking;
    bindDependencies(derivation);
    if (derivation.observing.length === 0) {
        warnAboutDerivationWithoutDependencies(derivation);
    }
    allowStateReadsEnd(prevAllowStateReads);
    return result;
}
function warnAboutDerivationWithoutDependencies(derivation) {
    if (process.env.NODE_ENV === "production")
        return;
    if (globalState.reactionRequiresObservable || derivation.requiresObservable) {
        console.warn("[mobx] Derivation " + derivation.name + " is created/updated without reading any observable value");
    }
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */
function bindDependencies(derivation) {
    // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
    var prevObserving = derivation.observing;
    var observing = (derivation.observing = derivation.newObserving);
    var lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE;
    // Go through all new observables and check diffValue: (this list can contain duplicates):
    //   0: first occurrence, change to 1 and keep it
    //   1: extra occurrence, drop it
    var i0 = 0, l = derivation.unboundDepsCount;
    for (var i = 0; i < l; i++) {
        var dep = observing[i];
        if (dep.diffValue === 0) {
            dep.diffValue = 1;
            if (i0 !== i)
                observing[i0] = dep;
            i0++;
        }
        // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
        // not hitting the condition
        if (dep.dependenciesState > lowestNewObservingDerivationState) {
            lowestNewObservingDerivationState = dep.dependenciesState;
        }
    }
    observing.length = i0;
    derivation.newObserving = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
    // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
    //   0: it's not in new observables, unobserve it
    //   1: it keeps being observed, don't want to notify it. change to 0
    l = prevObserving.length;
    while (l--) {
        var dep = prevObserving[l];
        if (dep.diffValue === 0) {
            removeObserver(dep, derivation);
        }
        dep.diffValue = 0;
    }
    // Go through all new observables and check diffValue: (now it should be unique)
    //   0: it was set to 0 in last loop. don't need to do anything.
    //   1: it wasn't observed, let's observe it. set back to 0
    while (i0--) {
        var dep = observing[i0];
        if (dep.diffValue === 1) {
            dep.diffValue = 0;
            addObserver(dep, derivation);
        }
    }
    // Some new observed derivations may become stale during this derivation computation
    // so they have had no chance to propagate staleness (#916)
    if (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) {
        derivation.dependenciesState = lowestNewObservingDerivationState;
        derivation.onBecomeStale();
    }
}
function clearObserving(derivation) {
    // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
    var obs = derivation.observing;
    derivation.observing = [];
    var i = obs.length;
    while (i--)
        removeObserver(obs[i], derivation);
    derivation.dependenciesState = IDerivationState.NOT_TRACKING;
}
function untracked(action) {
    var prev = untrackedStart();
    var res = action();
    untrackedEnd(prev);
    return res;
}
function untrackedStart() {
    var prev = globalState.trackingDerivation;
    globalState.trackingDerivation = null;
    return prev;
}
function untrackedEnd(prev) {
    globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
    var prev = globalState.allowStateReads;
    globalState.allowStateReads = allowStateReads;
    return prev;
}
function allowStateReadsEnd(prev) {
    globalState.allowStateReads = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */
function changeDependenciesStateTo0(derivation) {
    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE)
        return;
    derivation.dependenciesState = IDerivationState.UP_TO_DATE;
    var obs = derivation.observing;
    var i = obs.length;
    while (i--)
        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;
}

// we don't use globalState for these in order to avoid possible issues with multiple
// mobx versions
var currentActionId = 0;
var nextActionId = 1;
var functionNameDescriptor = Object.getOwnPropertyDescriptor(function () { }, "name");
var isFunctionNameConfigurable = functionNameDescriptor && functionNameDescriptor.configurable;
function createAction(actionName, fn) {
    if (process.env.NODE_ENV !== "production") {
        invariant(typeof fn === "function", "`action` can only be invoked on functions");
        if (typeof actionName !== "string" || !actionName)
            fail("actions should have valid names, got: '" + actionName + "'");
    }
    var res = function () {
        return executeAction(actionName, fn, this, arguments);
    };
    if (process.env.NODE_ENV !== "production") {
        if (isFunctionNameConfigurable) {
            Object.defineProperty(res, "name", { value: actionName });
        }
    }
    res.isMobxAction = true;
    return res;
}
function executeAction(actionName, fn, scope, args) {
    var runInfo = _startAction(actionName, scope, args);
    try {
        return fn.apply(scope, args);
    }
    catch (err) {
        runInfo.error = err;
        throw err;
    }
    finally {
        _endAction(runInfo);
    }
}
function _startAction(actionName, scope, args) {
    var notifySpy = isSpyEnabled() && !!actionName;
    var startTime = 0;
    if (notifySpy) {
        startTime = Date.now();
        var l = (args && args.length) || 0;
        var flattendArgs = new Array(l);
        if (l > 0)
            for (var i = 0; i < l; i++)
                flattendArgs[i] = args[i];
        spyReportStart({
            type: "action",
            name: actionName,
            object: scope,
            arguments: flattendArgs
        });
    }
    var prevDerivation = untrackedStart();
    startBatch();
    var prevAllowStateChanges = allowStateChangesStart(true);
    var prevAllowStateReads = allowStateReadsStart(true);
    var runInfo = {
        prevDerivation: prevDerivation,
        prevAllowStateChanges: prevAllowStateChanges,
        prevAllowStateReads: prevAllowStateReads,
        notifySpy: notifySpy,
        startTime: startTime,
        actionId: nextActionId++,
        parentActionId: currentActionId
    };
    currentActionId = runInfo.actionId;
    return runInfo;
}
function _endAction(runInfo) {
    if (currentActionId !== runInfo.actionId) {
        fail("invalid action stack. did you forget to finish an action?");
    }
    currentActionId = runInfo.parentActionId;
    if (runInfo.error !== undefined) {
        globalState.suppressReactionErrors = true;
    }
    allowStateChangesEnd(runInfo.prevAllowStateChanges);
    allowStateReadsEnd(runInfo.prevAllowStateReads);
    endBatch();
    untrackedEnd(runInfo.prevDerivation);
    if (runInfo.notifySpy) {
        spyReportEnd({ time: Date.now() - runInfo.startTime });
    }
    globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges, func) {
    var prev = allowStateChangesStart(allowStateChanges);
    var res;
    try {
        res = func();
    }
    finally {
        allowStateChangesEnd(prev);
    }
    return res;
}
function allowStateChangesStart(allowStateChanges) {
    var prev = globalState.allowStateChanges;
    globalState.allowStateChanges = allowStateChanges;
    return prev;
}
function allowStateChangesEnd(prev) {
    globalState.allowStateChanges = prev;
}

var ObservableValue = /** @class */ (function (_super) {
    __extends$1(ObservableValue, _super);
    function ObservableValue(value, enhancer, name, notifySpy, equals) {
        if (name === void 0) { name = "ObservableValue@" + getNextId(); }
        if (notifySpy === void 0) { notifySpy = true; }
        if (equals === void 0) { equals = comparer.default; }
        var _this = _super.call(this, name) || this;
        _this.enhancer = enhancer;
        _this.name = name;
        _this.equals = equals;
        _this.hasUnreportedChange = false;
        _this.value = enhancer(value, undefined, name);
        if (notifySpy && isSpyEnabled()) {
            // only notify spy if this is a stand-alone observable
            spyReport({ type: "create", name: _this.name, newValue: "" + _this.value });
        }
        return _this;
    }
    ObservableValue.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined)
            return this.dehancer(value);
        return value;
    };
    ObservableValue.prototype.set = function (newValue) {
        var oldValue = this.value;
        newValue = this.prepareNewValue(newValue);
        if (newValue !== globalState.UNCHANGED) {
            var notifySpy = isSpyEnabled();
            if (notifySpy) {
                spyReportStart({
                    type: "update",
                    name: this.name,
                    newValue: newValue,
                    oldValue: oldValue
                });
            }
            this.setNewValue(newValue);
            if (notifySpy)
                spyReportEnd();
        }
    };
    ObservableValue.prototype.prepareNewValue = function (newValue) {
        checkIfStateModificationsAreAllowed(this);
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                object: this,
                type: "update",
                newValue: newValue
            });
            if (!change)
                return globalState.UNCHANGED;
            newValue = change.newValue;
        }
        // apply modifier
        newValue = this.enhancer(newValue, this.value, this.name);
        return this.equals(this.value, newValue) ? globalState.UNCHANGED : newValue;
    };
    ObservableValue.prototype.setNewValue = function (newValue) {
        var oldValue = this.value;
        this.value = newValue;
        this.reportChanged();
        if (hasListeners(this)) {
            notifyListeners(this, {
                type: "update",
                object: this,
                newValue: newValue,
                oldValue: oldValue
            });
        }
    };
    ObservableValue.prototype.get = function () {
        this.reportObserved();
        return this.dehanceValue(this.value);
    };
    ObservableValue.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    ObservableValue.prototype.observe = function (listener, fireImmediately) {
        if (fireImmediately)
            listener({
                object: this,
                type: "update",
                newValue: this.value,
                oldValue: undefined
            });
        return registerListener(this, listener);
    };
    ObservableValue.prototype.toJSON = function () {
        return this.get();
    };
    ObservableValue.prototype.toString = function () {
        return this.name + "[" + this.value + "]";
    };
    ObservableValue.prototype.valueOf = function () {
        return toPrimitive(this.get());
    };
    return ObservableValue;
}(Atom));
ObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;
var isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue);

/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */
var ComputedValue = /** @class */ (function () {
    /**
     * Create a new computed value based on a function expression.
     *
     * The `name` property is for debug purposes only.
     *
     * The `equals` property specifies the comparer function to use to determine if a newly produced
     * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
     * compares based on identity comparison (===), and `structualComparer` deeply compares the structure.
     * Structural comparison can be convenient if you always produce a new aggregated object and
     * don't want to notify observers if it is structurally the same.
     * This is useful for working with vectors, mouse coordinates etc.
     */
    function ComputedValue(options) {
        this.dependenciesState = IDerivationState.NOT_TRACKING;
        this.observing = []; // nodes we are looking at. Our value depends on these nodes
        this.newObserving = null; // during tracking it's an array with new observed observers
        this.isBeingObserved = false;
        this.isPendingUnobservation = false;
        this.observers = [];
        this.observersIndexes = {};
        this.diffValue = 0;
        this.runId = 0;
        this.lastAccessedBy = 0;
        this.lowestObserverState = IDerivationState.UP_TO_DATE;
        this.unboundDepsCount = 0;
        this.__mapid = "#" + getNextId();
        this.value = new CaughtException(null);
        this.isComputing = false; // to check for cycles
        this.isRunningSetter = false;
        this.isTracing = TraceMode.NONE;
        invariant(options.get, "missing option for computed: get");
        this.derivation = options.get;
        this.name = options.name || "ComputedValue@" + getNextId();
        if (options.set)
            this.setter = createAction(this.name + "-setter", options.set);
        this.equals =
            options.equals ||
                (options.compareStructural || options.struct
                    ? comparer.structural
                    : comparer.default);
        this.scope = options.context;
        this.requiresReaction = !!options.requiresReaction;
        this.keepAlive = !!options.keepAlive;
    }
    ComputedValue.prototype.onBecomeStale = function () {
        propagateMaybeChanged(this);
    };
    ComputedValue.prototype.onBecomeUnobserved = function () { };
    ComputedValue.prototype.onBecomeObserved = function () { };
    /**
     * Returns the current value of this computed value.
     * Will evaluate its computation first if needed.
     */
    ComputedValue.prototype.get = function () {
        if (this.isComputing)
            fail("Cycle detected in computation " + this.name + ": " + this.derivation);
        if (globalState.inBatch === 0 && this.observers.length === 0 && !this.keepAlive) {
            if (shouldCompute(this)) {
                this.warnAboutUntrackedRead();
                startBatch(); // See perf test 'computed memoization'
                this.value = this.computeValue(false);
                endBatch();
            }
        }
        else {
            reportObserved(this);
            if (shouldCompute(this))
                if (this.trackAndCompute())
                    propagateChangeConfirmed(this);
        }
        var result = this.value;
        if (isCaughtException(result))
            throw result.cause;
        return result;
    };
    ComputedValue.prototype.peek = function () {
        var res = this.computeValue(false);
        if (isCaughtException(res))
            throw res.cause;
        return res;
    };
    ComputedValue.prototype.set = function (value) {
        if (this.setter) {
            invariant(!this.isRunningSetter, "The setter of computed value '" + this.name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?");
            this.isRunningSetter = true;
            try {
                this.setter.call(this.scope, value);
            }
            finally {
                this.isRunningSetter = false;
            }
        }
        else
            invariant(false, process.env.NODE_ENV !== "production" &&
                "[ComputedValue '" + this.name + "'] It is not possible to assign a new value to a computed value.");
    };
    ComputedValue.prototype.trackAndCompute = function () {
        if (isSpyEnabled()) {
            spyReport({
                object: this.scope,
                type: "compute",
                name: this.name
            });
        }
        var oldValue = this.value;
        var wasSuspended = 
        /* see #1208 */ this.dependenciesState === IDerivationState.NOT_TRACKING;
        var newValue = this.computeValue(true);
        var changed = wasSuspended ||
            isCaughtException(oldValue) ||
            isCaughtException(newValue) ||
            !this.equals(oldValue, newValue);
        if (changed) {
            this.value = newValue;
        }
        return changed;
    };
    ComputedValue.prototype.computeValue = function (track) {
        this.isComputing = true;
        globalState.computationDepth++;
        var res;
        if (track) {
            res = trackDerivedFunction(this, this.derivation, this.scope);
        }
        else {
            if (globalState.disableErrorBoundaries === true) {
                res = this.derivation.call(this.scope);
            }
            else {
                try {
                    res = this.derivation.call(this.scope);
                }
                catch (e) {
                    res = new CaughtException(e);
                }
            }
        }
        globalState.computationDepth--;
        this.isComputing = false;
        return res;
    };
    ComputedValue.prototype.suspend = function () {
        if (!this.keepAlive) {
            clearObserving(this);
            this.value = undefined; // don't hold on to computed value!
        }
    };
    ComputedValue.prototype.observe = function (listener, fireImmediately) {
        var _this = this;
        var firstTime = true;
        var prevValue = undefined;
        return autorun(function () {
            var newValue = _this.get();
            if (!firstTime || fireImmediately) {
                var prevU = untrackedStart();
                listener({
                    type: "update",
                    object: _this,
                    newValue: newValue,
                    oldValue: prevValue
                });
                untrackedEnd(prevU);
            }
            firstTime = false;
            prevValue = newValue;
        });
    };
    ComputedValue.prototype.warnAboutUntrackedRead = function () {
        if (process.env.NODE_ENV === "production")
            return;
        if (this.requiresReaction === true) {
            fail("[mobx] Computed value " + this.name + " is read outside a reactive context");
        }
        if (this.isTracing !== TraceMode.NONE) {
            console.log("[mobx.trace] '" + this.name + "' is being read outside a reactive context. Doing a full recompute");
        }
        if (globalState.computedRequiresReaction) {
            console.warn("[mobx] Computed value " + this.name + " is being read outside a reactive context. Doing a full recompute");
        }
    };
    ComputedValue.prototype.toJSON = function () {
        return this.get();
    };
    ComputedValue.prototype.toString = function () {
        return this.name + "[" + this.derivation.toString() + "]";
    };
    ComputedValue.prototype.valueOf = function () {
        return toPrimitive(this.get());
    };
    return ComputedValue;
}());
ComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;
var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);
var MobXGlobals = /** @class */ (function () {
    function MobXGlobals() {
        /**
         * MobXGlobals version.
         * MobX compatiblity with other versions loaded in memory as long as this version matches.
         * It indicates that the global state still stores similar information
         *
         * N.B: this version is unrelated to the package version of MobX, and is only the version of the
         * internal state storage of MobX, and can be the same across many different package versions
         */
        this.version = 5;
        /**
         * globally unique token to signal unchanged
         */
        this.UNCHANGED = {};
        /**
         * Currently running derivation
         */
        this.trackingDerivation = null;
        /**
         * Are we running a computation currently? (not a reaction)
         */
        this.computationDepth = 0;
        /**
         * Each time a derivation is tracked, it is assigned a unique run-id
         */
        this.runId = 0;
        /**
         * 'guid' for general purpose. Will be persisted amongst resets.
         */
        this.mobxGuid = 0;
        /**
         * Are we in a batch block? (and how many of them)
         */
        this.inBatch = 0;
        /**
         * Observables that don't have observers anymore, and are about to be
         * suspended, unless somebody else accesses it in the same batch
         *
         * @type {IObservable[]}
         */
        this.pendingUnobservations = [];
        /**
         * List of scheduled, not yet executed, reactions.
         */
        this.pendingReactions = [];
        /**
         * Are we currently processing reactions?
         */
        this.isRunningReactions = false;
        /**
         * Is it allowed to change observables at this point?
         * In general, MobX doesn't allow that when running computations and React.render.
         * To ensure that those functions stay pure.
         */
        this.allowStateChanges = true;
        /**
         * Is it allowed to read observables at this point?
         * Used to hold the state needed for `observableRequiresReaction`
         */
        this.allowStateReads = true;
        /**
         * If strict mode is enabled, state changes are by default not allowed
         */
        this.enforceActions = false;
        /**
         * Spy callbacks
         */
        this.spyListeners = [];
        /**
         * Globally attached error handlers that react specifically to errors in reactions
         */
        this.globalReactionErrorHandlers = [];
        /**
         * Warn if computed values are accessed outside a reactive context
         */
        this.computedRequiresReaction = false;
        /**
         * (Experimental)
         * Warn if you try to create to derivation / reactive context without accessing any observable.
         */
        this.reactionRequiresObservable = false;
        /**
         * (Experimental)
         * Warn if observables are accessed outside a reactive context
         */
        this.observableRequiresReaction = false;
        /**
         * Allows overwriting of computed properties, useful in tests but not prod as it can cause
         * memory leaks. See https://github.com/mobxjs/mobx/issues/1867
         */
        this.computedConfigurable = false;
        /*
         * Don't catch and rethrow exceptions. This is useful for inspecting the state of
         * the stack when an exception occurs while debugging.
         */
        this.disableErrorBoundaries = false;
        /*
         * If true, we are already handling an exception in an action. Any errors in reactions should be supressed, as
         * they are not the cause, see: https://github.com/mobxjs/mobx/issues/1836
         */
        this.suppressReactionErrors = false;
    }
    return MobXGlobals;
}());
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = (function () {
    var global = getGlobal();
    if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals)
        canMergeGlobalState = false;
    if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version)
        canMergeGlobalState = false;
    if (!canMergeGlobalState) {
        setTimeout(function () {
            if (!isolateCalled) {
                fail("There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`");
            }
        }, 1);
        return new MobXGlobals();
    }
    else if (global.__mobxGlobals) {
        global.__mobxInstanceCount += 1;
        if (!global.__mobxGlobals.UNCHANGED)
            global.__mobxGlobals.UNCHANGED = {}; // make merge backward compatible
        return global.__mobxGlobals;
    }
    else {
        global.__mobxInstanceCount = 1;
        return (global.__mobxGlobals = new MobXGlobals());
    }
})();
function isolateGlobalState() {
    if (globalState.pendingReactions.length ||
        globalState.inBatch ||
        globalState.isRunningReactions)
        fail("isolateGlobalState should be called before MobX is running any reactions");
    isolateCalled = true;
    if (canMergeGlobalState) {
        if (--getGlobal().__mobxInstanceCount === 0)
            getGlobal().__mobxGlobals = undefined;
        globalState = new MobXGlobals();
    }
}
// function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }
function addObserver(observable, node) {
    // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
    // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
    // invariantObservers(observable);
    var l = observable.observers.length;
    if (l) {
        // because object assignment is relatively expensive, let's not store data about index 0.
        observable.observersIndexes[node.__mapid] = l;
    }
    observable.observers[l] = node;
    if (observable.lowestObserverState > node.dependenciesState)
        observable.lowestObserverState = node.dependenciesState;
    // invariantObservers(observable);
    // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}
function removeObserver(observable, node) {
    // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
    // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
    // invariantObservers(observable);
    if (observable.observers.length === 1) {
        // deleting last observer
        observable.observers.length = 0;
        queueForUnobservation(observable);
    }
    else {
        // deleting from _observersIndexes is straight forward, to delete from _observers, let's swap `node` with last element
        var list = observable.observers;
        var map = observable.observersIndexes;
        var filler = list.pop(); // get last element, which should fill the place of `node`, so the array doesn't have holes
        if (filler !== node) {
            // otherwise node was the last element, which already got removed from array
            var index = map[node.__mapid] || 0; // getting index of `node`. this is the only place we actually use map.
            if (index) {
                // map store all indexes but 0, see comment in `addObserver`
                map[filler.__mapid] = index;
            }
            else {
                delete map[filler.__mapid];
            }
            list[index] = filler;
        }
        delete map[node.__mapid];
    }
    // invariantObservers(observable);
    // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");
}
function queueForUnobservation(observable) {
    if (observable.isPendingUnobservation === false) {
        // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
        observable.isPendingUnobservation = true;
        globalState.pendingUnobservations.push(observable);
    }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */
function startBatch() {
    globalState.inBatch++;
}
function endBatch() {
    if (--globalState.inBatch === 0) {
        runReactions();
        // the batch is actually about to finish, all unobserving should happen here.
        var list = globalState.pendingUnobservations;
        for (var i = 0; i < list.length; i++) {
            var observable = list[i];
            observable.isPendingUnobservation = false;
            if (observable.observers.length === 0) {
                if (observable.isBeingObserved) {
                    // if this observable had reactive observers, trigger the hooks
                    observable.isBeingObserved = false;
                    observable.onBecomeUnobserved();
                }
                if (observable instanceof ComputedValue) {
                    // computed values are automatically teared down when the last observer leaves
                    // this process happens recursively, this computed might be the last observabe of another, etc..
                    observable.suspend();
                }
            }
        }
        globalState.pendingUnobservations = [];
    }
}
function reportObserved(observable) {
    checkIfStateReadsAreAllowed(observable);
    var derivation = globalState.trackingDerivation;
    if (derivation !== null) {
        /**
         * Simple optimization, give each derivation run an unique id (runId)
         * Check if last time this observable was accessed the same runId is used
         * if this is the case, the relation is already known
         */
        if (derivation.runId !== observable.lastAccessedBy) {
            observable.lastAccessedBy = derivation.runId;
            derivation.newObserving[derivation.unboundDepsCount++] = observable;
            if (!observable.isBeingObserved) {
                observable.isBeingObserved = true;
                observable.onBecomeObserved();
            }
        }
        return true;
    }
    else if (observable.observers.length === 0 && globalState.inBatch > 0) {
        queueForUnobservation(observable);
    }
    return false;
}
// function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }
/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */
// Called by Atom when its value changes
function propagateChanged(observable) {
    // invariantLOS(observable, "changed start");
    if (observable.lowestObserverState === IDerivationState.STALE)
        return;
    observable.lowestObserverState = IDerivationState.STALE;
    var observers = observable.observers;
    var i = observers.length;
    while (i--) {
        var d = observers[i];
        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {
            if (d.isTracing !== TraceMode.NONE) {
                logTraceInfo(d, observable);
            }
            d.onBecomeStale();
        }
        d.dependenciesState = IDerivationState.STALE;
    }
    // invariantLOS(observable, "changed end");
}
// Called by ComputedValue when it recalculate and its value changed
function propagateChangeConfirmed(observable) {
    // invariantLOS(observable, "confirmed start");
    if (observable.lowestObserverState === IDerivationState.STALE)
        return;
    observable.lowestObserverState = IDerivationState.STALE;
    var observers = observable.observers;
    var i = observers.length;
    while (i--) {
        var d = observers[i];
        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE)
            d.dependenciesState = IDerivationState.STALE;
        else if (d.dependenciesState === IDerivationState.UP_TO_DATE // this happens during computing of `d`, just keep lowestObserverState up to date.
        )
            observable.lowestObserverState = IDerivationState.UP_TO_DATE;
    }
    // invariantLOS(observable, "confirmed end");
}
// Used by computed when its dependency changed, but we don't wan't to immediately recompute.
function propagateMaybeChanged(observable) {
    // invariantLOS(observable, "maybe start");
    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE)
        return;
    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;
    var observers = observable.observers;
    var i = observers.length;
    while (i--) {
        var d = observers[i];
        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {
            d.dependenciesState = IDerivationState.POSSIBLY_STALE;
            if (d.isTracing !== TraceMode.NONE) {
                logTraceInfo(d, observable);
            }
            d.onBecomeStale();
        }
    }
    // invariantLOS(observable, "maybe end");
}
function logTraceInfo(derivation, observable) {
    console.log("[mobx.trace] '" + derivation.name + "' is invalidated due to a change in: '" + observable.name + "'");
    if (derivation.isTracing === TraceMode.BREAK) {
        var lines = [];
        printDepTree(getDependencyTree(derivation), lines, 1);
        // prettier-ignore
        new Function("debugger;\n/*\nTracing '" + derivation.name + "'\n\nYou are entering this break point because derivation '" + derivation.name + "' is being traced and '" + observable.name + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
    }
}
function printDepTree(tree, lines, depth) {
    if (lines.length >= 1000) {
        lines.push("(and many more)");
        return;
    }
    lines.push("" + new Array(depth).join("\t") + tree.name); // MWE: not the fastest, but the easiest way :)
    if (tree.dependencies)
        tree.dependencies.forEach(function (child) { return printDepTree(child, lines, depth + 1); });
}

var Reaction = /** @class */ (function () {
    function Reaction(name, onInvalidate, errorHandler, requiresObservable) {
        if (name === void 0) { name = "Reaction@" + getNextId(); }
        if (requiresObservable === void 0) { requiresObservable = false; }
        this.name = name;
        this.onInvalidate = onInvalidate;
        this.errorHandler = errorHandler;
        this.requiresObservable = requiresObservable;
        this.observing = []; // nodes we are looking at. Our value depends on these nodes
        this.newObserving = [];
        this.dependenciesState = IDerivationState.NOT_TRACKING;
        this.diffValue = 0;
        this.runId = 0;
        this.unboundDepsCount = 0;
        this.__mapid = "#" + getNextId();
        this.isDisposed = false;
        this._isScheduled = false;
        this._isTrackPending = false;
        this._isRunning = false;
        this.isTracing = TraceMode.NONE;
    }
    Reaction.prototype.onBecomeStale = function () {
        this.schedule();
    };
    Reaction.prototype.schedule = function () {
        if (!this._isScheduled) {
            this._isScheduled = true;
            globalState.pendingReactions.push(this);
            runReactions();
        }
    };
    Reaction.prototype.isScheduled = function () {
        return this._isScheduled;
    };
    /**
     * internal, use schedule() if you intend to kick off a reaction
     */
    Reaction.prototype.runReaction = function () {
        if (!this.isDisposed) {
            startBatch();
            this._isScheduled = false;
            if (shouldCompute(this)) {
                this._isTrackPending = true;
                try {
                    this.onInvalidate();
                    if (this._isTrackPending && isSpyEnabled()) {
                        // onInvalidate didn't trigger track right away..
                        spyReport({
                            name: this.name,
                            type: "scheduled-reaction"
                        });
                    }
                }
                catch (e) {
                    this.reportExceptionInDerivation(e);
                }
            }
            endBatch();
        }
    };
    Reaction.prototype.track = function (fn) {
        startBatch();
        var notify = isSpyEnabled();
        var startTime;
        if (notify) {
            startTime = Date.now();
            spyReportStart({
                name: this.name,
                type: "reaction"
            });
        }
        this._isRunning = true;
        var result = trackDerivedFunction(this, fn, undefined);
        this._isRunning = false;
        this._isTrackPending = false;
        if (this.isDisposed) {
            // disposed during last run. Clean up everything that was bound after the dispose call.
            clearObserving(this);
        }
        if (isCaughtException(result))
            this.reportExceptionInDerivation(result.cause);
        if (notify) {
            spyReportEnd({
                time: Date.now() - startTime
            });
        }
        endBatch();
    };
    Reaction.prototype.reportExceptionInDerivation = function (error) {
        var _this = this;
        if (this.errorHandler) {
            this.errorHandler(error, this);
            return;
        }
        if (globalState.disableErrorBoundaries)
            throw error;
        var message = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'";
        if (globalState.suppressReactionErrors) {
            console.warn("[mobx] (error in reaction '" + this.name + "' suppressed, fix error of causing action below)"); // prettier-ignore
        }
        else {
            console.error(message, error);
            /** If debugging brought you here, please, read the above message :-). Tnx! */
        }
        if (isSpyEnabled()) {
            spyReport({
                type: "error",
                name: this.name,
                message: message,
                error: "" + error
            });
        }
        globalState.globalReactionErrorHandlers.forEach(function (f) { return f(error, _this); });
    };
    Reaction.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.isDisposed = true;
            if (!this._isRunning) {
                // if disposed while running, clean up later. Maybe not optimal, but rare case
                startBatch();
                clearObserving(this);
                endBatch();
            }
        }
    };
    Reaction.prototype.getDisposer = function () {
        var r = this.dispose.bind(this);
        r.$mobx = this;
        return r;
    };
    Reaction.prototype.toString = function () {
        return "Reaction[" + this.name + "]";
    };
    Reaction.prototype.trace = function (enterBreakPoint) {
        if (enterBreakPoint === void 0) { enterBreakPoint = false; }
        trace(this, enterBreakPoint);
    };
    return Reaction;
}());
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function (f) { return f(); };
function runReactions() {
    // Trampolining, if runReactions are already running, new reactions will be picked up
    if (globalState.inBatch > 0 || globalState.isRunningReactions)
        return;
    reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
    globalState.isRunningReactions = true;
    var allReactions = globalState.pendingReactions;
    var iterations = 0;
    // While running reactions, new reactions might be triggered.
    // Hence we work with two variables and check whether
    // we converge to no remaining reactions after a while.
    while (allReactions.length > 0) {
        if (++iterations === MAX_REACTION_ITERATIONS) {
            console.error("Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." +
                (" Probably there is a cycle in the reactive function: " + allReactions[0]));
            allReactions.splice(0); // clear reactions
        }
        var remainingReactions = allReactions.splice(0);
        for (var i = 0, l = remainingReactions.length; i < l; i++)
            remainingReactions[i].runReaction();
    }
    globalState.isRunningReactions = false;
}
var isReaction = createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
    var baseScheduler = reactionScheduler;
    reactionScheduler = function (f) { return fn(function () { return baseScheduler(f); }); };
}

function isSpyEnabled() {
    return !!globalState.spyListeners.length;
}
function spyReport(event) {
    if (!globalState.spyListeners.length)
        return;
    var listeners = globalState.spyListeners;
    for (var i = 0, l = listeners.length; i < l; i++)
        listeners[i](event);
}
function spyReportStart(event) {
    var change = __assign$1(__assign$1({}, event), { spyReportStart: true });
    spyReport(change);
}
var END_EVENT = { spyReportEnd: true };
function spyReportEnd(change) {
    if (change)
        spyReport(__assign$1(__assign$1({}, change), { spyReportEnd: true }));
    else
        spyReport(END_EVENT);
}
function spy(listener) {
    globalState.spyListeners.push(listener);
    return once(function () {
        globalState.spyListeners = globalState.spyListeners.filter(function (l) { return l !== listener; });
    });
}

function dontReassignFields() {
    fail(process.env.NODE_ENV !== "production" && "@action fields are not reassignable");
}
function namedActionDecorator(name) {
    return function (target, prop, descriptor) {
        if (descriptor) {
            if (process.env.NODE_ENV !== "production" && descriptor.get !== undefined) {
                return fail("@action cannot be used with getters");
            }
            // babel / typescript
            // @action method() { }
            if (descriptor.value) {
                // typescript
                return {
                    value: createAction(name, descriptor.value),
                    enumerable: false,
                    configurable: true,
                    writable: true // for typescript, this must be writable, otherwise it cannot inherit :/ (see inheritable actions test)
                };
            }
            // babel only: @action method = () => {}
            var initializer_1 = descriptor.initializer;
            return {
                enumerable: false,
                configurable: true,
                writable: true,
                initializer: function () {
                    // N.B: we can't immediately invoke initializer; this would be wrong
                    return createAction(name, initializer_1.call(this));
                }
            };
        }
        // bound instance methods
        return actionFieldDecorator(name).apply(this, arguments);
    };
}
function actionFieldDecorator(name) {
    // Simple property that writes on first invocation to the current instance
    return function (target, prop, descriptor) {
        Object.defineProperty(target, prop, {
            configurable: true,
            enumerable: false,
            get: function () {
                return undefined;
            },
            set: function (value) {
                addHiddenProp(this, prop, action(name, value));
            }
        });
    };
}
function boundActionDecorator(target, propertyName, descriptor, applyToInstance) {
    if (applyToInstance === true) {
        defineBoundAction(target, propertyName, descriptor.value);
        return null;
    }
    if (descriptor) {
        // if (descriptor.value)
        // Typescript / Babel: @action.bound method() { }
        // also: babel @action.bound method = () => {}
        return {
            configurable: true,
            enumerable: false,
            get: function () {
                defineBoundAction(this, propertyName, descriptor.value || descriptor.initializer.call(this));
                return this[propertyName];
            },
            set: dontReassignFields
        };
    }
    // field decorator Typescript @action.bound method = () => {}
    return {
        enumerable: false,
        configurable: true,
        set: function (v) {
            defineBoundAction(this, propertyName, v);
        },
        get: function () {
            return undefined;
        }
    };
}

var action = function action(arg1, arg2, arg3, arg4) {
    // action(fn() {})
    if (arguments.length === 1 && typeof arg1 === "function")
        return createAction(arg1.name || "<unnamed action>", arg1);
    // action("name", fn() {})
    if (arguments.length === 2 && typeof arg2 === "function")
        return createAction(arg1, arg2);
    // @action("name") fn() {}
    if (arguments.length === 1 && typeof arg1 === "string")
        return namedActionDecorator(arg1);
    // @action fn() {}
    if (arg4 === true) {
        // apply to instance immediately
        arg1[arg2] = createAction(arg1.name || arg2, arg3.value);
    }
    else {
        return namedActionDecorator(arg2).apply(null, arguments);
    }
};
action.bound = boundActionDecorator;
function runInAction(arg1, arg2) {
    // TODO: deprecate?
    var actionName = typeof arg1 === "string" ? arg1 : arg1.name || "<unnamed action>";
    var fn = typeof arg1 === "function" ? arg1 : arg2;
    if (process.env.NODE_ENV !== "production") {
        invariant(typeof fn === "function" && fn.length === 0, "`runInAction` expects a function without arguments");
        if (typeof actionName !== "string" || !actionName)
            fail("actions should have valid names, got: '" + actionName + "'");
    }
    return executeAction(actionName, fn, this, undefined);
}
function isAction(thing) {
    return typeof thing === "function" && thing.isMobxAction === true;
}
function defineBoundAction(target, propertyName, fn) {
    addHiddenProp(target, propertyName, createAction(propertyName, fn.bind(target)));
}

/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */
function autorun(view, opts) {
    if (opts === void 0) { opts = EMPTY_OBJECT; }
    if (process.env.NODE_ENV !== "production") {
        invariant(typeof view === "function", "Autorun expects a function as first argument");
        invariant(isAction(view) === false, "Autorun does not accept actions since actions are untrackable");
    }
    var name = (opts && opts.name) || view.name || "Autorun@" + getNextId();
    var runSync = !opts.scheduler && !opts.delay;
    var reaction;
    if (runSync) {
        // normal autorun
        reaction = new Reaction(name, function () {
            this.track(reactionRunner);
        }, opts.onError, opts.requiresObservable);
    }
    else {
        var scheduler_1 = createSchedulerFromOptions(opts);
        // debounced autorun
        var isScheduled_1 = false;
        reaction = new Reaction(name, function () {
            if (!isScheduled_1) {
                isScheduled_1 = true;
                scheduler_1(function () {
                    isScheduled_1 = false;
                    if (!reaction.isDisposed)
                        reaction.track(reactionRunner);
                });
            }
        }, opts.onError, opts.requiresObservable);
    }
    function reactionRunner() {
        view(reaction);
    }
    reaction.schedule();
    return reaction.getDisposer();
}
var run = function (f) { return f(); };
function createSchedulerFromOptions(opts) {
    return opts.scheduler
        ? opts.scheduler
        : opts.delay
            ? function (f) { return setTimeout(f, opts.delay); }
            : run;
}

function onBecomeObserved(thing, arg2, arg3) {
    return interceptHook("onBecomeObserved", thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
    return interceptHook("onBecomeUnobserved", thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
    var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
    var cb = typeof arg3 === "function" ? arg3 : arg2;
    var orig = atom[hook];
    if (typeof orig !== "function")
        return fail(process.env.NODE_ENV !== "production" && "Not an atom that can be (un)observed");
    atom[hook] = function () {
        orig.call(this);
        cb.call(this);
    };
    return function () {
        atom[hook] = orig;
    };
}

function configure(options) {
    var enforceActions = options.enforceActions, computedRequiresReaction = options.computedRequiresReaction, computedConfigurable = options.computedConfigurable, disableErrorBoundaries = options.disableErrorBoundaries, arrayBuffer = options.arrayBuffer, reactionScheduler = options.reactionScheduler, reactionRequiresObservable = options.reactionRequiresObservable, observableRequiresReaction = options.observableRequiresReaction;
    if (options.isolateGlobalState === true) {
        isolateGlobalState();
    }
    if (enforceActions !== undefined) {
        if (typeof enforceActions === "boolean" || enforceActions === "strict")
            deprecated("Deprecated value for 'enforceActions', use 'false' => '\"never\"', 'true' => '\"observed\"', '\"strict\"' => \"'always'\" instead");
        var ea = void 0;
        switch (enforceActions) {
            case true:
            case "observed":
                ea = true;
                break;
            case false:
            case "never":
                ea = false;
                break;
            case "strict":
            case "always":
                ea = "strict";
                break;
            default:
                fail("Invalid value for 'enforceActions': '" + enforceActions + "', expected 'never', 'always' or 'observed'");
        }
        globalState.enforceActions = ea;
        globalState.allowStateChanges = ea === true || ea === "strict" ? false : true;
    }
    if (computedRequiresReaction !== undefined) {
        globalState.computedRequiresReaction = !!computedRequiresReaction;
    }
    if (reactionRequiresObservable !== undefined) {
        globalState.reactionRequiresObservable = !!reactionRequiresObservable;
    }
    if (observableRequiresReaction !== undefined) {
        globalState.observableRequiresReaction = !!observableRequiresReaction;
        globalState.allowStateReads = !globalState.observableRequiresReaction;
    }
    if (computedConfigurable !== undefined) {
        globalState.computedConfigurable = !!computedConfigurable;
    }
    if (disableErrorBoundaries !== undefined) {
        if (disableErrorBoundaries === true)
            console.warn("WARNING: Debug feature only. MobX will NOT recover from errors if this is on.");
        globalState.disableErrorBoundaries = !!disableErrorBoundaries;
    }
    if (typeof arrayBuffer === "number") {
        reserveArrayBuffer(arrayBuffer);
    }
    if (reactionScheduler) {
        setReactionScheduler(reactionScheduler);
    }
}
function extendObservable(target, properties, decorators, options) {
    if (process.env.NODE_ENV !== "production") {
        invariant(arguments.length >= 2 && arguments.length <= 4, "'extendObservable' expected 2-4 arguments");
        invariant(typeof target === "object", "'extendObservable' expects an object as first argument");
        invariant(!isObservableMap(target), "'extendObservable' should not be used on maps, use map.merge instead");
        invariant(!isObservable(properties), "Extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540");
        if (decorators)
            for (var key in decorators)
                if (!(key in properties))
                    fail("Trying to declare a decorator for unspecified property '" + key + "'");
    }
    options = asCreateObservableOptions(options);
    var defaultDecorator = options.defaultDecorator || (options.deep === false ? refDecorator : deepDecorator);
    initializeInstance(target);
    asObservableObject(target, options.name, defaultDecorator.enhancer); // make sure object is observable, even without initial props
    startBatch();
    try {
        for (var key in properties) {
            var descriptor = Object.getOwnPropertyDescriptor(properties, key);
            if (process.env.NODE_ENV !== "production") {
                if (isComputed(descriptor.value))
                    fail("Passing a 'computed' as initial property value is no longer supported by extendObservable. Use a getter or decorator instead");
            }
            var decorator = decorators && key in decorators
                ? decorators[key]
                : descriptor.get
                    ? computedDecorator
                    : defaultDecorator;
            if (process.env.NODE_ENV !== "production" && typeof decorator !== "function")
                return fail("Not a valid decorator for '" + key + "', got: " + decorator);
            var resultDescriptor = decorator(target, key, descriptor, true);
            if (resultDescriptor // otherwise, assume already applied, due to `applyToInstance`
            )
                Object.defineProperty(target, key, resultDescriptor);
        }
    }
    finally {
        endBatch();
    }
    return target;
}

function getDependencyTree(thing, property) {
    return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
    var result = {
        name: node.name
    };
    if (node.observing && node.observing.length > 0)
        result.dependencies = unique(node.observing).map(nodeToDependencyTree);
    return result;
}

function _isComputed(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (isObservableObject(value) === false)
            return false;
        if (!value.$mobx.values[property])
            return false;
        var atom = getAtom(value, property);
        return isComputedValue(atom);
    }
    return isComputedValue(value);
}
function isComputed(value) {
    if (arguments.length > 1)
        return fail(process.env.NODE_ENV !== "production" &&
            "isComputed expects only 1 argument. Use isObservableProp to inspect the observability of a property");
    return _isComputed(value);
}

function _isObservable(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (process.env.NODE_ENV !== "production" &&
            (isObservableMap(value) || isObservableArray(value)))
            return fail("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
        if (isObservableObject(value)) {
            var o = value.$mobx;
            return o.values && !!o.values[property];
        }
        return false;
    }
    // For first check, see #701
    return (isObservableObject(value) ||
        !!value.$mobx ||
        isAtom(value) ||
        isReaction(value) ||
        isComputedValue(value));
}
function isObservable(value) {
    if (arguments.length !== 1)
        fail(process.env.NODE_ENV !== "production" &&
            "isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
    return _isObservable(value);
}

function keys(obj) {
    if (isObservableObject(obj)) {
        return obj.$mobx.getKeys();
    }
    if (isObservableMap(obj)) {
        return obj._keys.slice();
    }
    if (isObservableSet(obj)) {
        return iteratorToArray(obj.keys());
    }
    if (isObservableArray(obj)) {
        return obj.map(function (_, index) { return index; });
    }
    return fail(process.env.NODE_ENV !== "production" &&
        "'keys()' can only be used on observable objects, arrays, sets and maps");
}

var defaultOptions = {
    detectCycles: true,
    exportMapsAsObjects: true,
    recurseEverything: false
};
function cache(map, key, value, options) {
    if (options.detectCycles)
        map.set(key, value);
    return value;
}
function toJSHelper(source, options, __alreadySeen) {
    if (!options.recurseEverything && !isObservable(source))
        return source;
    if (typeof source !== "object")
        return source;
    // Directly return null if source is null
    if (source === null)
        return null;
    // Directly return the Date object itself if contained in the observable
    if (source instanceof Date)
        return source;
    if (isObservableValue(source))
        return toJSHelper(source.get(), options, __alreadySeen);
    // make sure we track the keys of the object
    if (isObservable(source))
        keys(source);
    var detectCycles = options.detectCycles === true;
    if (detectCycles && source !== null && __alreadySeen.has(source)) {
        return __alreadySeen.get(source);
    }
    if (isObservableArray(source) || Array.isArray(source)) {
        var res_1 = cache(__alreadySeen, source, [], options);
        var toAdd = source.map(function (value) { return toJSHelper(value, options, __alreadySeen); });
        res_1.length = toAdd.length;
        for (var i = 0, l = toAdd.length; i < l; i++)
            res_1[i] = toAdd[i];
        return res_1;
    }
    if (isObservableSet(source) || Object.getPrototypeOf(source) === Set.prototype) {
        if (options.exportMapsAsObjects === false) {
            var res_2 = cache(__alreadySeen, source, new Set(), options);
            source.forEach(function (value) {
                res_2.add(toJSHelper(value, options, __alreadySeen));
            });
            return res_2;
        }
        else {
            var res_3 = cache(__alreadySeen, source, [], options);
            source.forEach(function (value) {
                res_3.push(toJSHelper(value, options, __alreadySeen));
            });
            return res_3;
        }
    }
    if (isObservableMap(source) || Object.getPrototypeOf(source) === Map.prototype) {
        if (options.exportMapsAsObjects === false) {
            var res_4 = cache(__alreadySeen, source, new Map(), options);
            source.forEach(function (value, key) {
                res_4.set(key, toJSHelper(value, options, __alreadySeen));
            });
            return res_4;
        }
        else {
            var res_5 = cache(__alreadySeen, source, {}, options);
            source.forEach(function (value, key) {
                res_5[key] = toJSHelper(value, options, __alreadySeen);
            });
            return res_5;
        }
    }
    // Fallback to the situation that source is an ObservableObject or a plain object
    var res = cache(__alreadySeen, source, {}, options);
    for (var key in source) {
        res[key] = toJSHelper(source[key], options, __alreadySeen);
    }
    return res;
}
function toJS(source, options) {
    // backward compatibility
    if (typeof options === "boolean")
        options = { detectCycles: options };
    if (!options)
        options = defaultOptions;
    options.detectCycles =
        options.detectCycles === undefined
            ? options.recurseEverything === true
            : options.detectCycles === true;
    var __alreadySeen;
    if (options.detectCycles)
        __alreadySeen = new Map();
    return toJSHelper(source, options, __alreadySeen);
}

function trace() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var enterBreakPoint = false;
    if (typeof args[args.length - 1] === "boolean")
        enterBreakPoint = args.pop();
    var derivation = getAtomFromArgs(args);
    if (!derivation) {
        return fail(process.env.NODE_ENV !== "production" &&
            "'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
    }
    if (derivation.isTracing === TraceMode.NONE) {
        console.log("[mobx.trace] '" + derivation.name + "' tracing enabled");
    }
    derivation.isTracing = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
    switch (args.length) {
        case 0:
            return globalState.trackingDerivation;
        case 1:
            return getAtom(args[0]);
        case 2:
            return getAtom(args[0], args[1]);
    }
}

/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */
function transaction(action, thisArg) {
    if (thisArg === void 0) { thisArg = undefined; }
    startBatch();
    try {
        return action.apply(thisArg);
    }
    finally {
        endBatch();
    }
}

function hasInterceptors(interceptable) {
    return interceptable.interceptors !== undefined && interceptable.interceptors.length > 0;
}
function registerInterceptor(interceptable, handler) {
    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);
    interceptors.push(handler);
    return once(function () {
        var idx = interceptors.indexOf(handler);
        if (idx !== -1)
            interceptors.splice(idx, 1);
    });
}
function interceptChange(interceptable, change) {
    var prevU = untrackedStart();
    try {
        var interceptors = interceptable.interceptors;
        if (interceptors)
            for (var i = 0, l = interceptors.length; i < l; i++) {
                change = interceptors[i](change);
                invariant(!change || change.type, "Intercept handlers should return nothing or a change object");
                if (!change)
                    break;
            }
        return change;
    }
    finally {
        untrackedEnd(prevU);
    }
}

function hasListeners(listenable) {
    return listenable.changeListeners !== undefined && listenable.changeListeners.length > 0;
}
function registerListener(listenable, handler) {
    var listeners = listenable.changeListeners || (listenable.changeListeners = []);
    listeners.push(handler);
    return once(function () {
        var idx = listeners.indexOf(handler);
        if (idx !== -1)
            listeners.splice(idx, 1);
    });
}
function notifyListeners(listenable, change) {
    var prevU = untrackedStart();
    var listeners = listenable.changeListeners;
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i](change);
    }
    untrackedEnd(prevU);
}

var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859
// Detects bug in safari 9.1.1 (or iOS 9 safari mobile). See #364
var safariPrototypeSetterInheritanceBug = (function () {
    var v = false;
    var p = {};
    Object.defineProperty(p, "0", {
        set: function () {
            v = true;
        }
    });
    Object.create(p)["0"] = 1;
    return v === false;
})();
/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
// Typescript workaround to make sure ObservableArray extends Array
var StubArray = /** @class */ (function () {
    function StubArray() {
    }
    return StubArray;
}());
function inherit(ctor, proto) {
    if (typeof Object["setPrototypeOf"] !== "undefined") {
        Object["setPrototypeOf"](ctor.prototype, proto);
    }
    else if (typeof ctor.prototype.__proto__ !== "undefined") {
        ctor.prototype.__proto__ = proto;
    }
    else {
        ctor["prototype"] = proto;
    }
}
inherit(StubArray, Array.prototype);
// Weex freeze Array.prototype
// Make them writeable and configurable in prototype chain
// https://github.com/alibaba/weex/pull/1529
if (Object.isFrozen(Array)) {
    [
        "constructor",
        "push",
        "shift",
        "concat",
        "pop",
        "unshift",
        "replace",
        "find",
        "findIndex",
        "splice",
        "reverse",
        "sort"
    ].forEach(function (key) {
        Object.defineProperty(StubArray.prototype, key, {
            configurable: true,
            writable: true,
            value: Array.prototype[key]
        });
    });
}
var ObservableArrayAdministration = /** @class */ (function () {
    function ObservableArrayAdministration(name, enhancer, array, owned) {
        this.array = array;
        this.owned = owned;
        this.values = [];
        this.lastKnownLength = 0;
        this.atom = new Atom(name || "ObservableArray@" + getNextId());
        this.enhancer = function (newV, oldV) { return enhancer(newV, oldV, name + "[..]"); };
    }
    ObservableArrayAdministration.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined)
            return this.dehancer(value);
        return value;
    };
    ObservableArrayAdministration.prototype.dehanceValues = function (values) {
        if (this.dehancer !== undefined && values.length > 0)
            return values.map(this.dehancer);
        return values;
    };
    ObservableArrayAdministration.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {
        if (fireImmediately === void 0) { fireImmediately = false; }
        if (fireImmediately) {
            listener({
                object: this.array,
                type: "splice",
                index: 0,
                added: this.values.slice(),
                addedCount: this.values.length,
                removed: [],
                removedCount: 0
            });
        }
        return registerListener(this, listener);
    };
    ObservableArrayAdministration.prototype.getArrayLength = function () {
        this.atom.reportObserved();
        return this.values.length;
    };
    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {
        if (typeof newLength !== "number" || newLength < 0)
            throw new Error("[mobx.array] Out of range: " + newLength);
        var currentLength = this.values.length;
        if (newLength === currentLength)
            return;
        else if (newLength > currentLength) {
            var newItems = new Array(newLength - currentLength);
            for (var i = 0; i < newLength - currentLength; i++)
                newItems[i] = undefined; // No Array.fill everywhere...
            this.spliceWithArray(currentLength, 0, newItems);
        }
        else
            this.spliceWithArray(newLength, currentLength - newLength);
    };
    // adds / removes the necessary numeric properties to this object
    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {
        if (oldLength !== this.lastKnownLength)
            throw new Error("[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?");
        this.lastKnownLength += delta;
        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE)
            reserveArrayBuffer(oldLength + delta + 1);
    };
    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {
        var _this = this;
        checkIfStateModificationsAreAllowed(this.atom);
        var length = this.values.length;
        if (index === undefined)
            index = 0;
        else if (index > length)
            index = length;
        else if (index < 0)
            index = Math.max(0, length + index);
        if (arguments.length === 1)
            deleteCount = length - index;
        else if (deleteCount === undefined || deleteCount === null)
            deleteCount = 0;
        else
            deleteCount = Math.max(0, Math.min(deleteCount, length - index));
        if (newItems === undefined)
            newItems = EMPTY_ARRAY;
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                object: this.array,
                type: "splice",
                index: index,
                removedCount: deleteCount,
                added: newItems
            });
            if (!change)
                return EMPTY_ARRAY;
            deleteCount = change.removedCount;
            newItems = change.added;
        }
        newItems =
            newItems.length === 0 ? newItems : newItems.map(function (v) { return _this.enhancer(v, undefined); });
        var lengthDelta = newItems.length - deleteCount;
        this.updateArrayLength(length, lengthDelta); // create or remove new entries
        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);
        if (deleteCount !== 0 || newItems.length !== 0)
            this.notifyArraySplice(index, newItems, res);
        return this.dehanceValues(res);
    };
    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {
        var _a;
        if (newItems.length < MAX_SPLICE_SIZE) {
            return (_a = this.values).splice.apply(_a, __spread$1([index, deleteCount], newItems));
        }
        else {
            var res = this.values.slice(index, index + deleteCount);
            this.values = this.values
                .slice(0, index)
                .concat(newItems, this.values.slice(index + deleteCount));
            return res;
        }
    };
    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {
        var notifySpy = !this.owned && isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy
            ? {
                object: this.array,
                type: "update",
                index: index,
                newValue: newValue,
                oldValue: oldValue
            }
            : null;
        if (notifySpy)
            spyReportStart(__assign$1(__assign$1({}, change), { name: this.atom.name }));
        this.atom.reportChanged();
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
    };
    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {
        var notifySpy = !this.owned && isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy
            ? {
                object: this.array,
                type: "splice",
                index: index,
                removed: removed,
                added: added,
                removedCount: removed.length,
                addedCount: added.length
            }
            : null;
        if (notifySpy)
            spyReportStart(__assign$1(__assign$1({}, change), { name: this.atom.name }));
        this.atom.reportChanged();
        // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
    };
    return ObservableArrayAdministration;
}());
var ObservableArray = /** @class */ (function (_super) {
    __extends$1(ObservableArray, _super);
    function ObservableArray(initialValues, enhancer, name, owned) {
        if (name === void 0) { name = "ObservableArray@" + getNextId(); }
        if (owned === void 0) { owned = false; }
        var _this = _super.call(this) || this;
        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);
        addHiddenFinalProp(_this, "$mobx", adm);
        if (initialValues && initialValues.length) {
            var prev = allowStateChangesStart(true);
            _this.spliceWithArray(0, 0, initialValues);
            allowStateChangesEnd(prev);
        }
        if (safariPrototypeSetterInheritanceBug) {
            // Seems that Safari won't use numeric prototype setter untill any * numeric property is
            // defined on the instance. After that it works fine, even if this property is deleted.
            Object.defineProperty(adm.array, "0", ENTRY_0);
        }
        return _this;
    }
    ObservableArray.prototype.intercept = function (handler) {
        return this.$mobx.intercept(handler);
    };
    ObservableArray.prototype.observe = function (listener, fireImmediately) {
        if (fireImmediately === void 0) { fireImmediately = false; }
        return this.$mobx.observe(listener, fireImmediately);
    };
    ObservableArray.prototype.clear = function () {
        return this.splice(0);
    };
    ObservableArray.prototype.concat = function () {
        var arrays = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arrays[_i] = arguments[_i];
        }
        this.$mobx.atom.reportObserved();
        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) { return (isObservableArray(a) ? a.peek() : a); }));
    };
    ObservableArray.prototype.replace = function (newItems) {
        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);
    };
    /**
     * Converts this array back to a (shallow) javascript structure.
     * For a deep clone use mobx.toJS
     */
    ObservableArray.prototype.toJS = function () {
        return this.slice();
    };
    ObservableArray.prototype.toJSON = function () {
        // Used by JSON.stringify
        return this.toJS();
    };
    ObservableArray.prototype.peek = function () {
        this.$mobx.atom.reportObserved();
        return this.$mobx.dehanceValues(this.$mobx.values);
    };
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {
        if (fromIndex === void 0) { fromIndex = 0; }
        if (arguments.length === 3)
            deprecated("The array.find fromIndex argument to find will not be supported anymore in the next major");
        var idx = this.findIndex.apply(this, arguments);
        return idx === -1 ? undefined : this.get(idx);
    };
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
    ObservableArray.prototype.findIndex = function (predicate, thisArg, fromIndex) {
        if (fromIndex === void 0) { fromIndex = 0; }
        if (arguments.length === 3)
            deprecated("The array.findIndex fromIndex argument to find will not be supported anymore in the next major");
        var items = this.peek(), l = items.length;
        for (var i = fromIndex; i < l; i++)
            if (predicate.call(thisArg, items[i], i, this))
                return i;
        return -1;
    };
    /*
     * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
     * since these functions alter the inner structure of the array, the have side effects.
     * Because the have side effects, they should not be used in computed function,
     * and for that reason the do not call dependencyState.notifyObserved
     */
    ObservableArray.prototype.splice = function (index, deleteCount) {
        var newItems = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            newItems[_i - 2] = arguments[_i];
        }
        switch (arguments.length) {
            case 0:
                return [];
            case 1:
                return this.$mobx.spliceWithArray(index);
            case 2:
                return this.$mobx.spliceWithArray(index, deleteCount);
        }
        return this.$mobx.spliceWithArray(index, deleteCount, newItems);
    };
    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {
        return this.$mobx.spliceWithArray(index, deleteCount, newItems);
    };
    ObservableArray.prototype.push = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        var adm = this.$mobx;
        adm.spliceWithArray(adm.values.length, 0, items);
        return adm.values.length;
    };
    ObservableArray.prototype.pop = function () {
        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];
    };
    ObservableArray.prototype.shift = function () {
        return this.splice(0, 1)[0];
    };
    ObservableArray.prototype.unshift = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        var adm = this.$mobx;
        adm.spliceWithArray(0, 0, items);
        return adm.values.length;
    };
    ObservableArray.prototype.reverse = function () {
        // reverse by default mutates in place before returning the result
        // which makes it both a 'derivation' and a 'mutation'.
        // so we deviate from the default and just make it an dervitation
        var clone = this.slice();
        return clone.reverse.apply(clone, arguments);
    };
    ObservableArray.prototype.sort = function (compareFn) {
        // sort by default mutates in place before returning the result
        // which goes against all good practices. Let's not change the array in place!
        var clone = this.slice();
        return clone.sort.apply(clone, arguments);
    };
    ObservableArray.prototype.remove = function (value) {
        var idx = this.$mobx.dehanceValues(this.$mobx.values).indexOf(value);
        if (idx > -1) {
            this.splice(idx, 1);
            return true;
        }
        return false;
    };
    ObservableArray.prototype.move = function (fromIndex, toIndex) {
        deprecated("observableArray.move is deprecated, use .slice() & .replace() instead");
        function checkIndex(index) {
            if (index < 0) {
                throw new Error("[mobx.array] Index out of bounds: " + index + " is negative");
            }
            var length = this.$mobx.values.length;
            if (index >= length) {
                throw new Error("[mobx.array] Index out of bounds: " + index + " is not smaller than " + length);
            }
        }
        checkIndex.call(this, fromIndex);
        checkIndex.call(this, toIndex);
        if (fromIndex === toIndex) {
            return;
        }
        var oldItems = this.$mobx.values;
        var newItems;
        if (fromIndex < toIndex) {
            newItems = __spread$1(oldItems.slice(0, fromIndex), oldItems.slice(fromIndex + 1, toIndex + 1), [
                oldItems[fromIndex]
            ], oldItems.slice(toIndex + 1));
        }
        else {
            // toIndex < fromIndex
            newItems = __spread$1(oldItems.slice(0, toIndex), [
                oldItems[fromIndex]
            ], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));
        }
        this.replace(newItems);
    };
    // See #734, in case property accessors are unreliable...
    ObservableArray.prototype.get = function (index) {
        var impl = this.$mobx;
        if (impl) {
            if (index < impl.values.length) {
                impl.atom.reportObserved();
                return impl.dehanceValue(impl.values[index]);
            }
            console.warn("[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + impl.values.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
        }
        return undefined;
    };
    // See #734, in case property accessors are unreliable...
    ObservableArray.prototype.set = function (index, newValue) {
        var adm = this.$mobx;
        var values = adm.values;
        if (index < values.length) {
            // update at index in range
            checkIfStateModificationsAreAllowed(adm.atom);
            var oldValue = values[index];
            if (hasInterceptors(adm)) {
                var change = interceptChange(adm, {
                    type: "update",
                    object: this,
                    index: index,
                    newValue: newValue
                });
                if (!change)
                    return;
                newValue = change.newValue;
            }
            newValue = adm.enhancer(newValue, oldValue);
            var changed = newValue !== oldValue;
            if (changed) {
                values[index] = newValue;
                adm.notifyArrayChildUpdate(index, newValue, oldValue);
            }
        }
        else if (index === values.length) {
            // add a new item
            adm.spliceWithArray(index, 0, [newValue]);
        }
        else {
            // out of bounds
            throw new Error("[mobx.array] Index out of bounds, " + index + " is larger than " + values.length);
        }
    };
    return ObservableArray;
}(StubArray));
declareIterator(ObservableArray.prototype, function () {
    this.$mobx.atom.reportObserved();
    var self = this;
    var nextIndex = 0;
    return makeIterable({
        next: function () {
            return nextIndex < self.length
                ? { value: self[nextIndex++], done: false }
                : { done: true, value: undefined };
        }
    });
});
Object.defineProperty(ObservableArray.prototype, "length", {
    enumerable: false,
    configurable: true,
    get: function () {
        return this.$mobx.getArrayLength();
    },
    set: function (newLength) {
        this.$mobx.setArrayLength(newLength);
    }
});
addHiddenProp(ObservableArray.prototype, toStringTagSymbol(), "Array");
[
    "every",
    "filter",
    "forEach",
    "indexOf",
    "join",
    "lastIndexOf",
    "map",
    "reduce",
    "reduceRight",
    "slice",
    "some",
    "toString",
    "toLocaleString"
].forEach(function (funcName) {
    var baseFunc = Array.prototype[funcName];
    invariant(typeof baseFunc === "function", "Base function not defined on Array prototype: '" + funcName + "'");
    addHiddenProp(ObservableArray.prototype, funcName, function () {
        return baseFunc.apply(this.peek(), arguments);
    });
});
/**
 * We don't want those to show up in `for (const key in ar)` ...
 */
makeNonEnumerable(ObservableArray.prototype, [
    "constructor",
    "intercept",
    "observe",
    "clear",
    "concat",
    "get",
    "replace",
    "toJS",
    "toJSON",
    "peek",
    "find",
    "findIndex",
    "splice",
    "spliceWithArray",
    "push",
    "pop",
    "set",
    "shift",
    "unshift",
    "reverse",
    "sort",
    "remove",
    "move",
    "toString",
    "toLocaleString"
]);
// See #364
var ENTRY_0 = createArrayEntryDescriptor(0);
function createArrayEntryDescriptor(index) {
    return {
        enumerable: false,
        configurable: false,
        get: function () {
            return this.get(index);
        },
        set: function (value) {
            this.set(index, value);
        }
    };
}
function createArrayBufferItem(index) {
    Object.defineProperty(ObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}
function reserveArrayBuffer(max) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++)
        createArrayBufferItem(index);
    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
}
reserveArrayBuffer(1000);
var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);
}

var ObservableMapMarker = {};
var ObservableMap = /** @class */ (function () {
    function ObservableMap(initialData, enhancer, name) {
        if (enhancer === void 0) { enhancer = deepEnhancer; }
        if (name === void 0) { name = "ObservableMap@" + getNextId(); }
        this.enhancer = enhancer;
        this.name = name;
        this.$mobx = ObservableMapMarker;
        this._keys = (new ObservableArray(undefined, referenceEnhancer, this.name + ".keys()", true));
        if (typeof Map !== "function") {
            throw new Error("mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js");
        }
        this._data = new Map();
        this._hasMap = new Map();
        this.merge(initialData);
    }
    ObservableMap.prototype._has = function (key) {
        return this._data.has(key);
    };
    ObservableMap.prototype.has = function (key) {
        var _this = this;
        if (!globalState.trackingDerivation)
            return this._has(key);
        var entry = this._hasMap.get(key);
        if (!entry) {
            // todo: replace with atom (breaking change)
            var newEntry = (entry = new ObservableValue(this._has(key), referenceEnhancer, this.name + "." + stringifyKey(key) + "?", false));
            this._hasMap.set(key, newEntry);
            onBecomeUnobserved(newEntry, function () { return _this._hasMap.delete(key); });
        }
        return entry.get();
    };
    ObservableMap.prototype.set = function (key, value) {
        var hasKey = this._has(key);
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: hasKey ? "update" : "add",
                object: this,
                newValue: value,
                name: key
            });
            if (!change)
                return this;
            value = change.newValue;
        }
        if (hasKey) {
            this._updateValue(key, value);
        }
        else {
            this._addValue(key, value);
        }
        return this;
    };
    ObservableMap.prototype.delete = function (key) {
        var _this = this;
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: "delete",
                object: this,
                name: key
            });
            if (!change)
                return false;
        }
        if (this._has(key)) {
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy
                ? {
                    type: "delete",
                    object: this,
                    oldValue: this._data.get(key).value,
                    name: key
                }
                : null;
            if (notifySpy)
                spyReportStart(__assign$1(__assign$1({}, change), { name: this.name, key: key }));
            transaction(function () {
                _this._keys.remove(key);
                _this._updateHasMapEntry(key, false);
                var observable = _this._data.get(key);
                observable.setNewValue(undefined);
                _this._data.delete(key);
            });
            if (notify)
                notifyListeners(this, change);
            if (notifySpy)
                spyReportEnd();
            return true;
        }
        return false;
    };
    ObservableMap.prototype._updateHasMapEntry = function (key, value) {
        var entry = this._hasMap.get(key);
        if (entry) {
            entry.setNewValue(value);
        }
    };
    ObservableMap.prototype._updateValue = function (key, newValue) {
        var observable = this._data.get(key);
        newValue = observable.prepareNewValue(newValue);
        if (newValue !== globalState.UNCHANGED) {
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy
                ? {
                    type: "update",
                    object: this,
                    oldValue: observable.value,
                    name: key,
                    newValue: newValue
                }
                : null;
            if (notifySpy)
                spyReportStart(__assign$1(__assign$1({}, change), { name: this.name, key: key }));
            observable.setNewValue(newValue);
            if (notify)
                notifyListeners(this, change);
            if (notifySpy)
                spyReportEnd();
        }
    };
    ObservableMap.prototype._addValue = function (key, newValue) {
        var _this = this;
        transaction(function () {
            var observable = new ObservableValue(newValue, _this.enhancer, _this.name + "." + stringifyKey(key), false);
            _this._data.set(key, observable);
            newValue = observable.value; // value might have been changed
            _this._updateHasMapEntry(key, true);
            _this._keys.push(key);
        });
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy
            ? {
                type: "add",
                object: this,
                name: key,
                newValue: newValue
            }
            : null;
        if (notifySpy)
            spyReportStart(__assign$1(__assign$1({}, change), { name: this.name, key: key }));
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
    };
    ObservableMap.prototype.get = function (key) {
        if (this.has(key))
            return this.dehanceValue(this._data.get(key).get());
        return this.dehanceValue(undefined);
    };
    ObservableMap.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined) {
            return this.dehancer(value);
        }
        return value;
    };
    ObservableMap.prototype.keys = function () {
        return this._keys[iteratorSymbol()]();
    };
    ObservableMap.prototype.values = function () {
        var self = this;
        var nextIndex = 0;
        return makeIterable({
            next: function () {
                return nextIndex < self._keys.length
                    ? { value: self.get(self._keys[nextIndex++]), done: false }
                    : { value: undefined, done: true };
            }
        });
    };
    ObservableMap.prototype.entries = function () {
        var self = this;
        var nextIndex = 0;
        return makeIterable({
            next: function () {
                if (nextIndex < self._keys.length) {
                    var key = self._keys[nextIndex++];
                    return {
                        value: [key, self.get(key)],
                        done: false
                    };
                }
                return { done: true };
            }
        });
    };
    ObservableMap.prototype.forEach = function (callback, thisArg) {
        var _this = this;
        this._keys.forEach(function (key) { return callback.call(thisArg, _this.get(key), key, _this); });
    };
    /** Merge another object into this object, returns this. */
    ObservableMap.prototype.merge = function (other) {
        var _this = this;
        if (isObservableMap(other)) {
            other = other.toJS();
        }
        transaction(function () {
            if (isPlainObject(other))
                Object.keys(other).forEach(function (key) { return _this.set(key, other[key]); });
            else if (Array.isArray(other))
                other.forEach(function (_a) {
                    var _b = __read$1(_a, 2), key = _b[0], value = _b[1];
                    return _this.set(key, value);
                });
            else if (isES6Map(other)) {
                if (other.constructor !== Map)
                    fail("Cannot initialize from classes that inherit from Map: " + other.constructor.name); // prettier-ignore
                else
                    other.forEach(function (value, key) { return _this.set(key, value); });
            }
            else if (other !== null && other !== undefined)
                fail("Cannot initialize map from " + other);
        });
        return this;
    };
    ObservableMap.prototype.clear = function () {
        var _this = this;
        transaction(function () {
            untracked(function () {
                _this._keys.slice().forEach(function (key) { return _this.delete(key); });
            });
        });
    };
    ObservableMap.prototype.replace = function (values) {
        var _this = this;
        transaction(function () {
            var replacementMap = convertToMap(values);
            var oldKeys = _this._keys;
            var newKeys = Array.from(replacementMap.keys());
            var keysChanged = false;
            for (var i = 0; i < oldKeys.length; i++) {
                var oldKey = oldKeys[i];
                // key order change
                if (oldKeys.length === newKeys.length && oldKey !== newKeys[i]) {
                    keysChanged = true;
                }
                // deleted key
                if (!replacementMap.has(oldKey)) {
                    keysChanged = true;
                    _this.delete(oldKey);
                }
            }
            replacementMap.forEach(function (value, key) {
                // new key
                if (!_this._data.has(key)) {
                    keysChanged = true;
                }
                _this.set(key, value);
            });
            if (keysChanged) {
                _this._keys.replace(newKeys);
            }
        });
        return this;
    };
    Object.defineProperty(ObservableMap.prototype, "size", {
        get: function () {
            return this._keys.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a plain object that represents this map.
     * Note that all the keys being stringified.
     * If there are duplicating keys after converting them to strings, behaviour is undetermined.
     */
    ObservableMap.prototype.toPOJO = function () {
        var _this = this;
        var res = {};
        this._keys.forEach(function (key) { return (res[typeof key === "symbol" ? key : stringifyKey(key)] = _this.get(key)); });
        return res;
    };
    /**
     * Returns a shallow non observable object clone of this map.
     * Note that the values migth still be observable. For a deep clone use mobx.toJS.
     */
    ObservableMap.prototype.toJS = function () {
        var _this = this;
        var res = new Map();
        this._keys.forEach(function (key) { return res.set(key, _this.get(key)); });
        return res;
    };
    ObservableMap.prototype.toJSON = function () {
        // Used by JSON.stringify
        return this.toPOJO();
    };
    ObservableMap.prototype.toString = function () {
        var _this = this;
        return (this.name +
            "[{ " +
            this._keys.map(function (key) { return stringifyKey(key) + ": " + ("" + _this.get(key)); }).join(", ") +
            " }]");
    };
    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */
    ObservableMap.prototype.observe = function (listener, fireImmediately) {
        process.env.NODE_ENV !== "production" &&
            invariant(fireImmediately !== true, "`observe` doesn't support fireImmediately=true in combination with maps.");
        return registerListener(this, listener);
    };
    ObservableMap.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    return ObservableMap;
}());
function stringifyKey(key) {
    if (key && key.toString)
        return key.toString();
    else
        return new String(key).toString();
}
declareIterator(ObservableMap.prototype, function () {
    return this.entries();
});
addHiddenFinalProp(ObservableMap.prototype, toStringTagSymbol(), "Map");
/* 'var' fixes small-build issue */
var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);

var ObservableSetMarker = {};
var ObservableSet = /** @class */ (function () {
    function ObservableSet(initialData, enhancer, name) {
        if (enhancer === void 0) { enhancer = deepEnhancer; }
        if (name === void 0) { name = "ObservableSet@" + getNextId(); }
        this.name = name;
        this.$mobx = ObservableSetMarker;
        this._data = new Set();
        this._atom = createAtom(this.name);
        if (typeof Set !== "function") {
            throw new Error("mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js");
        }
        this.enhancer = function (newV, oldV) { return enhancer(newV, oldV, name); };
        if (initialData) {
            this.replace(initialData);
        }
    }
    ObservableSet.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined) {
            return this.dehancer(value);
        }
        return value;
    };
    ObservableSet.prototype.clear = function () {
        var _this = this;
        transaction(function () {
            untracked(function () {
                _this._data.forEach(function (value) {
                    _this.delete(value);
                });
            });
        });
    };
    ObservableSet.prototype.forEach = function (callbackFn, thisArg) {
        var _this = this;
        this._data.forEach(function (value) {
            callbackFn.call(thisArg, value, value, _this);
        });
    };
    Object.defineProperty(ObservableSet.prototype, "size", {
        get: function () {
            this._atom.reportObserved();
            return this._data.size;
        },
        enumerable: true,
        configurable: true
    });
    ObservableSet.prototype.add = function (value) {
        var _this = this;
        checkIfStateModificationsAreAllowed(this._atom);
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: "add",
                object: this,
                newValue: value
            });
            if (!change)
                return this;
            // TODO: ideally, value = change.value would be done here, so that values can be
            // changed by interceptor. Same applies for other Set and Map api's.
        }
        if (!this.has(value)) {
            transaction(function () {
                _this._data.add(_this.enhancer(value, undefined));
                _this._atom.reportChanged();
            });
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy
                ? {
                    type: "add",
                    object: this,
                    newValue: value
                }
                : null;
            if (notifySpy && process.env.NODE_ENV !== "production")
                spyReportStart(change);
            if (notify)
                notifyListeners(this, change);
            if (notifySpy && process.env.NODE_ENV !== "production")
                spyReportEnd();
        }
        return this;
    };
    ObservableSet.prototype.delete = function (value) {
        var _this = this;
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: "delete",
                object: this,
                oldValue: value
            });
            if (!change)
                return false;
        }
        if (this.has(value)) {
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy
                ? {
                    type: "delete",
                    object: this,
                    oldValue: value
                }
                : null;
            if (notifySpy && process.env.NODE_ENV !== "production")
                spyReportStart(__assign$1(__assign$1({}, change), { name: this.name }));
            transaction(function () {
                _this._atom.reportChanged();
                _this._data.delete(value);
            });
            if (notify)
                notifyListeners(this, change);
            if (notifySpy && process.env.NODE_ENV !== "production")
                spyReportEnd();
            return true;
        }
        return false;
    };
    ObservableSet.prototype.has = function (value) {
        this._atom.reportObserved();
        return this._data.has(this.dehanceValue(value));
    };
    ObservableSet.prototype.entries = function () {
        var nextIndex = 0;
        var keys = iteratorToArray(this.keys());
        var values = iteratorToArray(this.values());
        return makeIterable({
            next: function () {
                var index = nextIndex;
                nextIndex += 1;
                return index < values.length
                    ? { value: [keys[index], values[index]], done: false }
                    : { done: true };
            }
        });
    };
    ObservableSet.prototype.keys = function () {
        return this.values();
    };
    ObservableSet.prototype.values = function () {
        this._atom.reportObserved();
        var self = this;
        var nextIndex = 0;
        var observableValues;
        if (this._data.values !== undefined) {
            observableValues = iteratorToArray(this._data.values());
        }
        else {
            // There is no values function in IE11
            observableValues = [];
            this._data.forEach(function (e) { return observableValues.push(e); });
        }
        return makeIterable({
            next: function () {
                return nextIndex < observableValues.length
                    ? { value: self.dehanceValue(observableValues[nextIndex++]), done: false }
                    : { done: true };
            }
        });
    };
    ObservableSet.prototype.replace = function (other) {
        var _this = this;
        if (isObservableSet(other)) {
            other = other.toJS();
        }
        transaction(function () {
            if (Array.isArray(other)) {
                _this.clear();
                other.forEach(function (value) { return _this.add(value); });
            }
            else if (isES6Set(other)) {
                _this.clear();
                other.forEach(function (value) { return _this.add(value); });
            }
            else if (other !== null && other !== undefined) {
                fail("Cannot initialize set from " + other);
            }
        });
        return this;
    };
    ObservableSet.prototype.observe = function (listener, fireImmediately) {
        // TODO 'fireImmediately' can be true?
        process.env.NODE_ENV !== "production" &&
            invariant(fireImmediately !== true, "`observe` doesn't support fireImmediately=true in combination with sets.");
        return registerListener(this, listener);
    };
    ObservableSet.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    ObservableSet.prototype.toJS = function () {
        return new Set(this);
    };
    ObservableSet.prototype.toString = function () {
        return this.name + "[ " + iteratorToArray(this.keys()).join(", ") + " ]";
    };
    return ObservableSet;
}());
declareIterator(ObservableSet.prototype, function () {
    return this.values();
});
addHiddenFinalProp(ObservableSet.prototype, toStringTagSymbol(), "Set");
var isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet);

var ObservableObjectAdministration = /** @class */ (function () {
    function ObservableObjectAdministration(target, name, defaultEnhancer) {
        this.target = target;
        this.name = name;
        this.defaultEnhancer = defaultEnhancer;
        this.values = {};
    }
    ObservableObjectAdministration.prototype.read = function (owner, key) {
        if (process.env.NODE_ENV === "production" && this.target !== owner) {
            this.illegalAccess(owner, key);
            if (!this.values[key])
                return undefined;
        }
        return this.values[key].get();
    };
    ObservableObjectAdministration.prototype.write = function (owner, key, newValue) {
        var instance = this.target;
        if (process.env.NODE_ENV === "production" && instance !== owner) {
            this.illegalAccess(owner, key);
        }
        var observable = this.values[key];
        if (observable instanceof ComputedValue) {
            observable.set(newValue);
            return;
        }
        // intercept
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: "update",
                object: instance,
                name: key,
                newValue: newValue
            });
            if (!change)
                return;
            newValue = change.newValue;
        }
        newValue = observable.prepareNewValue(newValue);
        // notify spy & observers
        if (newValue !== globalState.UNCHANGED) {
            var notify = hasListeners(this);
            var notifySpy = isSpyEnabled();
            var change = notify || notifySpy
                ? {
                    type: "update",
                    object: instance,
                    oldValue: observable.value,
                    name: key,
                    newValue: newValue
                }
                : null;
            if (notifySpy)
                spyReportStart(__assign$1(__assign$1({}, change), { name: this.name, key: key }));
            observable.setNewValue(newValue);
            if (notify)
                notifyListeners(this, change);
            if (notifySpy)
                spyReportEnd();
        }
    };
    ObservableObjectAdministration.prototype.remove = function (key) {
        if (!this.values[key])
            return;
        var target = this.target;
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                object: target,
                name: key,
                type: "remove"
            });
            if (!change)
                return;
        }
        try {
            startBatch();
            var notify = hasListeners(this);
            var notifySpy = isSpyEnabled();
            var oldValue = this.values[key].get();
            if (this.keys)
                this.keys.remove(key);
            delete this.values[key];
            delete this.target[key];
            var change = notify || notifySpy
                ? {
                    type: "remove",
                    object: target,
                    oldValue: oldValue,
                    name: key
                }
                : null;
            if (notifySpy)
                spyReportStart(__assign$1(__assign$1({}, change), { name: this.name, key: key }));
            if (notify)
                notifyListeners(this, change);
            if (notifySpy)
                spyReportEnd();
        }
        finally {
            endBatch();
        }
    };
    ObservableObjectAdministration.prototype.illegalAccess = function (owner, propName) {
        /**
         * This happens if a property is accessed through the prototype chain, but the property was
         * declared directly as own property on the prototype.
         *
         * E.g.:
         * class A {
         * }
         * extendObservable(A.prototype, { x: 1 })
         *
         * classB extens A {
         * }
         * console.log(new B().x)
         *
         * It is unclear whether the property should be considered 'static' or inherited.
         * Either use `console.log(A.x)`
         * or: decorate(A, { x: observable })
         *
         * When using decorate, the property will always be redeclared as own property on the actual instance
         */
        console.warn("Property '" + propName + "' of '" + owner + "' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner");
    };
    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */
    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {
        process.env.NODE_ENV !== "production" &&
            invariant(fireImmediately !== true, "`observe` doesn't support the fire immediately property for observable objects.");
        return registerListener(this, callback);
    };
    ObservableObjectAdministration.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    ObservableObjectAdministration.prototype.getKeys = function () {
        var _this = this;
        if (this.keys === undefined) {
            this.keys = (new ObservableArray(Object.keys(this.values).filter(function (key) { return _this.values[key] instanceof ObservableValue; }), referenceEnhancer, "keys(" + this.name + ")", true));
        }
        return this.keys.slice();
    };
    return ObservableObjectAdministration;
}());
function asObservableObject(target, name, defaultEnhancer) {
    if (name === void 0) { name = ""; }
    if (defaultEnhancer === void 0) { defaultEnhancer = deepEnhancer; }
    var adm = target.$mobx;
    if (adm)
        return adm;
    process.env.NODE_ENV !== "production" &&
        invariant(Object.isExtensible(target), "Cannot make the designated object observable; it is not extensible");
    if (!isPlainObject(target))
        name = (target.constructor.name || "ObservableObject") + "@" + getNextId();
    if (!name)
        name = "ObservableObject@" + getNextId();
    adm = new ObservableObjectAdministration(target, name, defaultEnhancer);
    addHiddenFinalProp(target, "$mobx", adm);
    return adm;
}
function defineObservableProperty(target, propName, newValue, enhancer) {
    var adm = asObservableObject(target);
    assertPropertyConfigurable(target, propName);
    if (hasInterceptors(adm)) {
        var change = interceptChange(adm, {
            object: target,
            name: propName,
            type: "add",
            newValue: newValue
        });
        if (!change)
            return;
        newValue = change.newValue;
    }
    var observable = (adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + "." + propName, false));
    newValue = observable.value; // observableValue might have changed it
    Object.defineProperty(target, propName, generateObservablePropConfig(propName));
    if (adm.keys)
        adm.keys.push(propName);
    notifyPropertyAddition(adm, target, propName, newValue);
}
function defineComputedProperty(target, // which objects holds the observable and provides `this` context?
propName, options) {
    var adm = asObservableObject(target);
    options.name = adm.name + "." + propName;
    options.context = target;
    adm.values[propName] = new ComputedValue(options);
    Object.defineProperty(target, propName, generateComputedPropConfig(propName));
}
var observablePropertyConfigs = Object.create(null);
var computedPropertyConfigs = Object.create(null);
function generateObservablePropConfig(propName) {
    return (observablePropertyConfigs[propName] ||
        (observablePropertyConfigs[propName] = {
            configurable: true,
            enumerable: true,
            get: function () {
                return this.$mobx.read(this, propName);
            },
            set: function (v) {
                this.$mobx.write(this, propName, v);
            }
        }));
}
function getAdministrationForComputedPropOwner(owner) {
    var adm = owner.$mobx;
    if (!adm) {
        // because computed props are declared on proty,
        // the current instance might not have been initialized yet
        initializeInstance(owner);
        return owner.$mobx;
    }
    return adm;
}
function generateComputedPropConfig(propName) {
    return (computedPropertyConfigs[propName] ||
        (computedPropertyConfigs[propName] = {
            configurable: globalState.computedConfigurable,
            enumerable: false,
            get: function () {
                return getAdministrationForComputedPropOwner(this).read(this, propName);
            },
            set: function (v) {
                getAdministrationForComputedPropOwner(this).write(this, propName, v);
            }
        }));
}
function notifyPropertyAddition(adm, object, key, newValue) {
    var notify = hasListeners(adm);
    var notifySpy = isSpyEnabled();
    var change = notify || notifySpy
        ? {
            type: "add",
            object: object,
            name: key,
            newValue: newValue
        }
        : null;
    if (notifySpy)
        spyReportStart(__assign$1(__assign$1({}, change), { name: adm.name, key: key }));
    if (notify)
        notifyListeners(adm, change);
    if (notifySpy)
        spyReportEnd();
}
var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function isObservableObject(thing) {
    if (isObject(thing)) {
        // Initializers run lazily when transpiling to babel, so make sure they are run...
        initializeInstance(thing);
        return isObservableObjectAdministration(thing.$mobx);
    }
    return false;
}

function getAtom(thing, property) {
    if (typeof thing === "object" && thing !== null) {
        if (isObservableArray(thing)) {
            if (property !== undefined)
                fail(process.env.NODE_ENV !== "production" &&
                    "It is not possible to get index atoms from arrays");
            return thing.$mobx.atom;
        }
        if (isObservableSet(thing)) {
            return thing.$mobx;
        }
        if (isObservableMap(thing)) {
            var anyThing = thing;
            if (property === undefined)
                return getAtom(anyThing._keys);
            var observable = anyThing._data.get(property) || anyThing._hasMap.get(property);
            if (!observable)
                fail(process.env.NODE_ENV !== "production" &&
                    "the entry '" + property + "' does not exist in the observable map '" + getDebugName(thing) + "'");
            return observable;
        }
        // Initializers run lazily when transpiling to babel, so make sure they are run...
        initializeInstance(thing);
        if (property && !thing.$mobx)
            thing[property]; // See #1072
        if (isObservableObject(thing)) {
            if (!property)
                return fail(process.env.NODE_ENV !== "production" && "please specify a property");
            var observable = thing.$mobx.values[property];
            if (!observable)
                fail(process.env.NODE_ENV !== "production" &&
                    "no observable property '" + property + "' found on the observable object '" + getDebugName(thing) + "'");
            return observable;
        }
        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
            return thing;
        }
    }
    else if (typeof thing === "function") {
        if (isReaction(thing.$mobx)) {
            // disposer function
            return thing.$mobx;
        }
    }
    return fail(process.env.NODE_ENV !== "production" && "Cannot obtain atom from " + thing);
}
function getAdministration(thing, property) {
    if (!thing)
        fail("Expecting some object");
    if (property !== undefined)
        return getAdministration(getAtom(thing, property));
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing))
        return thing;
    if (isObservableMap(thing) || isObservableSet(thing))
        return thing;
    // Initializers run lazily when transpiling to babel, so make sure they are run...
    initializeInstance(thing);
    if (thing.$mobx)
        return thing.$mobx;
    fail(process.env.NODE_ENV !== "production" && "Cannot obtain administration from " + thing);
}
function getDebugName(thing, property) {
    var named;
    if (property !== undefined)
        named = getAtom(thing, property);
    else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing))
        named = getAdministration(thing);
    else
        named = getAtom(thing); // valid for arrays as well
    return named.name;
}

var toString = Object.prototype.toString;
function deepEqual(a, b, depth) {
    if (depth === void 0) { depth = -1; }
    return eq(a, b, depth);
}
// Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Internal recursive comparison function for `isEqual`.
function eq(a, b, depth, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b)
        return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null)
        return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a)
        return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== "function" && type !== "object" && typeof b != "object")
        return false;
    // Unwrap any wrapped objects.
    a = unwrap(a);
    b = unwrap(b);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b))
        return false;
    switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case "[object RegExp]":
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case "[object String]":
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return "" + a === "" + b;
        case "[object Number]":
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN.
            if (+a !== +a)
                return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case "[object Date]":
        case "[object Boolean]":
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        case "[object Symbol]":
            return (
            // eslint-disable-next-line
            typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b));
    }
    var areArrays = className === "[object Array]";
    if (!areArrays) {
        if (typeof a != "object" || typeof b != "object")
            return false;
        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor &&
            !(typeof aCtor === "function" &&
                aCtor instanceof aCtor &&
                typeof bCtor === "function" &&
                bCtor instanceof bCtor) &&
            ("constructor" in a && "constructor" in b)) {
            return false;
        }
    }
    if (depth === 0) {
        return false;
    }
    else if (depth < 0) {
        depth = -1;
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a)
            return bStack[length] === b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length)
            return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
            if (!eq(a[length], b[length], depth - 1, aStack, bStack))
                return false;
        }
    }
    else {
        // Deep compare objects.
        var keys = Object.keys(a);
        var key = void 0;
        length = keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (Object.keys(b).length !== length)
            return false;
        while (length--) {
            // Deep compare each member
            key = keys[length];
            if (!(has$1(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack)))
                return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
}
function unwrap(a) {
    if (isObservableArray(a))
        return a.peek();
    if (isES6Map(a) || isObservableMap(a))
        return iteratorToArray(a.entries());
    if (isES6Set(a) || isObservableSet(a))
        return iteratorToArray(a.entries());
    return a;
}
function has$1(a, key) {
    return Object.prototype.hasOwnProperty.call(a, key);
}

/*
The only reason for this file to exist is pure horror:
Without it rollup can make the bundling fail at any point in time; when it rolls up the files in the wrong order
it will cause undefined errors (for example because super classes or local variables not being hosted).
With this file that will still happen,
but at least in this file we can magically reorder the imports with trial and error until the build succeeds again.
*/

/**
 * (c) Michel Weststrate 2015 - 2019
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */
try {
    // define process.env if needed
    // if this is not a production build in the first place
    // (in which case the expression below would be substituted with 'production')
    // tslint:disable-next-line
    process.env.NODE_ENV;
}
catch (e) {
    var g = getGlobal();
    if (typeof process === "undefined")
        g.process = {};
    g.process.env = {};
}
(function () {
    function testCodeMinification() { }
    if (testCodeMinification.name !== "testCodeMinification" &&
        process.env.NODE_ENV !== "production" &&
        typeof process !== 'undefined' && process.env.IGNORE_MOBX_MINIFY_WARNING !== "true") {
        // trick so it doesn't get replaced
        var varName = ["process", "env", "NODE_ENV"].join(".");
        console.warn("[mobx] you are running a minified build, but '" + varName + "' was not set to 'production' in your bundler. This results in an unnecessarily large and slow bundle");
    }
})();
// forward compatibility with mobx, so that packages can easily support mobx 4 & 5
var $mobx = "$mobx";
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
    // See: https://github.com/andykog/mobx-devtools/
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
        spy: spy,
        extras: {
            getDebugName: getDebugName
        },
        $mobx: $mobx
    });
}
// TODO: remove in some future build
if (process.env.NODE_ENV !== "production" &&
    typeof module !== "undefined" &&
    typeof module.exports !== "undefined") {
    var warnedAboutDefaultExport_1 = false;
    Object.defineProperty(module.exports, "default", {
        enumerable: false,
        get: function () {
            if (!warnedAboutDefaultExport_1) {
                warnedAboutDefaultExport_1 = true;
                console.warn("The MobX package does not have a default export. Use 'import { thing } from \"mobx\"' (recommended) or 'import * as mobx from \"mobx\"' instead.\"");
            }
            return undefined;
        }
    });
    [
        "extras",
        "Atom",
        "BaseAtom",
        "asFlat",
        "asMap",
        "asReference",
        "asStructure",
        "autorunAsync",
        "createTranformer",
        "expr",
        "isModifierDescriptor",
        "isStrictModeEnabled",
        "map",
        "useStrict",
        "whyRun"
    ].forEach(function (prop) {
        Object.defineProperty(module.exports, prop, {
            enumerable: false,
            get: function () {
                fail("'" + prop + "' is no longer part of the public MobX api. Please consult the changelog to find out where this functionality went");
            },
            set: function () { }
        });
    });
}

var ClosedRange = /** @class */ (function () {
    function ClosedRange(from, to) {
        this.from = from;
        this.to = to;
    }
    ClosedRange.prototype.contains = function (value) {
        return this.from <= value && value <= this.to;
    };
    ClosedRange.prototype.clamp = function (value) {
        return Math.min(Math.max(this.from, value), this.to);
    };
    return ClosedRange;
}());

var AdjustmentsRange = new ClosedRange(-1, 1);
var AdjustmentsStore = /** @class */ (function () {
    function AdjustmentsStore(engineMediator) {
        this.engineMediator = engineMediator;
        this.state = adjustmentsInitialState;
    }
    AdjustmentsStore.prototype.editAdjustments = function (_a) {
        var type = _a.type, value = _a.value;
        var inRangeValue = AdjustmentsRange.clamp(value);
        this.state[type] = inRangeValue;
    };
    AdjustmentsStore.prototype.reset = function () {
        var _this = this;
        runInAction(function () {
            if (_this.indexInContainer === -1) {
                Object.keys(adjustmentsInitialState).forEach(function (key) {
                    _this.state[key] = adjustmentsInitialState[key];
                });
                _this.orderHelper.removeIndex(Tool.ADJUSTMENT);
            }
        });
    };
    Object.defineProperty(AdjustmentsStore.prototype, "indexInContainer", {
        /** Engine methods */
        get: function () {
            if (this.effect) {
                return this.effect.getIndexInParent();
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsStore.prototype, "orderHelper", {
        get: function () {
            return this.engineMediator.orderHelper;
        },
        enumerable: true,
        configurable: true
    });
    AdjustmentsStore.prototype.setAdjustmentEffect = function (adjustments) {
        var index = this.orderHelper.addIndex(Tool.ADJUSTMENT);
        if (this.effect) {
            this.effect.setProperties(adjustments);
        }
        else {
            this.effect = this.engineMediator.engine.addAdjustments(adjustments, this.engineMediator.image.container, index);
        }
        return this.effect.getProperties();
    };
    AdjustmentsStore.prototype.removeAdjustmentEffect = function () {
        if (this.effect) {
            this.engineMediator.engine.removeEffect(this.effect);
            if (this.indexInContainer === -1) {
                this.effect = undefined;
            }
        }
    };
    __decorate([
        observable
    ], AdjustmentsStore.prototype, "state", void 0);
    __decorate([
        action
    ], AdjustmentsStore.prototype, "editAdjustments", null);
    __decorate([
        action
    ], AdjustmentsStore.prototype, "reset", null);
    return AdjustmentsStore;
}());

var EntityMapper = /** @class */ (function () {
    function EntityMapper(assets, config) {
        var _this = this;
        this.assets = [];
        this.withoutItems = function (each) {
            var items = each.items, rest = __rest(each, ["items"]); // eslint-disable-line @typescript-eslint/no-unused-vars
            return rest;
        };
        this.entityMapper = function (entity, index) {
            if (EntityMapper.isCategory(entity)) {
                return _this.categoryMapper(entity, index);
            }
            return _this.itemMapper(entity, index);
        };
        this.categoryMapper = function (category, index) {
            return category
                ? __assign({}, category, { thumbnailURI: _this.getCategoryPath(category), type: CardType.LARGE, delay: index * 0.08, name: _this.config.locale[category.identifier] || category.name, items: category.items.map(_this.itemMapper) }) : null;
        };
        this.itemMapper = function (item, index) {
            return item
                ? __assign({}, item, { thumbnailURI: _this.getItemPath(item), type: CardType.MEDIUM, delay: index * 0.08, name: _this.config.locale[item.identifier] || item.name }) : null;
        };
        this.getCategoryPath = function (category) {
            if (isStickerCategoryDynamic(category) && _this.config.categoryDynamicKey) {
                return category[_this.config.categoryDynamicKey];
            }
            return _this.config.getAssetPath(category[_this.config.categoryKey] || '');
        };
        this.getItemPath = function (item) {
            if (isStickerAssetDynamic(item) && _this.config.itemDynamicKey) {
                return item[_this.config.itemDynamicKey];
            }
            return _this.config.getAssetPath(item[_this.config.itemKey] || '');
        };
        this.config = config;
        this.assets = assets.map(this.entityMapper).filter(Boolean);
    }
    EntityMapper.isCategory = function (entity) {
        return Object.prototype.hasOwnProperty.call(entity, 'items');
    };
    Object.defineProperty(EntityMapper.prototype, "categories", {
        /**
         * Returns all the relevant categories for UI for any given tool
         */
        get: function () {
            return this.assets
                .reduce(function (acc, entity) {
                if (EntityMapper.isCategory(entity)) {
                    return __spread(acc, [entity]);
                }
                return undefined;
            }, [])
                .filter(Boolean);
        },
        enumerable: true,
        configurable: true
    });
    EntityMapper.prototype.getCategories = function (selectedCategoryIdentifier) {
        // important for ui to be updated
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var categoryIndex = this.assets.findIndex(function (asset) { return asset.identifier === selectedCategoryIdentifier; });
        return this.categories;
    };
    Object.defineProperty(EntityMapper.prototype, "items", {
        /**
         * Returns all the relevant items for UI for any given tool
         */
        get: function () {
            return this.assets
                .reduce(function (acc, entity) {
                if (EntityMapper.isCategory(entity)) {
                    return __spread(acc, entity.items);
                }
                return __spread(acc, [entity]);
            }, [])
                .filter(Boolean);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns all the relevant categories for UI for any given tool
     */
    EntityMapper.prototype.itemsOfCategory = function (selectedCategoryIdentifier) {
        var categoryIndex = this.assets.findIndex(function (asset) { return asset.identifier === selectedCategoryIdentifier; });
        if (categoryIndex !== -1) {
            var items = this.categories[categoryIndex].items;
            return items;
        }
        return [];
    };
    /**
     * at a time only one category is selected
     * returns list of categories with items of the selected category injected at proper index
     * @param selectedCategoryIdentifier
     */
    EntityMapper.prototype.getEntities = function (selectedCategoryIdentifier) {
        if (this.config.flattenCategories) {
            return this.items;
        }
        if (selectedCategoryIdentifier) {
            var categoryIndex = this.assets.findIndex(function (asset) { return asset.identifier === selectedCategoryIdentifier; });
            if (categoryIndex !== -1) {
                var items = this.categories[categoryIndex].items;
                return __spread(this.categories.slice(0, categoryIndex + 1), items, this.categories.slice(categoryIndex + 1)).map(this.withoutItems);
            }
        }
        return this.categories.map(this.withoutItems);
    };
    return EntityMapper;
}());

var AdjustmentsToolStore = /** @class */ (function () {
    function AdjustmentsToolStore(editor) {
        var _this = this;
        this.dirty = observable.box(false);
        this.reset = function () {
            _this.pureReset();
            _this.addSnapshot("delete" /* DELETE */, _this.locale.controls.buttonReset);
            _this.editor.render();
        };
        this.editor = editor;
        this.adjustmentsStore = new AdjustmentsStore(this.editor.engineMediator);
        this.selectedOption = '';
        var assets = this.editor.assetProvider.getAssets('adjustment');
        this.entityManager = new EntityMapper(assets, __assign({}, this.config, { flattenCategories: false, categoryKey: '', itemKey: 'thumbnailURI', locale: __assign({}, this.locale.items, this.locale.categories), getAssetPath: this.editor.getAssetPath('adjustment') }));
    }
    AdjustmentsToolStore.prototype.editAdjustments = function (_a) {
        var type = _a.type, value = _a.value;
        this.pureSetAdjustment({ type: type, value: value });
        this.editor.render();
    };
    AdjustmentsToolStore.prototype.toolSnapshot = function () {
        this.dirty.set(true);
        this.addSnapshot("edit" /* EDIT */, Tool.ADJUSTMENT);
    };
    AdjustmentsToolStore.prototype.addSnapshot = function (type, desc) {
        this.editor.addSnapshot(undefined, type, desc);
    };
    AdjustmentsToolStore.prototype.toggleOptionSelection = function (type) {
        this.selectedOption = type;
    };
    AdjustmentsToolStore.prototype.pureSetAdjustment = function (_a) {
        var type = _a.type, value = _a.value;
        var _b;
        var properties = this.adjustmentsStore.setAdjustmentEffect((_b = {}, _b[type] = value, _b));
        this.adjustmentsStore.editAdjustments({ type: type, value: properties[type] });
    };
    AdjustmentsToolStore.prototype.pureReset = function () {
        this.dirty.set(false);
        this.adjustmentsStore.removeAdjustmentEffect();
        this.adjustmentsStore.reset();
        this.selectedOption = '';
    };
    AdjustmentsToolStore.prototype.updateStateFromHistory = function (state) {
        var _this = this;
        runInAction(function () {
            Object.keys(state).forEach(function (key) {
                _this.pureSetAdjustment({ type: key, value: state[key] });
            });
        });
    };
    AdjustmentsToolStore.prototype.updateStateFromSerialization = function (state) {
        this.updateStateFromHistory(state);
    };
    Object.defineProperty(AdjustmentsToolStore.prototype, "selectedAdjustmentType", {
        get: function () {
            return this.selectedOption;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "isDirty", {
        get: function () {
            return this.dirty.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "state", {
        get: function () {
            return this.adjustmentsStore.state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "selectedOptionLabel", {
        get: function () {
            var _this = this;
            var option = this.items.find(function (o) { return (o ? o.identifier === _this.selectedOption : false); });
            return option ? option.name : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "brightness", {
        get: function () {
            return this.state.brightness;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "saturation", {
        get: function () {
            return this.state.saturation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "contrast", {
        get: function () {
            return this.state.contrast;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "gamma", {
        get: function () {
            return this.state.gamma;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "clarity", {
        get: function () {
            return this.state.clarity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "exposure", {
        get: function () {
            return this.state.exposure;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "shadows", {
        get: function () {
            return this.state.shadows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "highlights", {
        get: function () {
            return this.state.highlights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "whites", {
        get: function () {
            return this.state.whites;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "blacks", {
        get: function () {
            return this.state.blacks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "temperature", {
        get: function () {
            return this.state.temperature;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "sharpness", {
        get: function () {
            return this.state.sharpness;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "categories", {
        get: function () {
            return this.entityManager.categories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "items", {
        get: function () {
            return this.entityManager.categories.reduce(function (acc, category) {
                var options = EntityMapper.isCategory(category) ? category.items : [category];
                return __spread(acc, options);
            }, []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "config", {
        get: function () {
            return this.editor.configStore.config[Tool.ADJUSTMENT];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AdjustmentsToolStore.prototype, "locale", {
        get: function () {
            return this.editor.configStore.locale[Tool.ADJUSTMENT];
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        observable
    ], AdjustmentsToolStore.prototype, "selectedOption", void 0);
    __decorate([
        observable
    ], AdjustmentsToolStore.prototype, "dirty", void 0);
    __decorate([
        action
    ], AdjustmentsToolStore.prototype, "editAdjustments", null);
    __decorate([
        action
    ], AdjustmentsToolStore.prototype, "toggleOptionSelection", null);
    __decorate([
        action
    ], AdjustmentsToolStore.prototype, "pureSetAdjustment", null);
    __decorate([
        action
    ], AdjustmentsToolStore.prototype, "pureReset", null);
    __decorate([
        action
    ], AdjustmentsToolStore.prototype, "reset", void 0);
    __decorate([
        action
    ], AdjustmentsToolStore.prototype, "updateStateFromHistory", null);
    __decorate([
        action
    ], AdjustmentsToolStore.prototype, "updateStateFromSerialization", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "selectedAdjustmentType", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "isDirty", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "state", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "selectedOptionLabel", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "brightness", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "saturation", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "contrast", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "gamma", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "clarity", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "exposure", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "shadows", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "highlights", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "whites", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "blacks", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "temperature", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "sharpness", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "categories", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "items", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "config", null);
    __decorate([
        computed
    ], AdjustmentsToolStore.prototype, "locale", null);
    return AdjustmentsToolStore;
}());

var filterInitialState = { identifier: 'identity', intensity: 1, isDuotone: false };

var FilterIntensityRange = new ClosedRange(0, 1);
var FilterStore = /** @class */ (function () {
    function FilterStore(engineMediator) {
        var _this = this;
        this.setEffectProperties = function (_a) {
            var intensity = _a.intensity;
            if (_this.effect) {
                if (_this.state.isDuotone) {
                    // @ts-ignore TS2349
                    _this.effect.setProperties({ colorIntensity: intensity });
                }
                else {
                    // @ts-ignore TS2349
                    _this.effect.setProperties({ intensity: intensity });
                }
                return _this.effect.getProperties();
            }
            return null;
        };
        this.engineMediator = engineMediator;
        this.state = filterInitialState;
    }
    FilterStore.prototype.changeIdentifier = function (identifier) {
        this.state.identifier = identifier;
    };
    FilterStore.prototype.changeIfDuotone = function (isDuotone) {
        this.state.isDuotone = isDuotone;
    };
    FilterStore.prototype.changeIntensity = function (intensity) {
        var inRangeIntensity = FilterIntensityRange.clamp(intensity);
        this.state.intensity = inRangeIntensity;
    };
    FilterStore.prototype.reset = function () {
        if (this.indexInContainer === -1) {
            this.state.identifier = filterInitialState.identifier;
            this.state.intensity = filterInitialState.intensity;
            this.removeIndex();
        }
    };
    Object.defineProperty(FilterStore.prototype, "indexInContainer", {
        /** Engine methods */
        get: function () {
            if (this.effect) {
                return this.effect.getIndexInParent();
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    FilterStore.prototype.setFilterEffect = function (_a) {
        var _this = this;
        var identifier = _a.identifier, intensity = _a.intensity, isDuotone = _a.isDuotone;
        var oldState = this.state;
        this.changeIdentifier(identifier);
        this.changeIntensity(intensity);
        this.changeIfDuotone(isDuotone);
        this.removeFilterEffect();
        var index = this.engineMediator.orderHelper.addIndex(Tool.FILTER);
        if (isDuotone) {
            return new Promise(function (resolve, reject) {
                _this.engineMediator.engine
                    .addDuoToneFilterFromAssets(identifier, _this.engineMediator.image.container, index)
                    .then(function (duotoneEffect) {
                    _this.effect = duotoneEffect;
                    _this.effect.setProperties({ colorIntensity: intensity });
                    resolve();
                })
                    .catch(function (e) {
                    _this.fallbackOnError(oldState);
                    reject(e);
                });
            });
        }
        return new Promise(function (resolve, reject) {
            _this.engineMediator.engine
                .addLUTFilterFromAssets(identifier, _this.engineMediator.image.container, index)
                .then(function (lutfilterEffect) {
                _this.effect = lutfilterEffect;
                _this.effect.setProperties({ intensity: intensity });
                resolve();
            })
                .catch(function (e) {
                _this.fallbackOnError(oldState);
                reject(e);
            });
        });
    };
    FilterStore.prototype.removeFilterEffect = function () {
        if (this.effect) {
            this.engineMediator.engine.removeEffect(this.effect);
            if (this.indexInContainer === -1) {
                this.effect = undefined;
            }
        }
    };
    FilterStore.prototype.removeIndex = function () {
        this.engineMediator.orderHelper.removeIndex(Tool.FILTER);
    };
    FilterStore.prototype.fallbackOnError = function (oldState) {
        this.changeIdentifier(oldState.identifier);
        this.changeIntensity(oldState.intensity);
        if (oldState.identifier === 'identity') {
            this.removeIndex();
        }
    };
    __decorate([
        observable
    ], FilterStore.prototype, "state", void 0);
    __decorate([
        action
    ], FilterStore.prototype, "changeIdentifier", null);
    __decorate([
        action
    ], FilterStore.prototype, "changeIfDuotone", null);
    __decorate([
        action
    ], FilterStore.prototype, "changeIntensity", null);
    __decorate([
        action
    ], FilterStore.prototype, "reset", null);
    return FilterStore;
}());

var initialFolderState = 'identity';
var FilterToolStore = /** @class */ (function () {
    function FilterToolStore(editor) {
        var _this = this;
        this.changeIntensity = function (intensity) {
            var isOptionDuoTone = _this.isOptionDuoTone(_this.identifier);
            var properties = _this.filterStore.setEffectProperties({ intensity: intensity });
            if (properties) {
                var property = isOptionDuoTone ? properties.colorIntensity : properties.intensity;
                _this.filterStore.changeIntensity(property);
                _this.editor.render();
            }
        };
        this.reset = function () {
            _this.pureReset();
            _this.addSnapshot("delete" /* DELETE */, _this.locale.controls.buttonReset);
            _this.editor.render();
        };
        this.editor = editor;
        this.selectedCategory = initialFolderState;
        this.filterStore = new FilterStore(this.editor.engineMediator);
        var config = this.config;
        var assets = this.editor.configStore.assetProvider.getAssets('filter');
        this.entityManager = new EntityMapper(assets, __assign({}, config, { categoryKey: 'thumbnailURI', itemKey: 'thumbnailURI', locale: this.locale.items, getAssetPath: this.editor.getAssetPath('filter') }));
    }
    FilterToolStore.prototype.selectFilter = function (identifier, intensity) {
        if (intensity === void 0) { intensity = 1; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(identifier !== this.identifier)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.filterStore.setFilterEffect({ identifier: identifier, intensity: intensity, isDuotone: this.isOptionDuoTone(identifier) })];
                    case 1:
                        _a.sent();
                        this.editor.render();
                        this.addSnapshot("add" /* ADD */, Tool.FILTER);
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * filter preview is a feature, where you can see how the filter looks like with the image you loaded
     * This function gets called on every new image
     * it checks if, the setting is enabled and gets previews from FilterPreview module
     */
    FilterToolStore.prototype.setImageAndGetPreviews = function () {
        return __awaiter(this, void 0, void 0, function () {
            var image;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.config.enablePreviewThumbnails) return [3 /*break*/, 3];
                        image = this.editor.activeStore.state.image;
                        return [4 /*yield*/, this.editor.previewThumbnails.addImageToContainer(image)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.getAllFilterPreview()];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets all filter previews and update entities and ui
     */
    FilterToolStore.prototype.getAllFilterPreview = function () {
        return __awaiter(this, void 0, void 0, function () {
            var allItems, allImages, config, assets, currentTool;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        allItems = this.entityManager.items.map(function (i) { return ({
                            identifier: i.identifier,
                            isDuotone: _this.isOptionDuoTone(i.identifier),
                        }); });
                        return [4 /*yield*/, this.editor.previewThumbnails.getAllFilterPreviewThumbnails(allItems)];
                    case 1:
                        allImages = _a.sent();
                        return [4 /*yield*/, this.editor.wait()];
                    case 2:
                        _a.sent();
                        config = this.config;
                        assets = this.editor.configStore.assetProvider.getAssets('filter').map(function (a) {
                            return __assign({}, a, { items: a.items.map(function (i) { return (__assign({}, i, { thumbnail: allImages[i.identifier] })); }) });
                        });
                        this.entityManager = new EntityMapper(assets, __assign({}, config, { categoryKey: 'thumbnailURI', itemDynamicKey: 'thumbnail', itemKey: 'thumbnailURI', locale: this.locale.items, getAssetPath: this.editor.getAssetPath('filter') }));
                        currentTool = this.editor.activeStore.tool;
                        this.editor.activeStore.selectTool(Tool.LIBRARY);
                        this.editor.activeStore.selectTool(currentTool);
                        return [2 /*return*/];
                }
            });
        });
    };
    FilterToolStore.prototype.toolSnapshot = function () {
        this.addSnapshot("edit" /* EDIT */, this.locale.controls.sliderIntensity);
    };
    FilterToolStore.prototype.addSnapshot = function (type, desc) {
        this.editor.addSnapshot(undefined, type, desc);
    };
    FilterToolStore.prototype.pureReset = function () {
        this.selectedCategory = initialFolderState;
        this.filterStore.removeFilterEffect();
        this.filterStore.reset();
    };
    FilterToolStore.prototype.toggleCategorySelection = function (identifier) {
        this.selectedCategory = this.selectedCategory === identifier ? initialFolderState : identifier;
    };
    FilterToolStore.prototype.updateStateFromSerialization = function (_a) {
        var identifier = _a.identifier, intensity = _a.intensity;
        var filterAsset = this.doesFilterAssetExist(identifier);
        if (filterAsset) {
            var isDuotone = isDuoToneFilterAsset(filterAsset);
            return this.filterStore.setFilterEffect({ identifier: identifier, intensity: intensity, isDuotone: isDuotone });
        }
        return new Promise(function (resolve, reject) {
            reject(new Error("Filter Asset " + identifier + " doesn't exist"));
        });
    };
    FilterToolStore.prototype.updateStateFromHistory = function (state) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (state.identifier === 'identity') {
                    this.pureReset();
                    return [2 /*return*/, new Promise(function (resolve) {
                            resolve();
                        })];
                }
                return [2 /*return*/, this.filterStore.setFilterEffect(state)];
            });
        });
    };
    Object.defineProperty(FilterToolStore.prototype, "state", {
        get: function () {
            return this.filterStore.state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterToolStore.prototype, "identifier", {
        get: function () {
            return this.state.identifier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterToolStore.prototype, "intensity", {
        get: function () {
            return this.state.intensity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterToolStore.prototype, "isDuotone", {
        get: function () {
            return this.state.isDuotone;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterToolStore.prototype, "selectedCategoryIdentifier", {
        get: function () {
            return this.selectedCategory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterToolStore.prototype, "isOptionSelected", {
        get: function () {
            return this.identifier !== 'identity';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterToolStore.prototype, "config", {
        get: function () {
            return this.editor.configStore.config[Tool.FILTER];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterToolStore.prototype, "locale", {
        get: function () {
            return this.editor.configStore.locale[Tool.FILTER];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterToolStore.prototype, "categories", {
        get: function () {
            return this.entityManager.getCategories(this.selectedCategoryIdentifier);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterToolStore.prototype, "flattenCategories", {
        get: function () {
            return this.config.flattenCategories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FilterToolStore.prototype, "entities", {
        get: function () {
            return this.entityManager.getEntities(this.selectedCategoryIdentifier);
        },
        enumerable: true,
        configurable: true
    });
    FilterToolStore.prototype.doesFilterAssetExist = function (identifier) {
        return this.entityManager.items.find(function (o) { return identifier === o.identifier; });
    };
    FilterToolStore.prototype.isOptionDuoTone = function (identifier) {
        var filter = this.doesFilterAssetExist(identifier);
        if (filter) {
            return isDuoToneFilterAsset(filter);
        }
        return false;
    };
    __decorate([
        observable
    ], FilterToolStore.prototype, "selectedCategory", void 0);
    __decorate([
        action
    ], FilterToolStore.prototype, "selectFilter", null);
    __decorate([
        action
    ], FilterToolStore.prototype, "changeIntensity", void 0);
    __decorate([
        action
    ], FilterToolStore.prototype, "pureReset", null);
    __decorate([
        action
    ], FilterToolStore.prototype, "reset", void 0);
    __decorate([
        action
    ], FilterToolStore.prototype, "toggleCategorySelection", null);
    __decorate([
        action
    ], FilterToolStore.prototype, "updateStateFromSerialization", null);
    __decorate([
        action
    ], FilterToolStore.prototype, "updateStateFromHistory", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "state", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "identifier", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "intensity", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "isDuotone", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "selectedCategoryIdentifier", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "isOptionSelected", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "config", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "locale", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "categories", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "flattenCategories", null);
    __decorate([
        computed
    ], FilterToolStore.prototype, "entities", null);
    return FilterToolStore;
}());

var commonInitialState = { blurRadius: 40, gradientSize: 0.2 };
var linarInitalState = __assign({ start: { x: 0, y: 0 }, end: { x: 0, y: 0 } }, commonInitialState);
var radialInitialState = __assign({ center: { x: 0, y: 0 }, radius: 0 }, commonInitialState);
var mirroredInitialState = __assign({ origin: { x: 0, y: 0 }, rotation: 0, size: 0 }, commonInitialState);
var gaussianInitialState = commonInitialState;
var focusInitialState = {
    identifier: 'identity',
    linear: linarInitalState,
    radial: radialInitialState,
    mirrored: mirroredInitialState,
    gaussian: gaussianInitialState,
};

var FocusStore = /** @class */ (function () {
    function FocusStore(engineMediator) {
        this.engineMediator = engineMediator;
        this.state = focusInitialState;
    }
    FocusStore.prototype.selectFocus = function (identifier, intensity) {
        var _this = this;
        runInAction(function () {
            _this.state.identifier = identifier;
            if (intensity) {
                _this.state[identifier].blurRadius = intensity;
            }
        });
    };
    FocusStore.prototype.changeBlurRadius = function (identifier, blurRadius) {
        if (identifier !== 'identity') {
            this.state[identifier].blurRadius = blurRadius;
        }
    };
    FocusStore.prototype.reset = function () {
        if (this.indexInContainer === -1) {
            this.state.identifier = focusInitialState.identifier;
            // @ts-ignore TS2365
            if (this.state.identifier !== 'identity') {
                this.state[this.state.identifier].blurRadius = focusInitialState[this.state.identifier].blurRadius;
            }
        }
    };
    FocusStore.prototype.setLinear = function (_a) {
        var start = _a.start, end = _a.end;
        this.state.linear.start.x = start.x;
        this.state.linear.start.y = start.y;
        this.state.linear.end.x = end.x;
        this.state.linear.end.y = end.y;
    };
    FocusStore.prototype.setLinearStart = function (start) {
        this.state.linear.start.x = start.x;
        this.state.linear.start.y = start.y;
    };
    FocusStore.prototype.setLinearEnd = function (end) {
        this.state.linear.end.x = end.x;
        this.state.linear.end.y = end.y;
    };
    FocusStore.prototype.setRadialCenter = function (center) {
        this.state.radial.center.x = center.x;
        this.state.radial.center.y = center.y;
    };
    FocusStore.prototype.setRadialRadius = function (radius) {
        this.state.radial.radius = radius;
    };
    FocusStore.prototype.setMirroredOrigin = function (origin) {
        this.state.mirrored.origin.x = origin.x;
        this.state.mirrored.origin.y = origin.y;
    };
    FocusStore.prototype.setMirroredRotation = function (rotation) {
        this.state.mirrored.rotation = rotation;
    };
    FocusStore.prototype.setMirroredSize = function (size) {
        this.state.mirrored.size = size;
    };
    Object.defineProperty(FocusStore.prototype, "indexInContainer", {
        /** Engine methods */
        get: function () {
            if (this.effect) {
                return this.effect.getIndexInParent();
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusStore.prototype, "order", {
        get: function () {
            return this.engineMediator.orderHelper.addIndex(Tool.FOCUS);
        },
        enumerable: true,
        configurable: true
    });
    FocusStore.prototype.setLinearFocus = function (state) {
        this.effect = this.engineMediator.engine.addLinearBlur(state, this.imageContainer, this.order);
        return this.effect.getProperties();
    };
    FocusStore.prototype.getEffectProperties = function () {
        if (this.effect) {
            return this.effect.getProperties();
        }
        return null;
    };
    FocusStore.prototype.setGaussianFocus = function (state) {
        this.effect = this.engineMediator.engine.addGaussianBlur(state, this.imageContainer, this.order);
        return this.effect.getProperties();
    };
    FocusStore.prototype.setRadialFocus = function (state) {
        this.effect = this.engineMediator.engine.addRadialBlur(state, this.imageContainer, this.order);
        return this.effect.getProperties();
    };
    FocusStore.prototype.setMirroredFocus = function (state) {
        this.effect = this.engineMediator.engine.addMirroredBlur(state, this.imageContainer, this.order);
        return this.effect.getProperties();
    };
    FocusStore.prototype.setEffectProperties = function (state) {
        if (this.effect) {
            // @ts-ignore TS2349
            this.effect.setProperties(state);
            return this.effect.getProperties();
        }
        return null;
    };
    FocusStore.prototype.removeFocus = function () {
        if (this.effect) {
            this.engineMediator.engine.removeEffect(this.effect);
            this.engineMediator.orderHelper.removeIndex(Tool.FOCUS);
        }
    };
    Object.defineProperty(FocusStore.prototype, "imageContainer", {
        get: function () {
            return this.engineMediator.image.container;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        observable
    ], FocusStore.prototype, "state", void 0);
    __decorate([
        action
    ], FocusStore.prototype, "selectFocus", null);
    __decorate([
        action
    ], FocusStore.prototype, "changeBlurRadius", null);
    __decorate([
        action
    ], FocusStore.prototype, "reset", null);
    __decorate([
        action
    ], FocusStore.prototype, "setLinear", null);
    __decorate([
        action
    ], FocusStore.prototype, "setLinearStart", null);
    __decorate([
        action
    ], FocusStore.prototype, "setLinearEnd", null);
    __decorate([
        action
    ], FocusStore.prototype, "setRadialCenter", null);
    __decorate([
        action
    ], FocusStore.prototype, "setRadialRadius", null);
    __decorate([
        action
    ], FocusStore.prototype, "setMirroredOrigin", null);
    __decorate([
        action
    ], FocusStore.prototype, "setMirroredRotation", null);
    __decorate([
        action
    ], FocusStore.prototype, "setMirroredSize", null);
    return FocusStore;
}());

/**
 * This function will return a point in the given direction based on the origin point
 */
var getPointInDirection = function (origin, rotation, distance) {
    if (rotation === void 0) { rotation = 0; }
    if (distance === void 0) { distance = 3; }
    var slope = Math.tan(rotation);
    var factor = Math.sqrt(Math.pow(slope, 2) + 1);
    return {
        x: origin.x + distance / factor,
        y: origin.y + (distance * slope) / factor,
    };
};

var flipRotationHorizontally = function (rotation) {
    return 2 * Math.PI - rotation;
};
var flipRotationVertically = function (rotation) {
    return Math.PI - rotation;
};
var applyFlipToRotation = function (_a) {
    var rotation = _a.rotation, flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
    var flippedRotation = rotation;
    if (flipHorizontally) {
        flippedRotation = flipRotationHorizontally(flippedRotation);
    }
    if (flipVertically) {
        flippedRotation = flipRotationVertically(flippedRotation);
    }
    return flippedRotation;
};

var FocusToolStore = /** @class */ (function () {
    function FocusToolStore(editor) {
        var _this = this;
        this.changeIntensity = function (blurRadius) {
            var properties = _this.focusStore.setEffectProperties({ blurRadius: blurRadius });
            if (properties) {
                _this.focusStore.changeBlurRadius(_this.identifier, properties.blurRadius);
                _this.editor.render();
            }
        };
        this.reset = function () {
            _this.pureReset();
            _this.editor.render();
            _this.addSnapshot("delete" /* DELETE */, _this.locale.controls.buttonReset);
        };
        this.editor = editor;
        this.focusStore = new FocusStore(this.editor.engineMediator);
        var assets = this.editor.assetProvider.getAssets('focus');
        this.entityManager = new EntityMapper([
            {
                identifier: '',
                name: '',
                items: assets,
            },
        ], __assign({}, this.config, { categoryKey: '', itemKey: 'thumbnailURI', flattenCategories: true, locale: this.locale.items, getAssetPath: this.editor.getAssetPath('focus') }));
    }
    Object.defineProperty(FocusToolStore, "minIntensity", {
        get: function () {
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    FocusToolStore.doesFocusIdentifierExist = function (identifier) {
        return (Object.keys(FocusIdentifier)
            .map(function (i) { return FocusIdentifier[i]; })
            .findIndex(function (f) { return f === identifier; }) !== -1);
    };
    FocusToolStore.prototype.selectFocus = function (identifier) {
        if (identifier !== this.identifier) {
            this.focusStore.removeFocus();
            var blurRadius = this.maxIntensity * 0.2;
            var width = this.editor.engine.getOutputContainer().getBounds().width;
            var radius = this.editor.shortestOutputSide * 0.2;
            /* eslint-disable no-case-declarations */
            switch (identifier) {
                case FocusIdentifier.LINEAR:
                    var start = this.editor.outputToWorld({ x: -width / 2, y: 0 });
                    var end = this.editor.outputToWorld({ x: width / 2, y: 0 });
                    this.setLinearFocus({ start: start, end: end, blurRadius: blurRadius });
                    break;
                case FocusIdentifier.RADIAL:
                    var center = this.editor.outputToWorld({ x: 0, y: 0 });
                    this.setRadialFocus({ center: center, radius: radius, blurRadius: blurRadius });
                    break;
                case FocusIdentifier.MIRRORED:
                    var mirrorAxisOrigin = this.editor.outputToWorld({ x: 0, y: 0 });
                    var clearAreaWidth = radius;
                    var mirrorAxisDirection = this.editor.outputToWorld(getPointInDirection({ x: 0, y: 0 }, 0));
                    this.setMirroredFocus({ mirrorAxisOrigin: mirrorAxisOrigin, clearAreaWidth: clearAreaWidth, blurRadius: blurRadius, mirrorAxisDirection: mirrorAxisDirection });
                    break;
                case FocusIdentifier.GAUSSIAN:
                    this.setGaussianFocus({ blurRadius: blurRadius });
            }
            /* eslint-enable no-case-declarations */
            this.focusStore.selectFocus(identifier, blurRadius);
            this.editor.render();
            this.addSnapshot("add" /* ADD */, Tool.FOCUS);
        }
    };
    FocusToolStore.prototype.toolSnapshot = function (property) {
        this.addSnapshot("edit" /* EDIT */, property);
    };
    FocusToolStore.prototype.addSnapshot = function (type, desc) {
        this.editor.addSnapshot(undefined, type, desc);
    };
    FocusToolStore.prototype.clickableCanvas = function (isClickable) {
        this.editor.clickableCanvas(isClickable);
    };
    FocusToolStore.prototype.pureReset = function () {
        this.focusStore.removeFocus();
        this.focusStore.reset();
    };
    FocusToolStore.prototype.setStart = function (start) {
        var properties = this.focusStore.setEffectProperties({
            start: this.editor.previewToWorld(start),
        });
        if (properties) {
            this.focusStore.setLinearStart(this.editor.worldToPreview(properties.start));
            this.editor.render();
        }
    };
    FocusToolStore.prototype.setEnd = function (end) {
        var properties = this.focusStore.setEffectProperties({
            end: this.editor.previewToWorld(end),
        });
        if (properties) {
            this.focusStore.setLinearEnd(this.editor.worldToPreview(properties.end));
            this.editor.render();
        }
    };
    FocusToolStore.prototype.setCenter = function (center) {
        var properties = this.focusStore.setEffectProperties({
            center: this.editor.previewToWorld(center),
        });
        if (properties) {
            this.focusStore.setRadialCenter(this.editor.worldToPreview(properties.center));
            this.editor.render();
        }
    };
    FocusToolStore.prototype.setRadius = function (radius) {
        var properties = this.focusStore.setEffectProperties({
            radius: this.editor.previewToWorld(radius),
        });
        if (properties) {
            this.focusStore.setRadialRadius(this.editor.worldToPreview(properties.radius));
            this.editor.render();
        }
    };
    FocusToolStore.prototype.setOrigin = function (origin) {
        var properties = this.focusStore.setEffectProperties({
            mirrorAxisOrigin: this.editor.previewToWorld(origin),
            mirrorAxisDirection: this.editor.previewToWorld(getPointInDirection(origin, this.rotation)),
        });
        if (properties) {
            this.focusStore.setMirroredOrigin(this.editor.worldToPreview(properties.mirrorAxisOrigin));
            this.editor.render();
        }
    };
    FocusToolStore.prototype.setSize = function (size) {
        var properties = this.focusStore.setEffectProperties({
            clearAreaWidth: this.editor.previewToWorld(size),
        });
        if (properties) {
            this.focusStore.setMirroredSize(this.editor.worldToPreview(properties.clearAreaWidth));
            this.editor.render();
        }
    };
    FocusToolStore.prototype.setRotation = function (rotation) {
        var _a = this.editor.outputContainer.getData(), flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
        var properties = this.focusStore.setEffectProperties({
            mirrorAxisDirection: this.editor.previewToWorld(getPointInDirection(this.origin, rotation)),
        });
        if (properties) {
            var flippedRotation = applyFlipToRotation({ rotation: rotation, flipHorizontally: flipHorizontally, flipVertically: flipVertically });
            this.focusStore.setMirroredRotation(flippedRotation);
            this.editor.render();
        }
    };
    /**
     * Whenever there are canvas controls involved,
     * the state for history (undo/redo) has to be relative to the canvas size,
     * because a user could change the screen size in the middle of the application
     * that's why the controls controls (position and size) and in turn the state (position and size state)
     * applied to the engine should be relative to the current canvasSize
     */
    FocusToolStore.prototype.updateStateFromHistory = function (state, relativeTo) {
        var _this = this;
        this.focusStore.removeFocus();
        var magnitude = relativeTo.magnitude;
        runInAction(function () {
            switch (state.identifier) {
                case FocusIdentifier.LINEAR:
                    _this.focusStore.selectFocus(FocusIdentifier.LINEAR);
                    _this.setLinearFocus({
                        start: _this.editor.previewToWorld(new Vector2(state.linear.start).multiply(relativeTo)),
                        end: _this.editor.previewToWorld(new Vector2(state.linear.end).multiply(relativeTo)),
                        blurRadius: state.linear.blurRadius,
                    });
                    break;
                case FocusIdentifier.GAUSSIAN:
                    _this.focusStore.selectFocus(FocusIdentifier.GAUSSIAN);
                    _this.setGaussianFocus({
                        blurRadius: state.gaussian.blurRadius,
                    });
                    break;
                case FocusIdentifier.RADIAL:
                    _this.focusStore.selectFocus(FocusIdentifier.RADIAL);
                    _this.setRadialFocus({
                        center: _this.editor.previewToWorld(new Vector2(state.radial.center).multiply(relativeTo)),
                        radius: _this.editor.previewToWorld(state.radial.radius * magnitude),
                        blurRadius: state.radial.blurRadius,
                    });
                    break;
                case FocusIdentifier.MIRRORED:
                    _this.focusStore.selectFocus(FocusIdentifier.MIRRORED);
                    _this.setMirroredFocus({
                        mirrorAxisOrigin: _this.editor.previewToWorld(new Vector2(state.mirrored.origin).multiply(relativeTo)),
                        clearAreaWidth: _this.editor.previewToWorld(state.mirrored.size * magnitude),
                        blurRadius: state.mirrored.blurRadius,
                        mirrorAxisDirection: _this.editor.previewToWorld(getPointInDirection(state.mirrored.origin, state.mirrored.rotation)),
                    });
                    break;
                case 'identity':
                    _this.pureReset();
                    break;
            }
        });
    };
    /**
     * goto: relativeTo
     */
    FocusToolStore.prototype.updateStateFromSerialization = function (state) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (FocusToolStore.doesFocusIdentifierExist(state.identifier)) {
                    this.updateStateFromHistory(state, Vector2.ONE);
                }
                else {
                    throw new Error("Focus identifier " + state.identifier + " doesn't exist");
                }
                return [2 /*return*/];
            });
        });
    };
    FocusToolStore.prototype.updateCanvasControls = function () {
        var state = this.focusStore.getEffectProperties();
        if (state && this.identifier !== 'identity') {
            switch (this.identifier) {
                case FocusIdentifier.LINEAR:
                    this.updateLinearState(state);
                    break;
                case FocusIdentifier.RADIAL:
                    this.updateRadialState(state);
                    break;
                case FocusIdentifier.MIRRORED:
                    this.updateMirroredState(state);
                    break;
            }
        }
    };
    Object.defineProperty(FocusToolStore.prototype, "state", {
        get: function () {
            return this.focusStore.state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "serializableState", {
        get: function () {
            return {
                identifier: this.identifier,
                linear: {
                    start: toJS(this.state.linear.start),
                    end: toJS(this.state.linear.end),
                    blurRadius: toJS(this.state.linear.blurRadius),
                },
                radial: {
                    center: toJS(this.state.radial.center),
                    radius: toJS(this.state.radial.radius),
                    blurRadius: toJS(this.state.radial.blurRadius),
                },
                mirrored: {
                    origin: toJS(this.state.mirrored.origin),
                    rotation: toJS(this.state.mirrored.rotation),
                    size: toJS(this.state.mirrored.size),
                    blurRadius: toJS(this.state.mirrored.blurRadius),
                },
                gaussian: {
                    blurRadius: toJS(this.state.gaussian.blurRadius),
                },
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Whenever there are canvas controls involved,
     * the state for history (undo/redo) has to be relative to the canvas size,
     * because a user could change the screen size in the middle of the application
     * that's why the controls controls (position and size) and in turn the state (position and size state)
     * applied to the engine should be relative to the current canvasSize
     */
    FocusToolStore.prototype.getFocusStateForHistory = function () {
        var relativeTo = this.editor.canvasStore.sizeVector;
        var linear = this.focusStore.state.linear;
        var radial = this.focusStore.state.radial;
        var mirrored = this.focusStore.state.mirrored;
        var vector = relativeTo;
        var magnitude = vector.magnitude;
        return __assign({}, this.focusStore.state, { linear: __assign({}, linear, { start: new Vector2(linear.start).divide(vector), end: new Vector2(linear.end).divide(vector) }), radial: __assign({}, radial, { center: new Vector2(radial.center).divide(vector), radius: radial.radius / magnitude }), mirrored: __assign({}, mirrored, { origin: new Vector2(mirrored.origin).divide(vector), size: mirrored.size / magnitude }), gaussian: __assign({}, this.focusStore.state.gaussian) });
    };
    Object.defineProperty(FocusToolStore.prototype, "start", {
        /** Linear */
        get: function () {
            return this.focusStore.state.linear.start;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "startOnPreview", {
        get: function () {
            var flipped = this.editor.applyFlipToPreview(this.focusStore.state.linear.start);
            return { x: Math.abs(flipped.x), y: Math.abs(flipped.y) };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "end", {
        get: function () {
            return this.focusStore.state.linear.end;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "endOnPreview", {
        get: function () {
            var flipped = this.editor.applyFlipToPreview(this.focusStore.state.linear.end);
            return { x: Math.abs(flipped.x), y: Math.abs(flipped.y) };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "center", {
        /** Radial */
        get: function () {
            return this.focusStore.state.radial.center;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "radius", {
        get: function () {
            return this.focusStore.state.radial.radius;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "origin", {
        /** Mirrored */
        get: function () {
            return this.focusStore.state.mirrored.origin;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "rotation", {
        get: function () {
            return this.focusStore.state.mirrored.rotation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "rotationOnPreview", {
        get: function () {
            var _a = this.editor.outputContainer.getData(), flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
            return applyFlipToRotation({
                rotation: this.focusStore.state.mirrored.rotation,
                flipHorizontally: flipHorizontally,
                flipVertically: flipVertically,
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "size", {
        get: function () {
            return this.focusStore.state.mirrored.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "mirroredAreaWidth", {
        get: function () {
            var _a = this.editor.canvasStore.canvasSize, width = _a.width, height = _a.height;
            return Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) * 2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "identifier", {
        get: function () {
            return this.state.identifier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "intensity", {
        get: function () {
            if (this.identifier === 'identity') {
                return focusInitialState.gaussian.blurRadius;
            }
            return this.state[this.identifier].blurRadius;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "maxIntensity", {
        get: function () {
            return this.editor.shortestOutputSide / 10;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "isOptionSelected", {
        get: function () {
            return this.identifier !== 'identity';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "config", {
        get: function () {
            return this.editor.configStore.config[Tool.FOCUS];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "locale", {
        get: function () {
            return this.editor.configStore.locale[Tool.FOCUS];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusToolStore.prototype, "entities", {
        get: function () {
            return this.entityManager.items;
        },
        enumerable: true,
        configurable: true
    });
    FocusToolStore.prototype.setLinearFocus = function (_a) {
        var start = _a.start, end = _a.end, blurRadius = _a.blurRadius;
        var linear = this.focusStore.setLinearFocus({ start: start, end: end, blurRadius: blurRadius });
        this.updateLinearState(linear);
    };
    FocusToolStore.prototype.updateLinearState = function (linear) {
        this.focusStore.setLinearStart(this.editor.worldToPreview(linear.start));
        this.focusStore.setLinearEnd(this.editor.worldToPreview(linear.end));
        this.focusStore.changeBlurRadius(this.identifier, linear.blurRadius);
    };
    FocusToolStore.prototype.setRadialFocus = function (_a) {
        var center = _a.center, radius = _a.radius, blurRadius = _a.blurRadius;
        var radial = this.focusStore.setRadialFocus({ center: center, radius: radius, blurRadius: blurRadius });
        this.updateRadialState(radial);
    };
    FocusToolStore.prototype.updateRadialState = function (radial) {
        this.focusStore.setRadialCenter(this.editor.worldToPreview(radial.center));
        this.focusStore.setRadialRadius(this.editor.worldToPreview(radial.radius));
        this.focusStore.changeBlurRadius(this.identifier, radial.blurRadius);
    };
    FocusToolStore.prototype.setMirroredFocus = function (_a) {
        var mirrorAxisOrigin = _a.mirrorAxisOrigin, clearAreaWidth = _a.clearAreaWidth, blurRadius = _a.blurRadius, mirrorAxisDirection = _a.mirrorAxisDirection;
        var mirrored = this.focusStore.setMirroredFocus({
            mirrorAxisOrigin: mirrorAxisOrigin,
            clearAreaWidth: clearAreaWidth,
            blurRadius: blurRadius,
            mirrorAxisDirection: mirrorAxisDirection,
        });
        this.updateMirroredState(mirrored);
    };
    FocusToolStore.prototype.updateMirroredState = function (mirrored) {
        var origin = new Vector2(mirrored.mirrorAxisOrigin);
        var direction = new Vector2(mirrored.mirrorAxisDirection);
        var distance = direction.subtract(origin);
        var rotation = Math.atan2(distance.y, distance.x);
        this.focusStore.setMirroredOrigin(this.editor.worldToPreview(mirrored.mirrorAxisOrigin));
        this.focusStore.setMirroredRotation(rotation);
        this.focusStore.setMirroredSize(this.editor.worldToPreview(mirrored.clearAreaWidth));
        this.focusStore.changeBlurRadius(this.identifier, mirrored.blurRadius);
    };
    FocusToolStore.prototype.setGaussianFocus = function (_a) {
        var blurRadius = _a.blurRadius;
        var gaussian = this.focusStore.setGaussianFocus({ blurRadius: blurRadius });
        this.focusStore.changeBlurRadius(this.identifier, gaussian.blurRadius);
    };
    __decorate([
        action
    ], FocusToolStore.prototype, "selectFocus", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "changeIntensity", void 0);
    __decorate([
        action
    ], FocusToolStore.prototype, "clickableCanvas", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "pureReset", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "reset", void 0);
    __decorate([
        action
    ], FocusToolStore.prototype, "setStart", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "setEnd", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "setCenter", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "setRadius", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "setOrigin", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "setSize", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "setRotation", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "updateStateFromHistory", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "updateStateFromSerialization", null);
    __decorate([
        action
    ], FocusToolStore.prototype, "updateCanvasControls", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "state", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "start", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "startOnPreview", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "end", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "endOnPreview", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "center", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "radius", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "origin", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "rotation", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "rotationOnPreview", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "size", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "mirroredAreaWidth", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "identifier", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "intensity", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "maxIntensity", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "isOptionSelected", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "config", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "locale", null);
    __decorate([
        computed
    ], FocusToolStore.prototype, "entities", null);
    return FocusToolStore;
}());

var overlayInitialState = { identifier: 'identity', opacity: 1, blendMode: BlendMode.LIGHTEN };

var OverlayOpacityRange = new ClosedRange(0, 1);
var OverlayStore = /** @class */ (function () {
    function OverlayStore(engineMediator) {
        this.engineMediator = engineMediator;
        this.state = overlayInitialState;
    }
    OverlayStore.prototype.changeIdentifier = function (identifier) {
        this.state.identifier = identifier;
    };
    OverlayStore.prototype.changeOpacity = function (opacity) {
        var inRangeOpacity = OverlayOpacityRange.clamp(opacity);
        this.state.opacity = inRangeOpacity;
    };
    OverlayStore.prototype.changeBlendMode = function (blendMode) {
        this.state.blendMode = blendMode;
    };
    OverlayStore.prototype.reset = function () {
        if (this.indexInContainer === -1) {
            this.state.identifier = overlayInitialState.identifier;
            this.state.opacity = overlayInitialState.opacity;
            this.state.blendMode = overlayInitialState.blendMode;
            this.removeIndex();
        }
    };
    Object.defineProperty(OverlayStore.prototype, "indexInContainer", {
        /** Engine methods */
        get: function () {
            if (this.effect) {
                return this.effect.getIndexInParent();
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    OverlayStore.prototype.removeOverlayEffect = function () {
        if (this.effect) {
            this.removeIndex();
            this.engineMediator.engine.removeEffect(this.effect);
            this.effect = undefined;
        }
    };
    OverlayStore.prototype.setEffectProperties = function (state) {
        if (this.effect) {
            this.effect.setProperties(state);
            return this.effect.getProperties();
        }
        return null;
    };
    OverlayStore.prototype.setOverlayEffect = function (_a) {
        var _this = this;
        var identifier = _a.identifier, blendMode = _a.blendMode, opacity = _a.opacity;
        var oldState = __assign({}, this.state);
        this.changeIdentifier(identifier);
        this.changeOpacity(opacity);
        this.changeBlendMode(blendMode);
        this.removeOverlayEffect();
        var index = this.engineMediator.orderHelper.addIndex(Tool.OVERLAY);
        return new Promise(function (resolve, reject) {
            _this.engineMediator.engine
                .addOverlayFromAssets(identifier, _this.engineMediator.image.container, index)
                .then(function (overlayEffect) {
                _this.effect = overlayEffect;
                _this.effect.setProperties({ blendMode: blendMode, opacity: opacity });
                resolve();
            })
                .catch(function (e) {
                _this.changeIdentifier(oldState.identifier);
                _this.changeOpacity(oldState.opacity);
                _this.changeBlendMode(oldState.blendMode);
                if (oldState.identifier === 'identity') {
                    _this.removeIndex();
                }
                reject(e);
            });
        });
    };
    OverlayStore.prototype.removeIndex = function () {
        this.engineMediator.orderHelper.removeIndex(Tool.OVERLAY);
    };
    __decorate([
        observable
    ], OverlayStore.prototype, "state", void 0);
    __decorate([
        action
    ], OverlayStore.prototype, "changeIdentifier", null);
    __decorate([
        action
    ], OverlayStore.prototype, "changeOpacity", null);
    __decorate([
        action
    ], OverlayStore.prototype, "changeBlendMode", null);
    __decorate([
        action
    ], OverlayStore.prototype, "reset", null);
    return OverlayStore;
}());

var OverlayToolStore = /** @class */ (function () {
    function OverlayToolStore(editor) {
        var _this = this;
        this.changeOpacity = function (opacity) {
            var properties = _this.overlayStore.setEffectProperties({ opacity: opacity });
            if (properties) {
                _this.overlayStore.changeOpacity(properties.opacity);
                _this.editor.render();
            }
        };
        this.reset = function () {
            _this.pureReset();
            _this.addSnapshot("delete" /* DELETE */, _this.locale.controls.buttonReset);
            _this.editor.render();
        };
        this.editor = editor;
        this.overlayStore = new OverlayStore(this.editor.engineMediator);
        var assets = this.editor.assetProvider.getAssets('overlay');
        var config = this.config;
        this.entityManager = new EntityMapper([
            {
                identifier: '',
                name: '',
                items: assets,
            },
        ], __assign({}, config, { categoryKey: '', itemKey: 'thumbnailURI', flattenCategories: true, locale: this.locale.items, getAssetPath: this.editor.getAssetPath('overlay') }));
    }
    OverlayToolStore.prototype.selectOverlay = function (identifier) {
        return __awaiter(this, void 0, void 0, function () {
            var blendMode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(identifier !== this.identifier)) return [3 /*break*/, 2];
                        blendMode = this.defaultBlendModeForIdentifier(identifier);
                        return [4 /*yield*/, this.overlayStore.setOverlayEffect({ identifier: identifier, opacity: 1, blendMode: blendMode })];
                    case 1:
                        _a.sent();
                        this.addSnapshot("add" /* ADD */, Tool.OVERLAY);
                        this.editor.render();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    OverlayToolStore.prototype.toolSnapshot = function () {
        this.addSnapshot("edit" /* EDIT */, this.locale.controls.sliderOpacity);
    };
    OverlayToolStore.prototype.addSnapshot = function (type, desc) {
        this.editor.addSnapshot(undefined, type, desc);
    };
    OverlayToolStore.prototype.changeBlendMode = function (blendMode) {
        var properties = this.overlayStore.setEffectProperties({ blendMode: blendMode });
        if (properties) {
            this.overlayStore.changeBlendMode(properties.blendMode);
            this.addSnapshot("edit" /* EDIT */, this.locale.controls.carouselBlendMode);
            this.editor.render();
        }
    };
    OverlayToolStore.prototype.pureReset = function () {
        this.overlayStore.removeOverlayEffect();
        this.overlayStore.reset();
    };
    OverlayToolStore.prototype.updateStateFromSerialization = function (state) {
        return __awaiter(this, void 0, void 0, function () {
            var overlayAsset;
            return __generator(this, function (_a) {
                overlayAsset = this.entityManager.items.find(function (i) { return i.identifier === state.identifier; });
                if (overlayAsset) {
                    return [2 /*return*/, this.overlayStore.setOverlayEffect(state)];
                }
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        reject(new Error("Overlay Asset " + state.identifier + " doesn't exist"));
                    })];
            });
        });
    };
    OverlayToolStore.prototype.updateStateFromHistory = function (state) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (state.identifier === 'identity') {
                    this.pureReset();
                    return [2 /*return*/, new Promise(function (resolve) {
                            resolve();
                        })];
                }
                return [2 /*return*/, this.overlayStore.setOverlayEffect(state)];
            });
        });
    };
    Object.defineProperty(OverlayToolStore.prototype, "state", {
        get: function () {
            return this.overlayStore.state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverlayToolStore.prototype, "identifier", {
        get: function () {
            return this.overlayStore.state.identifier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverlayToolStore.prototype, "opacity", {
        get: function () {
            return this.overlayStore.state.opacity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverlayToolStore.prototype, "blendMode", {
        get: function () {
            return this.overlayStore.state.blendMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverlayToolStore.prototype, "isOptionSelected", {
        get: function () {
            return this.identifier !== 'identity';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverlayToolStore.prototype, "config", {
        get: function () {
            return this.editor.configStore.config[Tool.OVERLAY];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverlayToolStore.prototype, "locale", {
        get: function () {
            return this.editor.configStore.locale[Tool.OVERLAY];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverlayToolStore.prototype, "entities", {
        get: function () {
            return this.entityManager.getEntities();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverlayToolStore.prototype, "allBlendModes", {
        get: function () {
            var overlayControlsLocale = this.locale.controls;
            return Object.keys(BlendMode).map(function (key) {
                var identifier = BlendMode[key];
                var localeKey = "blendMode" + identifier.charAt(0).toUpperCase() + identifier.slice(1);
                return {
                    identifier: identifier,
                    value: overlayControlsLocale[localeKey],
                };
            });
        },
        enumerable: true,
        configurable: true
    });
    OverlayToolStore.prototype.defaultBlendModeForIdentifier = function (identifier) {
        var index = this.entityManager.items.findIndex(function (entity) { return entity.identifier === identifier; });
        return index !== -1 ? this.entityManager.items[index].defaultBlendMode : BlendMode.LIGHTEN;
    };
    __decorate([
        action
    ], OverlayToolStore.prototype, "selectOverlay", null);
    __decorate([
        action
    ], OverlayToolStore.prototype, "changeOpacity", void 0);
    __decorate([
        action
    ], OverlayToolStore.prototype, "changeBlendMode", null);
    __decorate([
        action
    ], OverlayToolStore.prototype, "pureReset", null);
    __decorate([
        action
    ], OverlayToolStore.prototype, "reset", void 0);
    __decorate([
        action
    ], OverlayToolStore.prototype, "updateStateFromSerialization", null);
    __decorate([
        action
    ], OverlayToolStore.prototype, "updateStateFromHistory", null);
    __decorate([
        computed
    ], OverlayToolStore.prototype, "state", null);
    __decorate([
        computed
    ], OverlayToolStore.prototype, "identifier", null);
    __decorate([
        computed
    ], OverlayToolStore.prototype, "opacity", null);
    __decorate([
        computed
    ], OverlayToolStore.prototype, "blendMode", null);
    __decorate([
        computed
    ], OverlayToolStore.prototype, "isOptionSelected", null);
    __decorate([
        computed
    ], OverlayToolStore.prototype, "config", null);
    __decorate([
        computed
    ], OverlayToolStore.prototype, "locale", null);
    __decorate([
        computed
    ], OverlayToolStore.prototype, "entities", null);
    __decorate([
        computed
    ], OverlayToolStore.prototype, "allBlendModes", null);
    return OverlayToolStore;
}());

var defaultTintColorId = 'white';
var stickerDefaultState = {
    identifier: 'identity',
    opacity: 1,
    tintColor: ColorObject[defaultTintColorId],
    tintMode: 'none',
    resizeMode: 'keepAspect',
};
var stickerInitialState = {};

/**
 * This module is to create preview thumbnails of a certain effect
 * Currently only Filters
 *
 * Creates a new Engine instance with lesser quality settings
 * Provides sequential resolution of promises to avoid engine errors
 */
var PreviewThumbnails = /** @class */ (function () {
    /**
     * Creates a new Engine instance
     * Can't use the same instance, because engine works with only one base image
     * @param Engineconfiguration
     */
    function PreviewThumbnails(_a) {
        var license = _a.license, assetProvider = _a.assetProvider, crossOrigin = _a.crossOrigin;
        this.crossOrigin = crossOrigin;
        this.engine = new LegacyEngineAdapter({
            license: license,
            crossOrigin: crossOrigin,
            assetProvider: assetProvider,
            downscaleOptions: { maxDimensions: { width: 100, height: 100 } },
        });
    }
    PreviewThumbnails.isImageElement = function (image) {
        return image instanceof HTMLImageElement;
    };
    /**
     * Sequentially takes all the filters and creates previews, one by one,
     * at the end resolves with a promise with all the list of images with identifier
     * @param allFilters
     */
    PreviewThumbnails.prototype.getAllFilterPreviewThumbnails = function (allFilters) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var allImages = {};
            /**
             * Cannot use parallel operations like Promise.all here, because Engine cannot have more than one filter at a time
             * One filter has to be removed before the next one is added
             *
             * Using reduce to sequentially resolve the promises https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/
             */
            allFilters
                .reduce(function (previousPromise, nextItem) { return __awaiter(_this, void 0, void 0, function () {
                var image;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, previousPromise];
                        case 1:
                            image = _a.sent();
                            if (image.identifier) {
                                allImages[image.identifier] = image.imageData;
                            }
                            return [2 /*return*/, this.getFilterPreviewThumbnail(nextItem)];
                    }
                });
            }); }, Promise.resolve({ identifier: '', imageData: '' }))
                .then(function (image) {
                allImages[image.identifier] = image.imageData;
                resolve(allImages);
            })
                .catch(function (e) {
                reject(e);
            });
        });
    };
    /**
     * Given an identifier and type of filter, resolves with a lower quality exported filter image for thumbnail
     */
    PreviewThumbnails.prototype.getFilterPreviewThumbnail = function (_a) {
        var _this = this;
        var identifier = _a.identifier, isDuotone = _a.isDuotone;
        if (identifier !== '') {
            if (this.effect) {
                this.engine.removeEffect(this.effect);
                if (!this.effect.getIndexInParent()) {
                    this.effect = undefined;
                }
            }
            if (isDuotone) {
                return new Promise(function (resolve, reject) {
                    _this.engine
                        .addDuoToneFilterFromAssets(identifier, _this.container)
                        .then(function (duotoneEffect) {
                        duotoneEffect.setProperties({ colorIntensity: 0.5 });
                        _this.effect = duotoneEffect;
                        _this.engine
                            .export(ExportFormat.DATA_URL, ImageFormat.PNG, 0.2)
                            .then(function (imageData) {
                            resolve({ identifier: identifier, imageData: imageData });
                        })
                            .catch(function (e) {
                            reject(e);
                        });
                    })
                        .catch(function (e) {
                        reject(e);
                    });
                });
            }
            return new Promise(function (resolve, reject) {
                _this.engine
                    .addLUTFilterFromAssets(identifier, _this.container)
                    .then(function (lutfilterEffect) {
                    lutfilterEffect.setProperties({ intensity: 1 });
                    _this.effect = lutfilterEffect;
                    _this.engine
                        .export(ExportFormat.DATA_URL, ImageFormat.PNG, 0.2)
                        .then(function (imageData) {
                        resolve({ identifier: identifier, imageData: imageData });
                    })
                        .catch(function (e) {
                        reject(e);
                    });
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        }
        return new Promise(function (resolve) { return resolve({ identifier: '', imageData: '' }); });
    };
    /**
     * Based on image type, loads the image as elemnt or as url
     */
    PreviewThumbnails.prototype.addImageToContainer = function (image) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var imageElement;
            if (PreviewThumbnails.isImageElement(image)) {
                imageElement = image;
                _this.setBackgroundImage(imageElement);
                resolve();
            }
            else {
                _this.getImageElement(image)
                    .then(function (element) {
                    imageElement = element;
                    _this.setBackgroundImage(imageElement);
                    resolve();
                })
                    .catch(function (error) {
                    // eslint-disable-next-line prefer-promise-reject-errors
                    reject({ identifier: 'imageLoading', message: error.message });
                });
            }
        });
    };
    /**
     * Loads image before adding to the image container
     * @param imageUrl
     */
    PreviewThumbnails.prototype.getImageElement = function (imageUrl) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var image = new Image();
            image.addEventListener('load', function () {
                resolve(image);
            });
            image.addEventListener('error', function (error) {
                reject(error);
            });
            image.crossOrigin = _this.crossOrigin;
            image.src = imageUrl;
        });
    };
    PreviewThumbnails.prototype.setBackgroundImage = function (image) {
        if (!this.container) {
            this.container = this.engine.addImage({ image: image, blendMode: BlendMode.NORMAL, opacity: 1 });
        }
        else {
            this.container.setData({ image: image });
        }
        var size = this.container.getBounds().size;
        var outputContainer = this.engine.getOutputContainer();
        outputContainer.setResolution(size);
    };
    return PreviewThumbnails;
}());

var defaultFrameColorId = 'white';
var frameInitialState = {
    identifier: 'identity',
    opacity: 1,
    width: 0,
    color: ColorObject[defaultFrameColorId],
};

var FrameOpacityRange = new ClosedRange(0, 1);
var FrameStore = /** @class */ (function () {
    function FrameStore(engineMediator) {
        this.engineMediator = engineMediator;
        this.state = frameInitialState;
    }
    FrameStore.prototype.changeIdentifier = function (identifier) {
        this.state.identifier = identifier;
    };
    FrameStore.prototype.changeOpacity = function (opacity) {
        var inRangeOpacity = FrameOpacityRange.clamp(opacity);
        this.state.opacity = inRangeOpacity;
    };
    FrameStore.prototype.changeWidth = function (width) {
        this.state.width = width;
    };
    FrameStore.prototype.changeColor = function (color) {
        this.state.color = color;
    };
    FrameStore.prototype.reset = function () {
        if (this.indexInContainer === -1) {
            this.state.identifier = frameInitialState.identifier;
            this.state.opacity = frameInitialState.opacity;
            this.state.width = frameInitialState.width;
            this.state.color = frameInitialState.color;
            this.removeIndex();
        }
    };
    Object.defineProperty(FrameStore.prototype, "engine", {
        /** Engine methods */
        get: function () {
            return this.engineMediator.engine;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameStore.prototype, "imageContainer", {
        get: function () {
            return this.engineMediator.image.container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameStore.prototype, "indexInContainer", {
        get: function () {
            if (this.effect) {
                return this.effect.getIndexInParent();
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    FrameStore.prototype.removeFrameEffect = function () {
        if (this.effect) {
            this.engine.removeEffect(this.effect);
            this.effect = undefined;
        }
    };
    FrameStore.prototype.setEffectProperties = function (state) {
        if (this.effect) {
            this.removeIndex();
            this.effect.setProperties(state);
            return this.effect.getProperties();
        }
        return null;
    };
    FrameStore.prototype.setFrameEffect = function (_a) {
        var _this = this;
        var identifier = _a.identifier, width = _a.width, opacity = _a.opacity, color = _a.color;
        var oldState = __assign({}, this.state);
        this.changeIdentifier(identifier);
        this.changeWidth(width);
        this.changeOpacity(opacity);
        this.changeColor(color);
        this.removeFrameEffect();
        var index = this.engineMediator.orderHelper.addSprite(identifier);
        return new Promise(function (resolve, reject) {
            _this.engine
                .addFrameFromAssets(identifier, _this.engineMediator.image.container, index)
                .then(function (frameEffect) {
                _this.effect = frameEffect;
                _this.effect.setProperties({ tintColor: color, opacity: opacity, width: width });
                resolve();
            })
                .catch(function (e) {
                _this.changeIdentifier(oldState.identifier);
                _this.changeOpacity(oldState.opacity);
                _this.changeWidth(oldState.width);
                _this.changeColor(oldState.color);
                if (oldState.identifier === 'identity') {
                    _this.removeIndex();
                }
                reject(e);
            });
        });
    };
    FrameStore.prototype.removeIndex = function () {
        this.engineMediator.orderHelper.removeSprite(this.state.identifier);
    };
    __decorate([
        observable
    ], FrameStore.prototype, "state", void 0);
    __decorate([
        action
    ], FrameStore.prototype, "changeIdentifier", null);
    __decorate([
        action
    ], FrameStore.prototype, "changeOpacity", null);
    __decorate([
        action
    ], FrameStore.prototype, "changeWidth", null);
    __decorate([
        action
    ], FrameStore.prototype, "changeColor", null);
    __decorate([
        action
    ], FrameStore.prototype, "reset", null);
    return FrameStore;
}());

var FrameToolStore = /** @class */ (function () {
    function FrameToolStore(editor) {
        var _this = this;
        this.activeColorId = observable.box(defaultFrameColorId);
        this.changeOpacity = function (opacity) {
            var properties = _this.frameStore.setEffectProperties({ opacity: opacity });
            if (properties) {
                _this.frameStore.changeOpacity(properties.opacity);
                _this.editor.render();
            }
        };
        this.changeWidth = function (size) {
            var properties = _this.frameStore.setEffectProperties({ width: size });
            if (properties) {
                _this.frameStore.changeWidth(properties.width);
                _this.editor.render();
            }
        };
        this.changeColor = function (tintColor, identifier) {
            var properties = _this.frameStore.setEffectProperties({ tintColor: tintColor });
            if (properties) {
                _this.frameStore.changeColor(properties.tintColor);
                _this.activeColorId.set(identifier);
                _this.editor.render();
            }
        };
        this.colorSnapshot = function () {
            _this.addSnapshot("edit" /* EDIT */, _this.locale.controls.selectColor);
        };
        this.reset = function () {
            _this.pureReset();
            _this.addSnapshot("delete" /* DELETE */, _this.locale.controls.buttonReset);
            _this.editor.render();
        };
        this.editor = editor;
        this.frameStore = new FrameStore(this.editor.engineMediator);
        var assets = this.editor.assetProvider.getAssets('frame');
        var config = this.config;
        this.entityManager = new EntityMapper([
            {
                identifier: '',
                name: '',
                items: assets,
            },
        ], __assign({}, config, { categoryKey: '', itemKey: 'thumbnailURI', flattenCategories: true, locale: this.locale.items, getAssetPath: this.editor.getAssetPath('frame') }));
    }
    Object.defineProperty(FrameToolStore, "colors", {
        get: function () {
            return Editor.defaultColors;
        },
        enumerable: true,
        configurable: true
    });
    FrameToolStore.prototype.selectFrame = function (identifier) {
        return __awaiter(this, void 0, void 0, function () {
            var width;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(identifier !== this.identifier)) return [3 /*break*/, 2];
                        width = 0.1 * this.editor.shortestOutputSide;
                        return [4 /*yield*/, this.frameStore.setFrameEffect({ identifier: identifier, width: width, opacity: 1, color: frameInitialState.color })];
                    case 1:
                        _a.sent();
                        this.editor.render();
                        this.addSnapshot("add" /* ADD */, Tool.FRAME);
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    FrameToolStore.prototype.toolSnapshot = function (property) {
        this.addSnapshot("edit" /* EDIT */, property);
    };
    FrameToolStore.prototype.addSnapshot = function (type, desc) {
        this.editor.addSnapshot(undefined, type, desc);
    };
    FrameToolStore.prototype.pureReset = function () {
        this.frameStore.removeFrameEffect();
        this.frameStore.reset();
    };
    FrameToolStore.prototype.updateStateFromHistory = function (state) {
        if (state.identifier === 'identity') {
            this.pureReset();
            return new Promise(function (resolve) {
                resolve();
            });
        }
        return this.frameStore.setFrameEffect(state);
    };
    FrameToolStore.prototype.updateStateFromSerialization = function (state) {
        return __awaiter(this, void 0, void 0, function () {
            var frameAsset;
            return __generator(this, function (_a) {
                frameAsset = this.entityManager.items.find(function (i) { return i.identifier === state.identifier; });
                if (frameAsset) {
                    return [2 /*return*/, this.frameStore.setFrameEffect(state)];
                }
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        reject(new Error("Frame Asset doesn't exist"));
                    })];
            });
        });
    };
    Object.defineProperty(FrameToolStore.prototype, "state", {
        get: function () {
            return this.frameStore.state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "identifier", {
        get: function () {
            return this.state.identifier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "color", {
        get: function () {
            return this.state.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "activeColor", {
        get: function () {
            return this.activeColorId.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "size", {
        get: function () {
            return this.state.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "tintable", {
        get: function () {
            var _this = this;
            var selected = this.entityManager.items.find(function (option) { return option.identifier === _this.identifier; });
            return (selected && selected.tintable) || false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "opacity", {
        get: function () {
            return this.state.opacity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "minSize", {
        get: function () {
            return this.editor.shortestOutputSide * 0.05;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "maxSize", {
        get: function () {
            return this.editor.shortestOutputSide * 0.3;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "config", {
        get: function () {
            return this.editor.configStore.config[Tool.FRAME];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "locale", {
        get: function () {
            return this.editor.configStore.locale[Tool.FRAME];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "localeColor", {
        get: function () {
            return this.editor.configStore.locale.common.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "entities", {
        get: function () {
            return this.entityManager.getEntities();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FrameToolStore.prototype, "isOptionSelected", {
        get: function () {
            return this.identifier !== 'identity';
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        action
    ], FrameToolStore.prototype, "selectFrame", null);
    __decorate([
        action
    ], FrameToolStore.prototype, "changeOpacity", void 0);
    __decorate([
        action
    ], FrameToolStore.prototype, "changeWidth", void 0);
    __decorate([
        action
    ], FrameToolStore.prototype, "changeColor", void 0);
    __decorate([
        action
    ], FrameToolStore.prototype, "pureReset", null);
    __decorate([
        action
    ], FrameToolStore.prototype, "reset", void 0);
    __decorate([
        action
    ], FrameToolStore.prototype, "updateStateFromHistory", null);
    __decorate([
        action
    ], FrameToolStore.prototype, "updateStateFromSerialization", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "state", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "identifier", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "color", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "activeColor", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "size", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "tintable", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "opacity", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "minSize", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "maxSize", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "config", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "locale", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "localeColor", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "entities", null);
    __decorate([
        computed
    ], FrameToolStore.prototype, "isOptionSelected", null);
    return FrameToolStore;
}());

var defaultColorId = 'white';
var initialBrushState = {
    size: 10,
    color: ColorObject[defaultColorId],
    hardness: 0.5,
};

var BrushToolStore = /** @class */ (function () {
    function BrushToolStore(editor) {
        var _this = this;
        this.dirty = observable.box(false);
        this.id = '';
        this.activeColorId = observable.box(defaultColorId);
        this.containerId = function () {
            return _this.id;
        };
        this.changeColor = function (color, identifier) {
            _this.state.color = color;
            _this.activeColorId.set(identifier);
        };
        this.changeSize = function (size) {
            _this.state.size = size;
        };
        this.changeHardness = function (hardness) {
            _this.state.hardness = hardness;
        };
        this.reset = function () {
            _this.pureReset();
            _this.addSnapshot("delete" /* DELETE */, _this.locale.controls.buttonReset);
            _this.editor.render();
        };
        this.editor = editor;
        this.state = initialBrushState;
    }
    Object.defineProperty(BrushToolStore, "colors", {
        get: function () {
            return Editor.defaultColors;
        },
        enumerable: true,
        configurable: true
    });
    BrushToolStore.prototype.addSnapshot = function (type, desc) {
        this.editor.addSnapshot(undefined, type, desc);
    };
    BrushToolStore.prototype.clickableCanvas = function (isClickable) {
        this.editor.clickableCanvas(isClickable);
    };
    BrushToolStore.prototype.beginStroke = function (strokes) {
        if (strokes === void 0) { strokes = []; }
        if (!this.drawingContainer) {
            var index = this.editor.orderHelper.addSprite(Tool.BRUSH);
            this.drawingContainer = this.editor.engine.addDrawing({ strokes: strokes }, this.editor.imageContainer, index);
        }
        this.id = this.drawingContainer.getID();
        this.drawingContainer.beginStroke({
            id: 'imgly_brush_radial',
            color: toJS(this.state.color),
            size: this.state.size,
            hardness: this.state.hardness,
        });
    };
    BrushToolStore.prototype.strokePosition = function (position) {
        if (this.drawingContainer) {
            var worldPosition = this.editor.previewToWorld(position, false);
            this.drawingContainer.addPointToCurrentStroke(worldPosition);
            this.editor.render();
        }
    };
    BrushToolStore.prototype.endStroke = function () {
        if (this.drawingContainer) {
            this.drawingContainer.endStroke();
            this.editor.render();
            this.strokes = this.drawingContainer.getData();
            this.addSnapshot("edit" /* EDIT */, '');
            this.dirty.set(true);
        }
    };
    BrushToolStore.prototype.updateStateFromHistory = function (strokes) {
        strokes = strokes || { strokes: [] };
        if (this.drawingContainer) {
            this.strokes = strokes;
            this.drawingContainer.setData(this.strokes);
            if (strokes.strokes.length !== 0) {
                this.dirty.set(true);
            }
        }
        else {
            var index = this.editor.orderHelper.addSprite(Tool.BRUSH);
            this.drawingContainer = this.editor.engine.addDrawing({ strokes: strokes.strokes }, this.editor.imageContainer, index);
            this.strokes = this.drawingContainer.getData();
        }
        this.id = this.drawingContainer.getID();
    };
    BrushToolStore.prototype.pureReset = function () {
        this.dirty.set(false);
        this.strokes = { strokes: [] };
        if (this.drawingContainer) {
            this.editor.engine.removeContainer(this.drawingContainer);
            this.drawingContainer = undefined;
        }
    };
    Object.defineProperty(BrushToolStore.prototype, "config", {
        get: function () {
            return this.editor.configStore.config[Tool.BRUSH];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrushToolStore.prototype, "locale", {
        get: function () {
            return this.editor.configStore.locale[Tool.BRUSH];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrushToolStore.prototype, "localeColor", {
        get: function () {
            return this.editor.configStore.locale.common.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrushToolStore.prototype, "color", {
        get: function () {
            return this.state.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrushToolStore.prototype, "activeColor", {
        get: function () {
            return this.activeColorId.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrushToolStore.prototype, "size", {
        get: function () {
            return this.state.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrushToolStore.prototype, "sizeOnScreenSpace", {
        get: function () {
            return this.editor.worldToPreview(this.state.size);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrushToolStore.prototype, "hardness", {
        get: function () {
            return this.state.hardness;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrushToolStore.prototype, "isDirty", {
        get: function () {
            return this.dirty.get();
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        observable
    ], BrushToolStore.prototype, "state", void 0);
    __decorate([
        observable
    ], BrushToolStore.prototype, "dirty", void 0);
    __decorate([
        action
    ], BrushToolStore.prototype, "changeColor", void 0);
    __decorate([
        action
    ], BrushToolStore.prototype, "changeSize", void 0);
    __decorate([
        action
    ], BrushToolStore.prototype, "changeHardness", void 0);
    __decorate([
        action
    ], BrushToolStore.prototype, "clickableCanvas", null);
    __decorate([
        action
    ], BrushToolStore.prototype, "beginStroke", null);
    __decorate([
        action
    ], BrushToolStore.prototype, "strokePosition", null);
    __decorate([
        action
    ], BrushToolStore.prototype, "endStroke", null);
    __decorate([
        action
    ], BrushToolStore.prototype, "updateStateFromHistory", null);
    __decorate([
        action
    ], BrushToolStore.prototype, "reset", void 0);
    __decorate([
        computed
    ], BrushToolStore.prototype, "config", null);
    __decorate([
        computed
    ], BrushToolStore.prototype, "locale", null);
    __decorate([
        computed
    ], BrushToolStore.prototype, "localeColor", null);
    __decorate([
        computed
    ], BrushToolStore.prototype, "color", null);
    __decorate([
        computed
    ], BrushToolStore.prototype, "activeColor", null);
    __decorate([
        computed
    ], BrushToolStore.prototype, "size", null);
    __decorate([
        computed
    ], BrushToolStore.prototype, "sizeOnScreenSpace", null);
    __decorate([
        computed
    ], BrushToolStore.prototype, "hardness", null);
    __decorate([
        computed
    ], BrushToolStore.prototype, "isDirty", null);
    return BrushToolStore;
}());

var defaultCropState = {
    position: { x: 0, y: 0 },
    size: { height: 0, width: 0 },
    lockResolution: false,
    forceDimensions: false,
    ratio: '*',
    isRatioFlipped: false,
};
var initialTransformState = {
    identifier: 'identity',
    outputRotation: 0,
    rotationInDegrees: 0,
    flipHorizontally: false,
    flipVertically: false,
    cropState: observable.map({}),
};

var TransformStore = /** @class */ (function () {
    function TransformStore(editor) {
        this.minCropSize = 0;
        this.state = initialTransformState;
        this.configStore = editor.configStore;
        this.minCropSize = this.configStore.measurements.crop.minSize;
    }
    TransformStore.prototype.changeIdentifier = function (identifier) {
        this.state.identifier = identifier;
        var crop = this.state.cropState.get(identifier);
        if (!crop) {
            this.state.cropState.set(identifier, __assign({}, defaultCropState));
        }
    };
    TransformStore.prototype.changeRatio = function (ratio) {
        var crop = this.state.cropState.get(this.identifier);
        if (crop) {
            this.state.cropState.set(this.identifier, __assign({}, crop, { ratio: ratio }));
        }
    };
    TransformStore.prototype.flipRatio = function () {
        var crop = this.state.cropState.get(this.identifier);
        if (crop) {
            this.state.cropState.set(this.identifier, __assign({}, crop, { isRatioFlipped: !crop.isRatioFlipped }));
        }
    };
    TransformStore.prototype.changeSize = function (size) {
        var crop = this.state.cropState.get(this.identifier);
        if (crop) {
            if (size.width && size.width > 0) {
                crop.size.width = Math.floor(size.width);
            }
            if (size.height && size.height > 0) {
                crop.size.height = Math.floor(size.height);
            }
            this.state.cropState.set(this.identifier, crop);
        }
    };
    TransformStore.prototype.changeHeight = function (height) {
        var crop = this.state.cropState.get(this.identifier);
        if (crop) {
            if (height) {
                crop.size.height = Math.floor(height);
                this.state.cropState.set(this.identifier, crop);
            }
        }
    };
    TransformStore.prototype.changeWidth = function (width) {
        var crop = this.state.cropState.get(this.identifier);
        if (crop) {
            if (width) {
                crop.size.width = Math.floor(width);
                this.state.cropState.set(this.identifier, crop);
            }
        }
    };
    TransformStore.prototype.changePositionX = function (x, maxWidth) {
        var crop = this.state.cropState.get(this.identifier);
        if (crop && x <= maxWidth - this.minCropSize && x >= 0) {
            crop.position.x = Math.floor(x);
            this.state.cropState.set(this.identifier, crop);
            return true;
        }
        return false;
    };
    TransformStore.prototype.changePositionY = function (y, maxHeight) {
        var crop = this.state.cropState.get(this.identifier);
        if (crop && y <= maxHeight - this.minCropSize && y >= 0) {
            crop.position.y = Math.floor(y);
            this.state.cropState.set(this.identifier, crop);
            return true;
        }
        return false;
    };
    TransformStore.prototype.changePosition = function (position, maxSize) {
        var crop = this.state.cropState.get(this.identifier);
        if (crop) {
            if (position.x <= maxSize.width - this.minCropSize &&
                position.x >= 0 &&
                position.y <= maxSize.height - this.minCropSize &&
                position.y >= 0) {
                crop.position.x = Math.floor(position.x);
                crop.position.y = Math.floor(position.y);
                this.state.cropState.set(this.identifier, crop);
                return true;
            }
        }
        return false;
    };
    TransformStore.prototype.changeLockResolution = function (lockResolution) {
        var crop = this.state.cropState.get(this.identifier);
        if (crop) {
            crop.lockResolution = lockResolution !== undefined ? lockResolution : !crop.lockResolution;
            this.state.cropState.set(this.identifier, crop);
        }
    };
    TransformStore.prototype.changeForceDimensions = function (forceDimensions) {
        var crop = this.state.cropState.get(this.identifier);
        if (crop) {
            crop.forceDimensions = forceDimensions;
            this.state.cropState.set(this.identifier, crop);
        }
    };
    TransformStore.prototype.setRotation = function (rotation) {
        this.state.rotationInDegrees = rotation;
    };
    TransformStore.prototype.resetRotation = function () {
        this.state.rotationInDegrees = 0;
    };
    TransformStore.prototype.resetOutputRotation = function () {
        this.state.outputRotation = 0;
    };
    TransformStore.prototype.resetFlip = function () {
        this.state.flipHorizontally = false;
        this.state.flipVertically = false;
    };
    TransformStore.prototype.updateFlip = function (_a) {
        var flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
        this.state.flipHorizontally = flipHorizontally;
        this.state.flipVertically = flipVertically;
    };
    TransformStore.prototype.setOutputRotation = function (rotation) {
        this.state.outputRotation = rotation;
    };
    TransformStore.prototype.flipHorizontally = function () {
        this.state.flipHorizontally = !this.state.flipHorizontally;
    };
    TransformStore.prototype.flipVertically = function () {
        this.state.flipVertically = !this.state.flipVertically;
    };
    Object.defineProperty(TransformStore.prototype, "identifier", {
        get: function () {
            return this.state.identifier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "height", {
        get: function () {
            return this.selectedCrop ? this.selectedCrop.size.height : defaultCropState.size.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "width", {
        get: function () {
            return this.selectedCrop ? this.selectedCrop.size.width : defaultCropState.size.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "position", {
        get: function () {
            return this.selectedCrop ? this.selectedCrop.position : defaultCropState.position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "ratio", {
        get: function () {
            return this.selectedCrop ? this.selectedCrop.ratio : defaultCropState.ratio;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "isRatioFlipped", {
        get: function () {
            return this.selectedCrop ? this.selectedCrop.isRatioFlipped : defaultCropState.isRatioFlipped;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "size", {
        get: function () {
            return this.selectedCrop ? this.selectedCrop.size : defaultCropState.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "x", {
        get: function () {
            return this.selectedCrop ? this.selectedCrop.position.x : defaultCropState.position.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "y", {
        get: function () {
            return this.selectedCrop ? this.selectedCrop.position.y : defaultCropState.position.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "lockResolution", {
        get: function () {
            return this.selectedCrop ? this.selectedCrop.lockResolution : defaultCropState.lockResolution;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "forceDimensions", {
        get: function () {
            return this.selectedCrop ? this.selectedCrop.forceDimensions : defaultCropState.forceDimensions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "selectedCrop", {
        get: function () {
            return this.state.cropState.get(this.identifier);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "rotationInDegrees", {
        get: function () {
            return this.state.rotationInDegrees;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformStore.prototype, "outputRotation", {
        get: function () {
            return this.state.outputRotation;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        observable
    ], TransformStore.prototype, "state", void 0);
    __decorate([
        action
    ], TransformStore.prototype, "changeIdentifier", null);
    __decorate([
        action
    ], TransformStore.prototype, "changeRatio", null);
    __decorate([
        action
    ], TransformStore.prototype, "flipRatio", null);
    __decorate([
        action
    ], TransformStore.prototype, "changeSize", null);
    __decorate([
        action
    ], TransformStore.prototype, "changeHeight", null);
    __decorate([
        action
    ], TransformStore.prototype, "changeWidth", null);
    __decorate([
        action
    ], TransformStore.prototype, "changePositionX", null);
    __decorate([
        action
    ], TransformStore.prototype, "changePositionY", null);
    __decorate([
        action
    ], TransformStore.prototype, "changePosition", null);
    __decorate([
        action
    ], TransformStore.prototype, "changeLockResolution", null);
    __decorate([
        action
    ], TransformStore.prototype, "changeForceDimensions", null);
    __decorate([
        action
    ], TransformStore.prototype, "setRotation", null);
    __decorate([
        action
    ], TransformStore.prototype, "resetRotation", null);
    __decorate([
        action
    ], TransformStore.prototype, "resetOutputRotation", null);
    __decorate([
        action
    ], TransformStore.prototype, "resetFlip", null);
    __decorate([
        action
    ], TransformStore.prototype, "updateFlip", null);
    __decorate([
        action
    ], TransformStore.prototype, "setOutputRotation", null);
    __decorate([
        action
    ], TransformStore.prototype, "flipHorizontally", null);
    __decorate([
        action
    ], TransformStore.prototype, "flipVertically", null);
    __decorate([
        computed
    ], TransformStore.prototype, "identifier", null);
    __decorate([
        computed
    ], TransformStore.prototype, "height", null);
    __decorate([
        computed
    ], TransformStore.prototype, "width", null);
    __decorate([
        computed
    ], TransformStore.prototype, "position", null);
    __decorate([
        computed
    ], TransformStore.prototype, "ratio", null);
    __decorate([
        computed
    ], TransformStore.prototype, "isRatioFlipped", null);
    __decorate([
        computed
    ], TransformStore.prototype, "size", null);
    __decorate([
        computed
    ], TransformStore.prototype, "x", null);
    __decorate([
        computed
    ], TransformStore.prototype, "y", null);
    __decorate([
        computed
    ], TransformStore.prototype, "lockResolution", null);
    __decorate([
        computed
    ], TransformStore.prototype, "forceDimensions", null);
    __decorate([
        computed
    ], TransformStore.prototype, "selectedCrop", null);
    __decorate([
        computed
    ], TransformStore.prototype, "rotationInDegrees", null);
    __decorate([
        computed
    ], TransformStore.prototype, "outputRotation", null);
    return TransformStore;
}());

function isMergeableObject(val) {
    var nonNullObject = val && typeof val === 'object';
    return (nonNullObject &&
        Object.prototype.toString.call(val) !== '[object RegExp]' &&
        Object.prototype.toString.call(val) !== '[object Date]');
}
function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
function cloneIfNecessary(value, optionsArgument) {
    var clone = optionsArgument && optionsArgument.clone === true;
    return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
}
function mergeObject(target, source, optionsArgument) {
    var destination = {};
    if (isMergeableObject(target)) {
        Object.keys(target).forEach(function (key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
        });
    }
    Object.keys(source).forEach(function (key) {
        var shouldMerge = isMergeableObject(source[key]) && target[key];
        destination[key] = shouldMerge
            ? deepmerge(target[key], source[key], optionsArgument)
            : cloneIfNecessary(source[key], optionsArgument);
    });
    return destination;
}
function deepmerge(target, source, optionsArgument) {
    var array = Array.isArray(source);
    if (array) {
        return Array.isArray(target) ? source : cloneIfNecessary(source, optionsArgument);
    }
    return mergeObject(target, source, optionsArgument);
}
function deepmergeAll(array, optionsArgument) {
    if (optionsArgument === void 0) { optionsArgument = null; }
    if (!Array.isArray(array) || array.length < 2) {
        throw new Error('first argument should be an array with at least two elements');
    }
    return array.reduce(function (prev, next) {
        return deepmerge(prev, next, optionsArgument);
    });
}

var UIEventEmitter = /** @class */ (function (_super) {
    __extends(UIEventEmitter, _super);
    function UIEventEmitter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UIEventEmitter.prototype.onExport = function (imageElement) {
        this.emit(UIEvent.EXPORT, imageElement);
    };
    UIEventEmitter.prototype.onClose = function () {
        this.emit(UIEvent.CLOSE);
    };
    UIEventEmitter.prototype.onHistoryChange = function () {
        this.emit(UIEvent.HISTORY_CHANGE);
    };
    UIEventEmitter.prototype.onEditorReady = function () {
        this.emit(UIEvent.EDITOR_READY);
    };
    return UIEventEmitter;
}(EventEmitter));

// Identifiers are in snake case
/* eslint-disable  @typescript-eslint/camelcase */
var en = {
    common: {
        error: 'Error',
        warning: 'Warning',
        color: {
            colorPicker: {
                hex: 'Hex',
                r: 'R',
                g: 'G',
                b: 'B',
                sliderHue: 'Color',
                sliderOpacity: 'Color Opacity',
            },
        },
    },
    mainCanvasActions: {
        buttonExport: 'Export Image',
        buttonUndo: 'Undo',
        buttonRedo: 'Redo',
        buttonClose: 'Close',
    },
    infoModals: {
        exporting: {
            heading: 'Exporting...',
            body: 'Just a few seconds...',
        },
        saving: {
            heading: 'Saving...',
            body: 'Just a few seconds...',
        },
        loading: {
            heading: 'Loading...',
            body: 'Just a few seconds...',
        },
        resizing: {
            heading: 'Resizing...',
            body: 'Just a few seconds...',
        },
        loadingFonts: {
            heading: 'Loading Fonts...',
            body: 'Just a few seconds...',
        },
    },
    errorModals: {
        imageLoading: {
            body: 'Failed to load image. This can have multiple reasons, e.g. the file is corrupted or the file type is not supported',
            buttonYes: 'Reload',
        },
        rendering: {
            body: 'An error has occurred while rendering the image',
            buttonYes: 'Reload',
        },
        fontLoading: {
            heading: 'Failed to load font',
            // eslint-disable-next-line no-template-curly-in-string
            body: 'The following fonts could not be loaded: ${error}',
            buttonNo: 'Close',
        },
        webcamUnavailable: {
            // eslint-disable-next-line no-template-curly-in-string
            body: 'Unable to display webcam image (Error: ${error})',
            buttonYes: 'Close',
        },
        stickerLoading: {
            body: 'Unable to load the sticker',
            buttonNo: 'Close',
        },
        unsupportedSerializationVersion: {
            body: 'Serialization version is not supported',
            buttonNo: 'Close',
        },
        unexpectedError: {
            // eslint-disable-next-line no-template-curly-in-string
            body: 'An unexpected error has occured ${error}',
            buttonYes: 'Reload',
        },
    },
    warningModals: {
        imageResized: {
            heading: 'Image resized',
            // eslint-disable-next-line no-template-curly-in-string
            body: 'Your image has been resized to ${width}x${height} pixels',
        },
        discardChanges: {
            body: 'You have unsaved changes. Are you sure you want to discard the changes?',
            buttonYes: 'Discard changes',
            buttonNo: 'Keep Changes',
        },
        unsavedChanges: {
            body: 'You have unsaved changes. Are you sure you want to exit?',
            buttonYes: 'Exit without saving',
            buttonNo: 'Cancel',
        },
    },
    library: {
        title: 'Library',
        controls: {
            buttonUpload: 'Upload Image',
            buttonWebcamOpen: 'Open Webcam',
            buttonWebcamClose: 'Close Webcam',
            placeholderSearch: 'Search Library',
            noResults: 'No Results',
        },
    },
    filter: {
        title: 'Filters',
        controls: {
            buttonReset: 'Remove Filter',
            sliderIntensity: 'Filter Intensity',
        },
        categories: {
            imgly_filter_category_duotone: 'DuoTone',
            imgly_filter_category_bw: 'B & W',
            imgly_filter_category_vintage: 'Vintage',
            imgly_filter_category_smooth: 'Smooth',
            imgly_filter_category_cold: 'Cold',
            imgly_filter_category_warm: 'Warm',
            imgly_filter_category_legacy: 'Legacy',
        },
        items: {
            imgly_lut_celsius: 'Inferno',
            imgly_lut_chest: 'Chestnut',
            imgly_lut_fixie: 'Fixie',
            imgly_lut_fridge: 'Fridge',
            imgly_lut_front: 'Sunny 70s',
            imgly_lut_k2: 'Flat Black',
            imgly_lut_mellow: 'Mellow',
            imgly_lut_sin: 'Hard Stuff',
            imgly_lut_texas: 'Oldtimer',
            imgly_lut_ad1920: '1920 A.D.',
            imgly_lut_ancient: 'Ancient',
            imgly_lut_bleached: 'Kalmen',
            imgly_lut_bleachedblue: 'Joran',
            imgly_lut_blues: 'Polaroid',
            imgly_lut_blueshadows: 'Zephyr',
            imgly_lut_breeze: 'Levante',
            imgly_lut_bw: 'Greyed',
            imgly_lut_classic: 'Classic',
            imgly_lut_colorful: 'Colorful',
            imgly_lut_cool: 'Snappy',
            imgly_lut_cottoncandy: 'Candy',
            imgly_lut_creamy: 'Creamy',
            imgly_lut_eighties: 'Low Fire',
            imgly_lut_elder: 'Colla',
            imgly_lut_evening: 'Sunrise',
            imgly_lut_fall: 'Moss',
            imgly_lut_food: 'Food',
            imgly_lut_glam: 'Glam',
            imgly_lut_gobblin: 'Gobblin',
            imgly_lut_highcarb: 'High Carb',
            imgly_lut_highcontrast: 'Hicon',
            imgly_lut_k1: 'K1',
            imgly_lut_k6: 'K6',
            imgly_lut_kdynamic: 'Pebble',
            imgly_lut_keen: 'Keen',
            imgly_lut_lenin: 'Lemon',
            imgly_lut_litho: 'Litho',
            imgly_lut_lomo: 'Lomo',
            imgly_lut_lomo100: 'Lomo 100',
            imgly_lut_lucid: 'Lucid',
            imgly_lut_neat: 'Neat',
            imgly_lut_nogreen: 'Pumpkin',
            imgly_lut_orchid: 'Solanus',
            imgly_lut_pale: 'Pale',
            imgly_lut_pitched: 'Pitched',
            imgly_lut_plate: 'Weathered',
            imgly_lut_pola669: 'Green Gap',
            imgly_lut_polasx: 'Pola SX',
            imgly_lut_pro400: 'Pro 400',
            imgly_lut_quozi: 'Quozi',
            imgly_lut_sepiahigh: 'Sepia',
            imgly_lut_settled: 'Settled',
            imgly_lut_seventies: 'Seventies',
            imgly_lut_soft: 'Soft',
            imgly_lut_steel: 'Steel',
            imgly_lut_summer: 'Summer',
            imgly_lut_sunset: 'Golden',
            imgly_lut_tender: 'Tender',
            imgly_lut_twilight: 'Twilight',
            imgly_lut_winter: 'Softy',
            imgly_lut_x400: 'Dusty',
            imgly_duotone_desert: 'Desert',
            imgly_duotone_peach: 'Peach',
            imgly_duotone_clash: 'Clash',
            imgly_duotone_plum: 'Plum',
            imgly_duotone_breezy: 'Breezy',
            imgly_duotone_deepblue: 'Deep Blue',
            imgly_duotone_frog: 'Frog',
            imgly_duotone_sunset: 'Sunset',
        },
    },
    adjustment: {
        title: 'Adjust',
        controls: {
            buttonReset: 'Reset Adjustment',
        },
        categories: {
            basics: 'Basic',
            refinements: 'Refinements',
        },
        items: {
            brightness: 'Brightness',
            saturation: 'Saturation',
            contrast: 'Contrast',
            gamma: 'Gamma',
            sharpness: 'Sharpness',
            clarity: 'Clarity',
            exposure: 'Exposure',
            shadows: 'Shadows',
            highlights: 'Highlights',
            whites: 'Whites',
            blacks: 'Blacks',
            temperature: 'Temperature',
        },
    },
    focus: {
        title: 'Focus',
        controls: {
            buttonReset: 'Remove Focus',
            sliderIntensity: 'Focus Intensity',
        },
        items: {
            radial: 'Radial',
            mirrored: 'Mirrored',
            linear: 'Linear',
            gaussian: 'Gaussian',
        },
        history: {
            focusPosition: 'Focus Position',
            focusSize: 'Focus Size',
        },
    },
    overlay: {
        title: 'Overlays',
        controls: {
            buttonReset: 'Remove Overlay',
            sliderOpacity: 'Overlay Opacity',
            carouselBlendMode: 'Overlay Blend mode',
            blendModeNormal: 'Normal',
            blendModeOverlay: 'Overlay',
            blendModeHardLight: 'Hard Light',
            blendModeSoftLight: 'Soft Light',
            blendModeMultiply: 'Multiply',
            blendModeDarken: 'Darken',
            blendModeLighten: 'Lighten',
            blendModeScreen: 'Screen',
            blendModeColorBurn: 'Color Burn',
            tabOpacity: 'Opacity',
            tabBlendMode: 'Blend Mode',
        },
        items: {
            imgly_overlay_bokeh: 'Bokeh',
            imgly_overlay_chop: 'Chop',
            imgly_overlay_clouds: 'Clouds',
            imgly_overlay_golden: 'Golden',
            imgly_overlay_grain: 'Grain',
            imgly_overlay_hearts: 'Hearts',
            imgly_overlay_lightleak1: 'Light Leak 1',
            imgly_overlay_lightleak2: 'Light Leak 2',
            imgly_overlay_metal: 'Metal',
            imgly_overlay_mosaic: 'Mosaic',
            imgly_overlay_painting: 'Painting',
            imgly_overlay_paper: 'Paper',
            imgly_overlay_rain: 'Rain',
            imgly_overlay_vintage: 'Vintage',
            imgly_overlay_wall1: 'Wall',
            imgly_overlay_wall2: 'Wall 2',
            imgly_overlay_wood: 'Wood',
        },
    },
    sticker: {
        title: 'Stickers',
        controls: {
            buttonUpload: 'Upload Sticker',
            sliderOpacity: 'Sticker Opacity',
            selectColor: 'Sticker Color',
            tabColor: 'Color',
            tabOpacity: 'Opacity',
        },
        categories: {
            imgly_sticker_emoticons: 'Emoticons',
            imgly_sticker_shapes: 'Shapes',
            imgly_sticker_custom: 'Custom',
        },
        items: {
            imgly_sticker_emoticons_alien: 'Alien',
            imgly_sticker_emoticons_angel: 'Angel',
            imgly_sticker_emoticons_angry: 'Angry',
            imgly_sticker_emoticons_anxious: 'Anxious',
            imgly_sticker_emoticons_asleep: 'Asleep',
            imgly_sticker_emoticons_attention: 'Attention',
            imgly_sticker_emoticons_baby_chicken: 'Baby Chicken',
            imgly_sticker_emoticons_batman: 'Batman',
            imgly_sticker_emoticons_beer: 'Beer',
            imgly_sticker_emoticons_black: 'Black',
            imgly_sticker_emoticons_blue: 'Blue',
            imgly_sticker_emoticons_blush: 'Blush',
            imgly_sticker_emoticons_boxer: 'Boxer',
            imgly_sticker_emoticons_business: 'Business',
            imgly_sticker_emoticons_chicken: 'Chicken',
            imgly_sticker_emoticons_cool: 'Cool',
            imgly_sticker_emoticons_cry: 'Cry',
            imgly_sticker_emoticons_deceased: 'Deceased',
            imgly_sticker_emoticons_devil: 'Devil',
            imgly_sticker_emoticons_duckface: 'Duckface',
            imgly_sticker_emoticons_furious: 'Furious',
            imgly_sticker_emoticons_grin: 'Grin',
            imgly_sticker_emoticons_guitar: 'Guitar',
            imgly_sticker_emoticons_harry_potter: 'Harry Potter',
            imgly_sticker_emoticons_hippie: 'Hippie',
            imgly_sticker_emoticons_hitman: 'Hitman',
            imgly_sticker_emoticons_humourous: 'Humourous',
            imgly_sticker_emoticons_idea: 'Idea',
            imgly_sticker_emoticons_impatient: 'Impatient',
            imgly_sticker_emoticons_kiss: 'Kiss',
            imgly_sticker_emoticons_kisses: 'Kisses',
            imgly_sticker_emoticons_laugh: 'Laugh',
            imgly_sticker_emoticons_loud_cry: 'Loud Cry',
            imgly_sticker_emoticons_loving: 'Loving',
            imgly_sticker_emoticons_masked: 'Masked',
            imgly_sticker_emoticons_music: 'Music',
            imgly_sticker_emoticons_nerd: 'Nerd',
            imgly_sticker_emoticons_ninja: 'Ninja',
            imgly_sticker_emoticons_not_speaking_to_you: 'Not speaking to you',
            imgly_sticker_emoticons_pig: 'Pig',
            imgly_sticker_emoticons_pumpkin: 'Pumpkin',
            imgly_sticker_emoticons_question: 'Question',
            imgly_sticker_emoticons_rabbit: 'Rabbit',
            imgly_sticker_emoticons_sad: 'Sad',
            imgly_sticker_emoticons_sick: 'Sick',
            imgly_sticker_emoticons_skateboard: 'Skateboard',
            imgly_sticker_emoticons_skull: 'Skull',
            imgly_sticker_emoticons_sleepy: 'Sleepy',
            imgly_sticker_emoticons_smile: 'Smile',
            imgly_sticker_emoticons_smoking: 'Smoking',
            imgly_sticker_emoticons_sobbing: 'Sobbing',
            imgly_sticker_emoticons_star: 'Star',
            imgly_sticker_emoticons_steaming_furious: 'Steaming Furious',
            imgly_sticker_emoticons_sunbathing: 'Sunbathing',
            imgly_sticker_emoticons_tired: 'Tired',
            imgly_sticker_emoticons_tongue_out_wink: 'Tongue out wink',
            imgly_sticker_emoticons_wave: 'Wave',
            imgly_sticker_emoticons_wide_grin: 'Wide Grin',
            imgly_sticker_emoticons_wink: 'Wink',
            imgly_sticker_emoticons_wrestler: 'Wrestler',
            imgly_sticker_shapes_arrow_02: 'Arrow 1',
            imgly_sticker_shapes_arrow_03: 'Arrow 2',
            imgly_sticker_shapes_badge_01: 'Badge 1',
            imgly_sticker_shapes_badge_11: 'Badge 5',
            imgly_sticker_shapes_badge_12: 'Badge 6',
            imgly_sticker_shapes_badge_13: 'Badge 7',
            imgly_sticker_shapes_badge_15: 'Badge 8',
            imgly_sticker_shapes_badge_18: 'Badge 9',
            imgly_sticker_shapes_badge_19: 'Badge 10',
            imgly_sticker_shapes_badge_20: 'Badge 11',
            imgly_sticker_shapes_badge_28: 'Badge 12',
            imgly_sticker_shapes_badge_32: 'Badge 13',
            imgly_sticker_shapes_badge_35: 'Badge 14',
            imgly_sticker_shapes_badge_36: 'Badge 15',
            imgly_sticker_shapes_badge_04: 'Badge 2',
            imgly_sticker_shapes_badge_06: 'Badge 3',
            imgly_sticker_shapes_badge_08: 'Badge 4',
            imgly_sticker_shapes_spray_01: 'Spray 1',
            imgly_sticker_shapes_spray_03: 'Spray 2',
            imgly_sticker_shapes_spray_04: 'Spray 3',
        },
        canvasActions: {
            buttonDelete: 'Delete',
            buttonBringToFront: 'Move to front',
            buttonDuplicate: 'Duplicate',
            buttonFlipHorizontal: 'Flip',
            buttonFlipVertical: 'Flip',
        },
        history: {
            add: 'Sticker',
            resize: 'Sticker resize',
            position: 'Sticker position',
            color: 'Sticker color',
            delete: 'Sticker delete',
            order: 'Sticker order',
            opacity: 'Sticker opacity',
            flip: 'Sticker flip',
        },
    },
    text: {
        title: 'Text',
        controls: {
            buttonNew: 'New Text',
            dropdownFontFamily: 'Font Family',
            textFontSize: 'Font Size',
            selectAlignment: 'Alignment',
            selectFontColor: 'Font Color',
            selectBackgroundColor: 'Background Color',
            sliderLineSpacing: 'Line Spacing',
            tabColor: 'Color',
            tabBgColor: 'Bg Color',
            tabAlignment: 'Alignment',
            tabLineHeight: 'Line Height',
            tabFontSize: 'Font Size',
        },
        canvasControls: {
            placeholderText: 'Write Something',
            buttonSave: 'Done',
            buttonClose: 'Cancel',
            inputText: 'Text Input',
        },
        canvasActions: {
            buttonEdit: 'Edit',
            buttonDelete: 'Delete',
            buttonBringToFront: 'Move to front',
            buttonDuplicate: 'Duplicate',
        },
        history: {
            add: 'Text',
            edit: 'Text edit',
            resize: 'Text resize',
            position: 'Text position',
            alignment: 'Text alignment',
            textColor: 'Text color',
            backgroundColor: 'Text background color',
            fontFamily: 'Font family',
            fontStyle: 'Font style',
            lineSpacing: 'Line spacing',
            width: 'Text width',
            delete: 'Text delete',
            order: 'Text order',
        },
    },
    textdesign: {
        title: 'Text Design',
        controls: {
            buttonNew: 'New Text Design',
            buttonShuffle: 'Shuffle Layout',
            selectColor: 'Text Color',
            tabColor: 'Color',
            tabShuffle: 'Shuffle',
        },
        canvasControls: {
            placeholderText: 'Write Something',
            buttonSave: 'Done',
            buttonClose: 'Schließen',
            inputText: 'Text Input',
        },
        canvasActions: {
            buttonEdit: 'Edit',
            buttonInvert: 'Invert',
            buttonDelete: 'Delete',
            buttonBringToFront: 'Move to front',
            buttonDuplicate: 'Duplicate',
        },
        history: {
            add: 'Text design',
            edit: 'Text design edit',
            resize: 'Text design resize',
            position: 'Text design position',
            color: 'Text design color',
            shuffle: 'Text design shuffle',
            invert: 'Text design invert',
            padding: 'Text design padding',
            order: 'Text design order',
            delete: 'Text design delete',
        },
    },
    frame: {
        title: 'Frames',
        controls: {
            buttonReset: 'Remove Frame',
            sliderOpacity: 'Frame Opacity',
            sliderSize: 'Frame Size',
            selectColor: 'Frame Color',
            tabColor: 'Color',
            tabOpacity: 'Opacity',
            tabSize: 'Size',
        },
        items: {
            imgly_frame_dia: 'Dia',
            imgly_frame_art_decor: 'Art Decor',
            imgly_frame_black_passepartout: 'Black',
            imgly_frame_lowpoly_shadow: 'Low Poly',
            imgly_frame_wood_passepartout: 'Wood',
        },
    },
    brush: {
        title: 'Brush',
        controls: {
            buttonReset: 'Remove Brush',
            sliderSize: 'Brush Size',
            sliderHardness: 'Brush Hardness',
            selectColor: 'Brush Color',
            tabSize: 'Size',
            tabHardness: 'Hardness',
            tabColor: 'Color',
        },
        history: {
            brushStroke: 'Brush Stroke',
        },
    },
    transform: {
        title: 'Transform',
        controls: {
            buttonReset: 'Reset to default',
            checkboxKeepResolution: 'Keep Resolution',
            inputCropSize: 'Crop Size',
            inputHeight: 'h',
            inputWidth: 'w',
            tabFlipAndRotate: 'Flip & Rotate',
            tabResolution: 'Resolution',
            tabCropSize: 'Crop Size',
            selectFlipRatio: 'Flip Crop Ratio',
        },
        categories: {
            imgly_transforms_common: 'Common',
            imgly_transforms_facebook: 'Facebook',
            imgly_transforms_twitter: 'Twitter',
            imgly_transforms_instagram: 'Instagram',
        },
        items: {
            imgly_transform_common_custom: 'Custom',
            imgly_transform_common_square: 'Square',
            imgly_transform_common_4: '4:3',
            imgly_transform_common_16: '16:9',
            imgly_transform_common_3: '3:4',
            imgly_transform_common_9: '9:16',
            imgly_transform_facebook_profile: 'Profile',
            imgly_transform_facebook_title: 'Title',
            imgly_transform_facebook_post: 'Post',
            imgly_transform_instagram_story: 'Story',
            imgly_transform_instagram_landscape: 'Landcape',
            imgly_transform_instagram_portrait: 'Portrait',
            imgly_transform_instagram_square: 'Square',
            imgly_transform_twitter_profile: 'Profile',
            imgly_transform_twitter_title: 'Title',
            imgly_transform_twitter_post: 'Post',
        },
        transformActions: {
            buttonFlipHorizontal: 'Flip Horizontal',
            buttonFlipVertical: 'Flip Vertical',
            buttonRotateClockwise: 'Rotate Clockwise',
            buttonRotateAntiClockwise: 'Rotate Anticlockwise',
        },
    },
};
/* eslint-enable  @typescript-eslint/camelcase */

// Identifiers are in snake case
/* eslint-disable  @typescript-eslint/camelcase */
var de = {
    common: {
        error: 'Fehler',
        warning: 'Warnung',
        color: {
            colorPicker: {
                hex: 'Hex',
                r: 'R',
                g: 'G',
                b: 'B',
                sliderHue: 'Farbe',
                sliderOpacity: 'Farbe Intransparenz',
            },
        },
    },
    mainCanvasActions: {
        buttonExport: 'Bild Exportieren',
        buttonUndo: 'Rückgängig machen',
        buttonRedo: 'Wiederholen',
        buttonClose: 'Schließen',
    },
    infoModals: {
        exporting: {
            heading: 'Exportieren...',
            body: 'Just a few seconds...',
        },
        saving: {
            heading: 'Speichere...',
            body: 'Just a few seconds...',
        },
        loading: {
            heading: 'Lade...',
            body: 'Just a few seconds...',
        },
        resizing: {
            heading: 'Bild wird bearbeitet...',
            body: 'Just a few seconds...',
        },
        loadingFonts: {
            heading: 'Lade Schriftarten...',
            body: 'Just a few seconds...',
        },
    },
    errorModals: {
        imageLoading: {
            body: 'Laden des Bildes fehlgeschlagen. Dies kann verschiedene Gründe haben, beispielsweise kann die Datei defekt sein oder der Dateityp wird nicht unterstützt',
            buttonYes: 'Neu Laden',
        },
        rendering: {
            body: 'Beim Rendern des Bildes ist ein Fehler aufgetreten',
            buttonYes: 'Neu Laden',
        },
        fontLoading: {
            heading: 'Laden von Schriftarten ist fehlgeschlagen',
            // eslint-disable-next-line no-template-curly-in-string
            body: 'Die folgenden Schriftarten konnten nicht geladen werden: ${error}',
            buttonNo: 'Schließen',
        },
        webcamUnavailable: {
            // eslint-disable-next-line no-template-curly-in-string
            body: 'Webcam-Bild kann nicht dargestellt werden. (Fehler: ${error})',
            buttonYes: 'Schließen',
        },
        stickerLoading: {
            body: 'Laden des Stickers fehlgeschlagen.',
            buttonNo: 'Schließen',
        },
        unsupportedSerializationVersion: {
            body: 'Serialization version ist nicht unterstützt',
            buttonNo: 'Schließen',
        },
        unexpectedError: {
            // eslint-disable-next-line no-template-curly-in-string
            body: 'Ein erwarteter Fehler ist aufgetreten, ${error}',
            buttonYes: 'Neu Laden',
        },
    },
    warningModals: {
        imageResized: {
            heading: 'Bild verkleinert',
            // eslint-disable-next-line no-template-curly-in-string
            body: 'Das Bild wurde es auf ${width}x${height} Pixel verkleinert',
        },
        discardChanges: {
            body: 'Sind Sie sicher, dass Sie die Änderungen verwerfen wollen?',
            buttonYes: 'Änderungen verwerfen?',
            buttonNo: 'Änderungen beibehalten',
        },
        unsavedChanges: {
            body: 'Sind Sie sicher, dass Sie die Änderungen verwerfen wollen?',
            buttonYes: 'Beenden ohne zu speichern',
            buttonNo: 'Schließen',
        },
    },
    library: {
        title: 'Bibliothek',
        controls: {
            buttonUpload: 'Hochladen',
            buttonWebcamOpen: 'Webcam',
            buttonWebcamClose: 'Close Webcam',
            placeholderSearch: 'Bibliothek durchsuchen',
            noResults: 'Keine Ergebnisse',
        },
    },
    filter: {
        title: 'Filters',
        controls: {
            buttonReset: 'Zurücksetzen',
            sliderIntensity: 'Filter Intensität',
        },
        categories: {
            imgly_filter_category_duotone: 'DuoTone',
            imgly_filter_category_bw: 'B & W',
            imgly_filter_category_vintage: 'Vintage',
            imgly_filter_category_smooth: 'Smooth',
            imgly_filter_category_cold: 'Cold',
            imgly_filter_category_warm: 'Warm',
            imgly_filter_category_legacy: 'Legacy',
        },
        items: {
            imgly_lut_celsius: 'Inferno',
            imgly_lut_chest: 'Chestnut',
            imgly_lut_fixie: 'Fixie',
            imgly_lut_fridge: 'Fridge',
            imgly_lut_front: 'Sunny 70s',
            imgly_lut_k2: 'Flat Black',
            imgly_lut_mellow: 'Mellow',
            imgly_lut_sin: 'Hard Stuff',
            imgly_lut_texas: 'Oldtimer',
            imgly_lut_ad1920: '1920 A.D.',
            imgly_lut_ancient: 'Ancient',
            imgly_lut_bleached: 'Kalmen',
            imgly_lut_bleachedblue: 'Joran',
            imgly_lut_blues: 'Polaroid',
            imgly_lut_blueshadows: 'Zephyr',
            imgly_lut_breeze: 'Levante',
            imgly_lut_bw: 'Greyed',
            imgly_lut_classic: 'Classic',
            imgly_lut_colorful: 'Colorful',
            imgly_lut_cool: 'Snappy',
            imgly_lut_cottoncandy: 'Candy',
            imgly_lut_creamy: 'Creamy',
            imgly_lut_eighties: 'Low Fire',
            imgly_lut_elder: 'Colla',
            imgly_lut_evening: 'Sunrise',
            imgly_lut_fall: 'Moss',
            imgly_lut_food: 'Food',
            imgly_lut_glam: 'Glam',
            imgly_lut_gobblin: 'Gobblin',
            imgly_lut_highcarb: 'High Carb',
            imgly_lut_highcontrast: 'Hicon',
            imgly_lut_k1: 'K1',
            imgly_lut_k6: 'K6',
            imgly_lut_kdynamic: 'Pebble',
            imgly_lut_keen: 'Keen',
            imgly_lut_lenin: 'Lemon',
            imgly_lut_litho: 'Litho',
            imgly_lut_lomo: 'Lomo',
            imgly_lut_lomo100: 'Lomo 100',
            imgly_lut_lucid: 'Lucid',
            imgly_lut_neat: 'Neat',
            imgly_lut_nogreen: 'Pumpkin',
            imgly_lut_orchid: 'Solanus',
            imgly_lut_pale: 'Pale',
            imgly_lut_pitched: 'Pitched',
            imgly_lut_plate: 'Weathered',
            imgly_lut_pola669: 'Green Gap',
            imgly_lut_polasx: 'Pola SX',
            imgly_lut_pro400: 'Pro 400',
            imgly_lut_quozi: 'Quozi',
            imgly_lut_sepiahigh: 'Sepia',
            imgly_lut_settled: 'Settled',
            imgly_lut_seventies: 'Seventies',
            imgly_lut_soft: 'Soft',
            imgly_lut_steel: 'Steel',
            imgly_lut_summer: 'Summer',
            imgly_lut_sunset: 'Golden',
            imgly_lut_tender: 'Tender',
            imgly_lut_twilight: 'Twilight',
            imgly_lut_winter: 'Softy',
            imgly_lut_x400: 'Dusty',
            imgly_duotone_desert: 'Desert',
            imgly_duotone_peach: 'Peach',
            imgly_duotone_clash: 'Clash',
            imgly_duotone_plum: 'Plum',
            imgly_duotone_breezy: 'Breezy',
            imgly_duotone_deepblue: 'Deep Blue',
            imgly_duotone_frog: 'Frog',
            imgly_duotone_sunset: 'Sunset',
        },
    },
    adjustment: {
        title: 'Korrekturen',
        controls: {
            buttonReset: 'Zurücksetzen',
        },
        categories: {
            basics: 'Grundlagen',
            refinements: 'Feinheiten',
        },
        items: {
            brightness: 'Helligkeit',
            saturation: 'Sättigung',
            contrast: 'Kontrast',
            gamma: 'Gamma',
            sharpness: 'Schärfe',
            clarity: 'Klarheit',
            exposure: 'Belichtung',
            shadows: 'Schatten',
            highlights: 'Lichter',
            whites: 'Weiß',
            blacks: 'Schwarz',
            temperature: 'Temperatur',
        },
    },
    focus: {
        title: 'Weichzeichnen',
        controls: {
            buttonReset: 'Zurücksetzen',
            sliderIntensity: 'Focus Intensität',
        },
        items: {
            radial: 'Kreisförmig',
            mirrored: 'Gespiegelt',
            linear: 'Linear',
            gaussian: 'Gaußsch',
        },
        history: {
            focusPosition: 'Focus Position',
            focusSize: 'Focus Größe',
        },
    },
    overlay: {
        title: 'Overlays',
        controls: {
            buttonReset: 'Zurücksetzen',
            sliderOpacity: 'Overlay Intransparenz',
            carouselBlendMode: 'Overlay Mischmodus',
            blendModeNormal: 'Normal',
            blendModeOverlay: 'Overlay',
            blendModeHardLight: 'Hard Light',
            blendModeSoftLight: 'Soft Light',
            blendModeMultiply: 'Multiply',
            blendModeDarken: 'Darken',
            blendModeLighten: 'Lighten',
            blendModeScreen: 'Screen',
            blendModeColorBurn: 'Color Burn',
            tabOpacity: 'Intransparenz',
            tabBlendMode: 'Blend Mode',
        },
        items: {
            imgly_overlay_bokeh: 'Bokeh',
            imgly_overlay_chop: 'Chop',
            imgly_overlay_clouds: 'Clouds',
            imgly_overlay_golden: 'Golden',
            imgly_overlay_grain: 'Grain',
            imgly_overlay_hearts: 'Hearts',
            imgly_overlay_lightleak1: 'Light Leak 1',
            imgly_overlay_lightleak2: 'Light Leak 2',
            imgly_overlay_metal: 'Metal',
            imgly_overlay_mosaic: 'Mosaic',
            imgly_overlay_painting: 'Painting',
            imgly_overlay_paper: 'Paper',
            imgly_overlay_rain: 'Rain',
            imgly_overlay_vintage: 'Vintage',
            imgly_overlay_wall1: 'Wall',
            imgly_overlay_wall2: 'Wall 2',
            imgly_overlay_wood: 'Wood',
        },
    },
    sticker: {
        title: 'Stickers',
        controls: {
            buttonUpload: 'Sticker Hochladen',
            sliderOpacity: 'Sticker Transparenz',
            selectColor: 'Form Farbe',
            tabColor: 'Farbe',
            tabOpacity: 'Intransparenz',
        },
        categories: {
            imgly_sticker_emoticons: 'Emoticons',
            imgly_sticker_shapes: 'Shapes',
            imgly_sticker_custom: 'Custom',
        },
        items: {
            imgly_sticker_emoticons_alien: 'Alien',
            imgly_sticker_emoticons_angel: 'Angel',
            imgly_sticker_emoticons_angry: 'Angry',
            imgly_sticker_emoticons_anxious: 'Anxious',
            imgly_sticker_emoticons_asleep: 'Asleep',
            imgly_sticker_emoticons_attention: 'Attention',
            imgly_sticker_emoticons_baby_chicken: 'Baby Chicken',
            imgly_sticker_emoticons_batman: 'Batman',
            imgly_sticker_emoticons_beer: 'Beer',
            imgly_sticker_emoticons_black: 'Black',
            imgly_sticker_emoticons_blue: 'Blue',
            imgly_sticker_emoticons_blush: 'Blush',
            imgly_sticker_emoticons_boxer: 'Boxer',
            imgly_sticker_emoticons_business: 'Business',
            imgly_sticker_emoticons_chicken: 'Chicken',
            imgly_sticker_emoticons_cool: 'Cool',
            imgly_sticker_emoticons_cry: 'Cry',
            imgly_sticker_emoticons_deceased: 'Deceased',
            imgly_sticker_emoticons_devil: 'Devil',
            imgly_sticker_emoticons_duckface: 'Duckface',
            imgly_sticker_emoticons_furious: 'Furious',
            imgly_sticker_emoticons_grin: 'Grin',
            imgly_sticker_emoticons_guitar: 'Guitar',
            imgly_sticker_emoticons_harry_potter: 'Harry Potter',
            imgly_sticker_emoticons_hippie: 'Hippie',
            imgly_sticker_emoticons_hitman: 'Hitman',
            imgly_sticker_emoticons_humourous: 'Humourous',
            imgly_sticker_emoticons_idea: 'Idea',
            imgly_sticker_emoticons_impatient: 'Impatient',
            imgly_sticker_emoticons_kiss: 'Kiss',
            imgly_sticker_emoticons_kisses: 'Kisses',
            imgly_sticker_emoticons_laugh: 'Laugh',
            imgly_sticker_emoticons_loud_cry: 'Loud Cry',
            imgly_sticker_emoticons_loving: 'Loving',
            imgly_sticker_emoticons_masked: 'Masked',
            imgly_sticker_emoticons_music: 'Music',
            imgly_sticker_emoticons_nerd: 'Nerd',
            imgly_sticker_emoticons_ninja: 'Ninja',
            imgly_sticker_emoticons_not_speaking_to_you: 'Not speaking to you',
            imgly_sticker_emoticons_pig: 'Pig',
            imgly_sticker_emoticons_pumpkin: 'Pumpkin',
            imgly_sticker_emoticons_question: 'Question',
            imgly_sticker_emoticons_rabbit: 'Rabbit',
            imgly_sticker_emoticons_sad: 'Sad',
            imgly_sticker_emoticons_sick: 'Sick',
            imgly_sticker_emoticons_skateboard: 'Skateboard',
            imgly_sticker_emoticons_skull: 'Skull',
            imgly_sticker_emoticons_sleepy: 'Sleepy',
            imgly_sticker_emoticons_smile: 'Smile',
            imgly_sticker_emoticons_smoking: 'Smoking',
            imgly_sticker_emoticons_sobbing: 'Sobbing',
            imgly_sticker_emoticons_star: 'Star',
            imgly_sticker_emoticons_steaming_furious: 'Steaming Furious',
            imgly_sticker_emoticons_sunbathing: 'Sunbathing',
            imgly_sticker_emoticons_tired: 'Tired',
            imgly_sticker_emoticons_tongue_out_wink: 'Tongue out wink',
            imgly_sticker_emoticons_wave: 'Wave',
            imgly_sticker_emoticons_wide_grin: 'Wide Grin',
            imgly_sticker_emoticons_wink: 'Wink',
            imgly_sticker_emoticons_wrestler: 'Wrestler',
            imgly_sticker_shapes_arrow_02: 'Arrow 1',
            imgly_sticker_shapes_arrow_03: 'Arrow 2',
            imgly_sticker_shapes_badge_01: 'Badge 1',
            imgly_sticker_shapes_badge_11: 'Badge 5',
            imgly_sticker_shapes_badge_12: 'Badge 6',
            imgly_sticker_shapes_badge_13: 'Badge 7',
            imgly_sticker_shapes_badge_15: 'Badge 8',
            imgly_sticker_shapes_badge_18: 'Badge 9',
            imgly_sticker_shapes_badge_19: 'Badge 10',
            imgly_sticker_shapes_badge_20: 'Badge 11',
            imgly_sticker_shapes_badge_28: 'Badge 12',
            imgly_sticker_shapes_badge_32: 'Badge 13',
            imgly_sticker_shapes_badge_35: 'Badge 14',
            imgly_sticker_shapes_badge_36: 'Badge 15',
            imgly_sticker_shapes_badge_04: 'Badge 2',
            imgly_sticker_shapes_badge_06: 'Badge 3',
            imgly_sticker_shapes_badge_08: 'Badge 4',
            imgly_sticker_shapes_spray_01: 'Spray 1',
            imgly_sticker_shapes_spray_03: 'Spray 2',
            imgly_sticker_shapes_spray_04: 'Spray 3',
        },
        canvasActions: {
            buttonDelete: 'Löschen',
            buttonBringToFront: 'In den Vordergrund',
            buttonDuplicate: 'Duplizieren',
            buttonFlipHorizontal: 'Horizontal spiegeln',
            buttonFlipVertical: 'Vertikal spiegeln',
        },
        history: {
            add: 'Sticker',
            resize: 'Sticker resize',
            position: 'Sticker position',
            color: 'Sticker color',
            delete: 'Sticker delete',
            order: 'Sticker order',
            opacity: 'Sticker opacity',
            flip: 'Sticker flip',
        },
    },
    text: {
        title: 'Text',
        controls: {
            buttonNew: 'Neuer Text',
            dropdownFontFamily: 'Schriftart',
            textFontSize: 'Schriftgröße',
            selectAlignment: 'Ausrichtung',
            selectFontColor: 'Schriftfarbe',
            selectBackgroundColor: 'Hintergrund Color',
            sliderLineSpacing: 'Zeile',
            tabColor: 'Farbe',
            tabBgColor: 'Hintergrund',
            tabAlignment: 'Ausrichtung',
            tabLineHeight: 'Zeile',
            tabFontSize: 'Schriftgröße',
        },
        canvasControls: {
            placeholderText: 'Etwas aufschreiben',
            buttonSave: 'Fertig',
            buttonClose: 'Abbrechen',
            inputText: 'Text Input',
        },
        canvasActions: {
            buttonEdit: 'Bearbeiten',
            buttonDelete: 'Löschen',
            buttonBringToFront: 'In den Vordergrund',
            buttonDuplicate: 'Duplizieren',
        },
        history: {
            add: 'Text',
            edit: 'Text edit',
            resize: 'Text resize',
            position: 'Text position',
            alignment: 'Text alignment',
            textColor: 'Text color',
            backgroundColor: 'Text background color',
            fontFamily: 'Font family',
            fontStyle: 'Font style',
            lineSpacing: 'Line spacing',
            width: 'Text width',
            delete: 'Text delete',
            order: 'Text order',
        },
    },
    textdesign: {
        title: 'Text Design',
        controls: {
            buttonNew: 'Neues Text Design',
            buttonShuffle: 'Shuffle Layout',
            selectColor: 'Text Farbe',
            tabColor: 'Color',
            tabShuffle: 'Shuffle',
        },
        canvasControls: {
            placeholderText: 'Etwas aufschreiben',
            buttonSave: 'Done',
            buttonClose: 'Schließen',
            inputText: 'Text Input',
        },
        canvasActions: {
            buttonEdit: 'Bearbeiten',
            buttonInvert: 'Invertieren',
            buttonDelete: 'Löschen',
            buttonBringToFront: 'In den Vordergrund',
            buttonDuplicate: 'Duplizieren',
        },
        history: {
            add: 'Text design',
            edit: 'Text design edit',
            resize: 'Text design resize',
            position: 'Text design position',
            color: 'Text design color',
            shuffle: 'Text design shuffle',
            invert: 'Text design invert',
            padding: 'Text design padding',
            order: 'Text design order',
            delete: 'Text design delete',
        },
    },
    frame: {
        title: 'Rahmen',
        controls: {
            buttonReset: 'Zurücksetzen',
            sliderOpacity: 'Rahmen Intransparenz',
            sliderSize: 'Rahmen Dicke',
            selectColor: 'Rahmen Farbe',
            tabColor: 'Farbe',
            tabOpacity: 'Intransparenz',
            tabSize: 'Dicke',
        },
        items: {
            imgly_frame_dia: 'Dia',
            imgly_frame_art_decor: 'Art Decor',
            imgly_frame_black_passepartout: 'Black',
            imgly_frame_lowpoly_shadow: 'Low Poly',
            imgly_frame_wood_passepartout: 'Wood',
        },
    },
    brush: {
        title: 'Malen',
        controls: {
            buttonReset: 'Zurücksetzen',
            sliderSize: 'Dicke',
            sliderHardness: 'Härte',
            selectColor: 'Farbe',
            tabColor: 'Farbe',
            tabSize: 'Dicke',
            tabHardness: 'Härte',
        },
        history: {
            brushStroke: 'Brush Stroke',
        },
    },
    transform: {
        title: 'Zuschneiden',
        controls: {
            buttonReset: 'Zurücksetzen',
            checkboxKeepResolution: 'Fixiere Auflösung',
            inputCropSize: 'Bildgröße',
            inputHeight: 'h',
            inputWidth: 'b',
            tabFlipAndRotate: 'Flip & Rotate',
            tabResolution: 'Auflösung',
            tabCropSize: 'Bildgröße',
            selectFlipRatio: 'Flip Crop Ratio',
        },
        categories: {
            imgly_transforms_common: 'Standard',
            imgly_transforms_facebook: 'Facebook',
            imgly_transforms_twitter: 'Twitter',
            imgly_transforms_instagram: 'Instagram',
        },
        items: {
            imgly_transform_common_custom: 'Frei',
            imgly_transform_common_square: 'Quadratisch',
            imgly_transform_common_4: '4:3',
            imgly_transform_common_16: '16:9',
            imgly_transform_common_3: '3:4',
            imgly_transform_common_9: '9:16',
            imgly_transform_facebook_profile: 'Profile',
            imgly_transform_facebook_title: 'Titel',
            imgly_transform_facebook_post: 'Post',
            imgly_transform_instagram_story: 'Story',
            imgly_transform_instagram_landscape: 'Landcape',
            imgly_transform_instagram_portrait: 'Portrait',
            imgly_transform_instagram_square: 'Square',
            imgly_transform_twitter_profile: 'Profile',
            imgly_transform_twitter_title: 'Title',
            imgly_transform_twitter_post: 'Post',
        },
        transformActions: {
            buttonFlipHorizontal: 'Horizontal spiegeln',
            buttonFlipVertical: 'Vertikal spiegeln',
            buttonRotateClockwise: 'Rotate Clockwise',
            buttonRotateAntiClockwise: 'Rotate Anticlockwise',
        },
    },
};
/* eslint-enable  @typescript-eslint/camelcase */

var getLanguage = function (language) {
    if (language === 'de') {
        return de;
    }
    return en;
};
var localeManager = function (language, customLanguages) {
    if (customLanguages && customLanguages[language]) {
        return deepmergeAll([getLanguage(language), customLanguages[language]]);
    }
    return getLanguage(language) || en;
};

var ScrollManager = /** @class */ (function () {
    function ScrollManager() {
    }
    ScrollManager.addScrollStyles = function (color) {
        if (color === void 0) { color = 'rgba(255, 255, 255, 0.2)'; }
        var styles = ScrollManager.styles(color);
        var css = "\n    /* Injected by PhotoEditorSDK */\n    " + styles + "\n  ";
        var styleTag = document.createElement('style');
        styleTag.innerHTML = css;
        document.head.appendChild(styleTag);
    };
    ScrollManager.styles = function (background) { return "\n    [data-simplebar] {\n      position: relative;\n      flex-direction: column;\n      flex-wrap: wrap;\n      justify-content: flex-start;\n      align-content: flex-start;\n      align-items: flex-start;\n    }\n\n    .simplebar-wrapper {\n      overflow: hidden;\n      width: inherit;\n      height: inherit;\n      max-width: inherit;\n      max-height: inherit;\n    }\n\n    .simplebar-mask {\n      direction: inherit;\n      position: absolute;\n      padding: 0;\n      margin: 0;\n      left: 0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      width: auto !important;\n      height: auto !important;\n      z-index: 0;\n    }\n\n    .simplebar-offset {\n      direction: inherit !important;\n      box-sizing: inherit !important;\n      resize: none !important;\n      position: absolute;\n      top: 0;\n      left: 0;\n      bottom: 0;\n      right: 0;\n      padding: 0;\n      margin: 0;\n      -webkit-overflow-scrolling: touch;\n    }\n\n    .simplebar-content-wrapper {\n      direction: inherit;\n      box-sizing: border-box !important;\n      position: relative;\n      display: block;\n      height: 100%; /* Required for horizontal native scrollbar to not appear if parent is taller than natural height */\n      width: auto;\n      visibility: visible;\n      overflow: auto; /* Scroll on this element otherwise element can't have a padding applied properly */\n      max-width: 100%; /* Not required for horizontal scroll to trigger */\n      max-height: 100%; /* Needed for vertical scroll to trigger */\n    }\n\n    .simplebar-content:before,\n    .simplebar-content:after {\n      content: ' ';\n      display: table;\n    }\n\n    .simplebar-placeholder {\n      max-height: 100%;\n      max-width: 100%;\n      width: 100%;\n      pointer-events: none;\n    }\n\n    .simplebar-height-auto-observer-wrapper {\n      box-sizing: inherit !important;\n      height: 100%;\n      width: 100%;\n      max-width: 1px;\n      position: relative;\n      float: left;\n      max-height: 1px;\n      overflow: hidden;\n      z-index: -1;\n      padding: 0;\n      margin: 0;\n      pointer-events: none;\n      flex-grow: inherit;\n      flex-shrink: 0;\n      flex-basis: 0;\n    }\n\n    .simplebar-height-auto-observer {\n      box-sizing: inherit;\n      display: block;\n      opacity: 0;\n      position: absolute;\n      top: 0;\n      left: 0;\n      height: 1000%;\n      width: 1000%;\n      min-height: 1px;\n      min-width: 1px;\n      overflow: hidden;\n      pointer-events: none;\n      z-index: -1;\n    }\n\n    .simplebar-track {\n      z-index: 1;\n      position: absolute;\n      right: 0;\n      bottom: 0;\n      pointer-events: none;\n      overflow: hidden;\n    }\n\n    [data-simplebar].simplebar-dragging .simplebar-track {\n      pointer-events: all;\n    }\n\n    .simplebar-scrollbar {\n      position: absolute;\n      right: 2px;\n      width: 7px;\n      min-height: 10px;\n    }\n\n    .simplebar-scrollbar:before {\n      position: absolute;\n      content: '';\n      background: " + background + ";\n      border-radius: 7px;\n      left: 0;\n      right: 0;\n      opacity: 0;\n      transition: opacity 0.2s linear;\n    }\n\n    .simplebar-track .simplebar-scrollbar.simplebar-visible:before {\n      /* When hovered, remove all transitions from drag handle */\n      opacity: 0.5;\n      transition: opacity 0s linear;\n    }\n\n    .simplebar-track.simplebar-vertical {\n      top: 0;\n      width: 11px;\n    }\n\n    .simplebar-track.simplebar-vertical .simplebar-scrollbar:before {\n      top: 2px;\n      bottom: 2px;\n    }\n\n    .simplebar-track.simplebar-vertical .simplebar-scrollbar {\n      right: 0px;\n      width: 4px;\n    }\n\n    .simplebar-track.simplebar-horizontal {\n      left: 0;\n      height: 11px;\n    }\n\n    .simplebar-track.simplebar-horizontal .simplebar-scrollbar:before {\n      height: 100%;\n      left: 2px;\n      right: 2px;\n    }\n\n    .simplebar-track.simplebar-horizontal .simplebar-scrollbar {\n      right: auto;\n      left: 0;\n      min-height: 0;\n      min-width: 10px;\n      width: auto;\n      top: 7px;\n      height: 4px;\n    }\n\n    /* Rtl support */\n    [data-simplebar-direction='rtl'] .simplebar-track.simplebar-vertical {\n      right: auto;\n      left: 0;\n    }\n\n    .hs-dummy-scrollbar-size {\n      direction: rtl;\n      position: fixed;\n      opacity: 0;\n      visibility: hidden;\n      height: 500px;\n      width: 500px;\n      overflow-y: hidden;\n      overflow-x: scroll;\n    }\n  "; };
    return ScrollManager;
}());

var getDarktheme = function (_a) {
    var _b = _a === void 0 ? {
        primary: '#365afc',
        background: '#0B0B0B',
        foreground: '#FFFFFF',
    } : _a, _c = _b.primary, primary = _c === void 0 ? '#365afc' : _c, _d = _b.background, background = _d === void 0 ? '#0B0B0B' : _d, _e = _b.foreground, foreground = _e === void 0 ? '#FFFFFF' : _e;
    var textHE = 'rgba(255, 255, 255, 0.90)';
    var textME = 'rgba(255, 255, 255, 0.60)';
    var textLE = 'rgba(255, 255, 255, 0.38)';
    var surface600 = '#424242';
    var surface700 = '#333333';
    var surface800 = '#242424';
    var surface900 = '#171717';
    var surface1000 = '#0B0B0B';
    var hoverOverlayColor = 'rgba(255, 255, 255, 0.08)';
    var inactiveOverlayColor = 'rgba(0, 0, 0, 0.3)';
    var activeOverlayColor = 'rgba(89, 121, 252, 0.20)';
    var inactiveOpacity = '0.3';
    return {
        shape: {
            radiusSmall: 2,
            radiusMedium: 4,
            radiusLarge: 4,
        },
        typography: {
            fontFamily: 'Fira Sans',
            provider: 'google',
        },
        background: background,
        foreground: foreground,
        primary: primary,
        warning: '#ffba5c',
        error: '#c2393a',
        success: '#39c26c',
        focusOutlineColor: 'rgba(255, 255, 255, 0.12)',
        scrollbar: {
            handleColor: 'rgba(255, 255, 255, 0.2)',
        },
        button: {
            outlinedBorderColor: surface700,
            activeForeground: primary,
            containedPrimaryBackground: primary,
            containedPrimaryForeground: textHE,
            outlinedPrimaryBackground: surface800,
            outlinedPrimaryForeground: textHE,
            outlinedSecondaryBackground: 'transparent',
            outlinedSecondaryForeground: textME,
            textPrimaryForeground: primary,
            textSecondaryForeground: textME,
            outlinedInactiveOverlayColor: inactiveOverlayColor,
            textInactiveOpacity: '0.5',
            hoverOverlayColor: hoverOverlayColor,
        },
        checkbox: {
            background: surface700,
            foreground: foreground,
            activeForeground: foreground,
            activeBackground: primary,
            inactiveOpacity: inactiveOpacity,
            hoverOpacity: '0.8',
        },
        modal: {
            background: surface800,
            bodyForeground: textHE,
            headerForeground: textME,
            backdrop: 'rgba(0, 0, 0, 0.6)',
        },
        card: {
            background: surface700,
            foreground: textHE,
            activeBorderColor: primary,
            activeOverlayColor: activeOverlayColor,
            labelBackground: 'linear-gradient(transparent, rgba(0, 0, 0, 0.6))',
            labelForeground: textHE,
            inactiveOverlayColor: inactiveOverlayColor,
            hoverOverlayColor: hoverOverlayColor,
        },
        tabTitle: {
            foreground: textME,
            background: 'transparent',
            activeBackground: 'transparent',
            activeBorderColor: primary,
            activeForeground: textHE,
        },
        dropdown: {
            background: 'transparent',
            foreground: textHE,
            hoverBorderColor: textME,
            borderColor: surface700,
            caretColor: textLE,
            listBackground: surface700,
            listBorderColor: surface700,
            listItemHoverBackground: surface600,
            listForeground: textME,
            listShadow: "0 12px 17px 2px rgba(0,0,0,0.14),\n        0 5px 22px 4px rgba(0,0,0,0.12),\n        0 7px 8px -4px rgba(0,0,0,0.20)",
            inactiveOpacity: inactiveOpacity,
        },
        textInput: {
            foreground: textHE,
            hoverBorderColor: 'rgba(255, 255, 255, 0.40)',
            background: 'transparent',
            borderColor: surface700,
            inactiveOpacity: inactiveOpacity,
        },
        slider: {
            trackColor: 'rgba(255, 255, 255, 0.4)',
            activeTrackColor: primary,
            thumbBackground: surface900,
            thumbBorderColor: primary,
            inactiveOpacity: inactiveOpacity,
            hoverOpacity: '0.7',
        },
        selectColor: {
            activeBorderColor: primary,
            inactiveOpacity: inactiveOpacity,
        },
        toolbar: {
            foreground: textHE,
            background: surface800,
            activeBackground: 'transparent',
            activeForeground: primary,
            borderColor: 'transparent',
        },
        tooltip: {
            background: surface600,
            foreground: textHE,
        },
        toolControlBar: {
            // opaque surface900 color with 90% opacity
            background: 'rgba(23, 23, 23, 0.9)',
            borderColor: 'transparent',
            shadow: 'none',
            separatorColor: surface700,
            titleForeground: textME,
            inputLabelForeground: textME,
            inputLabelInactiveOpacity: inactiveOpacity,
        },
        mainCanvasActionBar: {
            background: 'linear-gradient(0deg, transparent 0%,  rgba(0, 0, 0, 0.6) 98%)',
            foreground: textHE,
            borderColor: 'none',
        },
        canvasActionBar: {
            background: surface600,
            foreground: textHE,
            separatorColor: textLE,
        },
        canvas: {
            background: surface1000,
            controlsOutline: 'rgba(255, 255, 255, 0.5)',
            controlsColor: '#ffffff',
            cropBackdrop: 'rgba(0, 0, 0, 0.5)',
        },
        colorPicker: {
            listBackground: surface700,
            listShadow: "0 12px 17px 2px rgba(0,0,0,0.14),\n        0 5px 22px 4px rgba(0,0,0,0.12),\n        0 7px 8px -4px rgba(0,0,0,0.20)",
            controlsColor: '#ffffff',
            inputBorderColor: surface600,
        },
        webcam: {
            backdrop: 'rgba(0, 0, 0, 0.3)',
            floatButton: foreground,
            background: surface1000,
        },
        snapping: {
            positionGuideColor: '#f0f',
            rotationGuideColor: '#0ff',
        },
        transform: {
            crops: {
                main: '#424242',
                highlight: '#565656',
                shadow: '#333333',
            },
        },
    };
};

var getLightTheme = function (_a) {
    var _b = _a === void 0 ? {
        primary: '#1e47fb',
        background: '#FBFBFB',
        foreground: '#000000',
    } : _a, _c = _b.primary, primary = _c === void 0 ? '#1e47fb' : _c, _d = _b.background, background = _d === void 0 ? '#FBFBFB' : _d, _e = _b.foreground, foreground = _e === void 0 ? '#000000' : _e;
    var textHE = 'rgba(0, 0, 0, 0.90)';
    var textME = 'rgba(0, 0, 0, 0.60)';
    var textLE = 'rgba(0, 0, 0, 0.38)';
    var surface600 = '#CCCCCC';
    var surface700 = '#D4D4D4';
    var surface800 = '#E6E6E6';
    var surface900 = '#EEEEEE';
    var surface1000 = '#FBFBFB';
    var hoverOverlayColor = 'rgba(125, 125, 125, 0.12)';
    var activeOverlayColor = 'rgba(30, 71, 251, 0.2)';
    var inactiveOverlayColor = 'rgba(0, 0, 0, 0.3)';
    var inactiveOpacity = '0.3';
    return {
        shape: {
            radiusSmall: 2,
            radiusMedium: 4,
            radiusLarge: 4,
        },
        typography: {
            fontFamily: 'Fira Sans',
            provider: 'google',
        },
        background: background,
        foreground: foreground,
        primary: primary,
        warning: '#ffb045',
        error: '#c01a1b',
        success: '#17c658',
        focusOutlineColor: 'rgba(125, 125, 125, 0.12)',
        scrollbar: {
            handleColor: 'rgba(0, 0, 0, 0.2)',
        },
        button: {
            outlinedBorderColor: surface700,
            activeForeground: primary,
            containedPrimaryBackground: primary,
            containedPrimaryForeground: 'rgba(255, 255, 255, 0.9)',
            outlinedPrimaryBackground: surface800,
            outlinedPrimaryForeground: textHE,
            outlinedSecondaryBackground: 'transparent',
            outlinedSecondaryForeground: textME,
            textPrimaryForeground: primary,
            textSecondaryForeground: textME,
            outlinedInactiveOverlayColor: inactiveOverlayColor,
            textInactiveOpacity: '0.5',
            hoverOverlayColor: hoverOverlayColor,
        },
        checkbox: {
            background: surface700,
            foreground: foreground,
            activeForeground: foreground,
            activeBackground: primary,
            inactiveOpacity: inactiveOpacity,
            hoverOpacity: '0.8',
        },
        modal: {
            background: surface800,
            bodyForeground: textHE,
            headerForeground: textME,
            backdrop: 'rgba(0, 0, 0, 0.6)',
        },
        card: {
            background: surface700,
            foreground: textHE,
            activeBorderColor: primary,
            activeOverlayColor: activeOverlayColor,
            labelBackground: 'linear-gradient(transparent, rgba(0, 0, 0, 0.6))',
            labelForeground: 'rgba(255, 255, 255, 0.87)',
            inactiveOverlayColor: inactiveOverlayColor,
            hoverOverlayColor: hoverOverlayColor,
        },
        tabTitle: {
            foreground: textME,
            background: 'transparent',
            activeBackground: 'transparent',
            activeBorderColor: primary,
            activeForeground: textHE,
        },
        dropdown: {
            background: 'transparent',
            foreground: textHE,
            hoverBorderColor: textME,
            borderColor: surface700,
            listBackground: surface700,
            caretColor: textLE,
            listForeground: textME,
            listBorderColor: surface700,
            listItemHoverBackground: surface600,
            listShadow: "0 8px 10px 1px rgba(0,0,0,0.14),\n        0 3px 14px 2px rgba(0,0,0,0.12),\n        0 5px 5px -3px rgba(0,0,0,0.20)",
            inactiveOpacity: inactiveOpacity,
        },
        textInput: {
            foreground: textHE,
            hoverBorderColor: textHE,
            background: 'transparent',
            borderColor: surface700,
            inactiveOpacity: inactiveOpacity,
        },
        slider: {
            trackColor: surface600,
            activeTrackColor: primary,
            thumbBackground: surface900,
            thumbBorderColor: primary,
            inactiveOpacity: inactiveOpacity,
            hoverOpacity: '0.7',
        },
        selectColor: {
            activeBorderColor: primary,
            inactiveOpacity: inactiveOpacity,
        },
        toolbar: {
            foreground: textHE,
            background: surface700,
            activeBackground: 'transparent',
            activeForeground: primary,
            borderColor: 'transparent',
        },
        tooltip: {
            background: surface600,
            foreground: textHE,
        },
        toolControlBar: {
            // opaque surface900 color with 90% opacity
            background: 'rgba(238, 238, 238, 0.9)',
            borderColor: surface900,
            shadow: 'none',
            separatorColor: surface700,
            titleForeground: textME,
            inputLabelForeground: textME,
            inputLabelInactiveOpacity: inactiveOpacity,
        },
        mainCanvasActionBar: {
            background: 'transparent',
            foreground: textHE,
            borderColor: 'none',
        },
        canvasActionBar: {
            background: surface600,
            foreground: textHE,
            separatorColor: textLE,
        },
        canvas: {
            background: surface1000,
            controlsOutline: 'rgba(255, 255, 255, 0.6)',
            controlsColor: '#ffffff',
            cropBackdrop: 'rgba(255, 255, 255, 0.3)',
        },
        colorPicker: {
            listBackground: surface700,
            listShadow: "0 8px 10px 1px rgba(0,0,0,0.14),\n        0 3px 14px 2px rgba(0,0,0,0.12),\n        0 5px 5px -3px rgba(0,0,0,0.20)",
            controlsColor: '#ffffff',
            inputBorderColor: surface600,
        },
        webcam: {
            backdrop: 'rgba(0, 0, 0, 0.3)',
            floatButton: foreground,
            background: surface1000,
        },
        snapping: {
            positionGuideColor: '',
            rotationGuideColor: '',
        },
        transform: {
            crops: {
                main: '#B8B8B8',
                highlight: '#E6E6E6',
                shadow: '#D4D4D4',
            },
        },
    };
};

/**
 * PESDK UIs have certain sizes for layouts
 * In order to keep it variable and not hard coded
 * these objects were created
 *
 * They are provided to the component tree same way as theme is provided
 * Currently this is not a part user facing API, but maybe someday ¯\_(ツ)_/¯
 */
var fontSystem = {
    /** Titles */
    headline1: { size: 16, letterSpacing: 1.5, case: 'uppercase' },
    /** Subtitles that group different elements */
    headline2: { size: 14, letterSpacing: 0.8, case: 'uppercase' },
    /** Carousel, input text, modal body */
    body: { size: 13, letterSpacing: 0, case: 'none' },
    /** Card labels, input labels */
    label: { size: 13, letterSpacing: 0, case: 'capitalize' },
    /** Card labels, input labels */
    label2: { size: 12, letterSpacing: 0, case: 'capitalize' },
    /** Primary / Secondary buttons */
    button1: { size: 12, letterSpacing: 1.2, case: 'uppercase' },
    /** Buttons without shape eg: Undo/Redo */
    button2: { size: 14, letterSpacing: 0, case: 'capitalize' },
};
var zIndex = {
    toast: 2,
    controlsBar: 5,
    buttonGroup: 5,
    toolControlBar: 6,
    toolbar: 7,
    label: 10,
    disable: 11,
    canvas: {
        knob: 4,
        bar: 5,
        controls: 6,
        snappingGuide: 1,
        crop: {
            grid: 2,
            dragImage: 3,
            backdrop: 4,
        },
        webcam: {
            backdrop: 7,
        },
    },
    input: {
        list: 6,
    },
    button: {
        float: 5,
    },
    modal: {
        backdrop: 100,
    },
};
var getMeasurements = function () {
    var spacer = 8;
    var toolControlBarWidth = 230;
    var toolControlBarSidePadding = 3 * spacer;
    var largeCard = toolControlBarWidth - 2 * toolControlBarSidePadding;
    // 2 extra spacer here is because when there are 2 cards in a row, 1 spacer in between
    var smallCard = (largeCard - 2 * spacer) / 3;
    // 1 extra spacer here is because when there are 2 cards in a row, 1 spacer in between
    var mediumCard = (largeCard - spacer) / 2;
    return {
        advancedUIToolbar: {
            width: 55,
            itemHeight: 48,
            seperatorHeight: 20,
        },
        advancedToolControlBar: {
            width: toolControlBarWidth,
            padding: 2 * spacer + "px " + toolControlBarSidePadding + "px",
        },
        advancedCard: {
            small: { height: smallCard, width: smallCard },
            medium: { height: mediumCard, width: mediumCard },
            large: { height: 86, width: largeCard },
        },
        advancedSpacer: 8,
        basicCanvasOffset: 35 + 76 - 88,
        basicUIToolbar: {
            openHeight: 88,
            closeHeight: 35,
        },
        basicToolControlBar: {
            itemsBarHeight: 72,
            controlsBarHeight: 80,
            // itemsBarHeight + closeHeight + padding
            maxHeight: 72 + 35 + 4,
            maxWidth: 300,
        },
        basicCard: {
            medium: { height: 56, width: 90 },
            large: { height: 60, width: 110 },
        },
        basicSpacer: 8,
        mainCanvasActionBar: {
            height: 50,
        },
        crop: {
            minSize: 50,
        },
        canvas: {
            marginTop: 0,
        },
        canvasControls: {
            sprite: {
                controlOffset: 16,
                rotateHandle: {
                    height: 16,
                },
                minSize: 50,
                controlPadding: 16,
            },
            knob: {
                size: 16,
                touchable: {
                    desktop: 24,
                },
            },
            corner: {
                size: 14,
                touchable: {
                    desktop: 32,
                    mobile: 48,
                },
                borderWidth: 4,
            },
            width: {
                size: 14,
            },
        },
        buttons: {
            float: {
                size: 56,
            },
        },
        color: {
            colorItem: {
                button: {
                    size: 20,
                },
            },
            colorPicker: {
                width: 214,
                saturationSlider: {
                    height: 150,
                },
                thumb: {
                    size: 14,
                },
                arrow: {
                    width: 36,
                },
            },
        },
        fontSystem: fontSystem,
        zIndex: zIndex,
    };
};

var defaultTheme = getDarktheme();
var defaultMeasurements = getMeasurements();
var defaultStyledTheme = __assign({}, defaultTheme, { measurements: defaultMeasurements });

var getTheme = function (theme) {
    if (theme === 'light') {
        return getLightTheme;
    }
    return getDarktheme;
};
var themeManager = function (theme, customThemes) {
    var themefn = getTheme(theme);
    if (customThemes && customThemes[theme]) {
        var _a = customThemes[theme], primary = _a.primary, background = _a.background, foreground = _a.foreground;
        var input_1 = { primary: primary, background: background, foreground: foreground };
        var themeInput = Object.keys(input_1).reduce(function (acc, key) {
            var _a;
            if (input_1[key]) {
                return __assign({}, acc, (_a = {}, _a[key] = input_1[key], _a));
            }
            return acc;
        }, {});
        return deepmergeAll([themefn(themeInput), customThemes[theme]]);
    }
    return themefn() || defaultTheme;
};

var allowedValues = [
    'canvas',
    'advancedUIToolbar',
    'basicUIToolbar',
    'mainCanvasActionBar',
];
var measurementsManager = function (customMeasurements) {
    var measurements = getMeasurements();
    if (customMeasurements) {
        var pickedTarget_1 = {};
        Object.keys(customMeasurements).forEach(function (key) {
            if (allowedValues.indexOf(key) !== -1) {
                pickedTarget_1[key] = customMeasurements[key];
            }
        });
        return deepmergeAll([measurements, pickedTarget_1]);
    }
    return measurements;
};

var initialState = {
    config: defaultConfig,
    locale: en,
    theme: defaultTheme,
    measurements: defaultMeasurements,
};
var ConfigStore = /** @class */ (function () {
    function ConfigStore() {
        this.checkDefaultToolAvailability = function (defaultTool, allTools) {
            return allTools.indexOf(defaultTool) !== -1;
        };
        this.state = observable(initialState);
        this.events = new UIEventEmitter();
    }
    ConfigStore.prototype.saveConfig = function (configByUser) {
        if (configByUser.mainCanvasActions && configByUser.mainCanvasActions.length !== 4) {
            configByUser.mainCanvasActions.length = 4;
        }
        var mergedConfig = deepmergeAll([defaultConfig, configByUser]);
        var config = mergedConfig;
        var locale = localeManager(config.language, config.custom.languages);
        var theme = themeManager(config.theme, config.custom.themes);
        var measurements = measurementsManager(config.custom.measurements);
        var provider = config.library.provider;
        delete config.language;
        delete config.custom.languages;
        delete config.custom.themes;
        delete config.library.provider;
        var allTools = config.tools.reduce(function (acc, tool) {
            if (typeof tool === 'object') {
                return __spread(acc, tool);
            }
            return __spread(acc, [tool]);
        }, []);
        if (!allTools.length) {
            // eslint-disable-next-line no-console
            console.error("Empty list input for tools");
            allTools = DefaultTools.reduce(function (acc, tool) {
                if (typeof tool === 'object') {
                    return __spread(acc, tool);
                }
                return __spread(acc, [tool]);
            }, []);
        }
        var doesDefaulttoolExist = this.checkDefaultToolAvailability(config.defaultTool, allTools);
        if (!doesDefaulttoolExist) {
            // eslint-disable-next-line no-console
            console.warn("Configured default tool " + config.defaultTool + " is not a part of configured list of tools: " + allTools.join(' ') + ", using fallback default Tool " + allTools[0] + " is being used, pls change config.defaultTool to change the fallback tool")[config.defaultTool] = allTools;
        }
        this.state.config = config;
        this.state.locale = locale;
        this.state.theme = theme;
        this.state.measurements = measurements;
        ScrollManager.addScrollStyles(this.state.theme.scrollbar.handleColor);
        var assetConfig = this.buildCustomAssetsConfig();
        this.assetProvider = new AssetManager(assetConfig);
        this.loadThemeFont();
        return provider;
    };
    Object.defineProperty(ConfigStore.prototype, "config", {
        get: function () {
            return this.state.config;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigStore.prototype, "locale", {
        get: function () {
            return this.state.locale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigStore.prototype, "theme", {
        get: function () {
            return this.state.theme;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigStore.prototype, "measurements", {
        get: function () {
            return this.state.measurements;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigStore.prototype, "tools", {
        get: function () {
            return this.config.tools.reduce(function (acc, tool) {
                if (typeof tool === 'string') {
                    return __spread(acc, [tool]);
                }
                return __spread(acc, [''], tool);
            }, []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigStore.prototype, "defaultTool", {
        get: function () {
            return this.config.defaultTool;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigStore.prototype, "isOrderDefault", {
        get: function () {
            return this.config.order === 'default';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigStore.prototype, "isLayoutAdvanced", {
        get: function () {
            return this.config.layout === 'advanced';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConfigStore.prototype, "displayCloseButton", {
        get: function () {
            return this.config.mainCanvasActions.indexOf(CanvasAction.CLOSE) !== -1;
        },
        enumerable: true,
        configurable: true
    });
    ConfigStore.prototype.loadThemeFont = function () {
        var typography = this.theme.typography;
        if (!typography.skipLoading) {
            this.assetProvider.getFontManager().injectFonts([typography]);
        }
    };
    ConfigStore.prototype.buildCustomAssetsConfig = function () {
        var configuredTools = this.tools;
        var toolConfig = toJS(this.state.config);
        var basePath = this.state.config.assetBaseUrl;
        var theme = this.state.theme;
        var filter = configuredTools.indexOf(Tool.FILTER) !== -1 ? toolConfig[Tool.FILTER] : undefined;
        var focus = configuredTools.indexOf(Tool.FOCUS) !== -1 ? toolConfig[Tool.FOCUS] : undefined;
        var adjustment = configuredTools.indexOf(Tool.ADJUSTMENT) !== -1 ? toolConfig[Tool.ADJUSTMENT] : undefined;
        var sticker = configuredTools.indexOf(Tool.STICKER) !== -1 ? toolConfig[Tool.STICKER] : undefined;
        var frame = configuredTools.indexOf(Tool.FRAME) !== -1 ? toolConfig[Tool.FRAME] : undefined;
        var overlay = configuredTools.indexOf(Tool.OVERLAY) !== -1 ? toolConfig[Tool.OVERLAY] : undefined;
        var transform = configuredTools.indexOf(Tool.TRANSFORM) !== -1 ? toolConfig[Tool.TRANSFORM] : undefined;
        var text = configuredTools.indexOf(Tool.TEXT) !== -1 ? toolConfig[Tool.TEXT] : undefined;
        var textdesign = configuredTools.indexOf(Tool.TEXT_DESIGN) !== -1 ? toolConfig[Tool.TEXT_DESIGN] : undefined;
        return {
            basePath: basePath,
            theme: theme,
            filter: filter,
            focus: focus,
            sticker: sticker,
            frame: frame,
            overlay: overlay,
            transform: transform,
            text: text,
            adjustment: adjustment,
            textdesign: textdesign,
        };
    };
    __decorate([
        action
    ], ConfigStore.prototype, "saveConfig", null);
    __decorate([
        computed
    ], ConfigStore.prototype, "config", null);
    __decorate([
        computed
    ], ConfigStore.prototype, "locale", null);
    __decorate([
        computed
    ], ConfigStore.prototype, "theme", null);
    __decorate([
        computed
    ], ConfigStore.prototype, "measurements", null);
    __decorate([
        computed
    ], ConfigStore.prototype, "tools", null);
    __decorate([
        computed
    ], ConfigStore.prototype, "defaultTool", null);
    __decorate([
        computed
    ], ConfigStore.prototype, "isOrderDefault", null);
    __decorate([
        computed
    ], ConfigStore.prototype, "isLayoutAdvanced", null);
    __decorate([
        computed
    ], ConfigStore.prototype, "displayCloseButton", null);
    return ConfigStore;
}());

var initialState$1 = {
    tool: null,
    isWebcam: false,
    image: '',
};
var ActiveStore = /** @class */ (function () {
    function ActiveStore(editor) {
        var _this = this;
        this.newImage = function (image) {
            _this.editor.init(image);
        };
        this.editor = editor;
        this.state = observable(initialState$1);
    }
    ActiveStore.isValidURL = function (str) {
        try {
            // eslint-disable-next-line no-new
            new URL(str);
            return true;
        }
        catch (_) {
            return false;
        }
    };
    ActiveStore.isImageElement = function (image) {
        return image instanceof HTMLImageElement;
    };
    ActiveStore.prototype.selectTool = function (tool, isBasic) {
        if (isBasic === void 0) { isBasic = false; }
        tool = this.state.tool === tool && isBasic ? null : tool;
        this.editor.onToolChange(this.state.tool, tool);
        this.state.tool = tool;
        var dimensions = this.editor.engineMediator.engine.getOutputDimensions();
        var size = Math.max(Math.min(dimensions.width, dimensions.height) * 0.05, 1);
        switch (tool) {
            case Tool.TEXT:
                this.editor.spriteStore.textToolStore.addOrselect();
                break;
            case Tool.TEXT_DESIGN:
                this.editor.spriteStore.textDesignToolStore.addOrselect();
                break;
            case Tool.BRUSH:
                this.editor.brushToolStore.changeSize(size);
                break;
            case Tool.TRANSFORM:
                this.editor.transformToolStore.applyDefaultCrop(true);
                this.editor.historyStore.saveTransformLocalSnapshotIndex();
                break;
        }
    };
    ActiveStore.prototype.selectWebcam = function (isWebcam) {
        this.state.isWebcam = isWebcam;
    };
    ActiveStore.prototype.setImage = function (image) {
        if (typeof image === 'string' && !ActiveStore.isValidURL(image)) {
            this.state.image = this.editor.assetProvider.getAbsolutePath(image);
        }
        else {
            this.state.image = image;
        }
        if (this.isWebcam) {
            this.state.isWebcam = false;
        }
    };
    Object.defineProperty(ActiveStore.prototype, "webcamLabel", {
        get: function () {
            return this.editor.libraryStore.locale.controls.buttonWebcamClose;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActiveStore.prototype, "tool", {
        get: function () {
            return this.state.tool;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActiveStore.prototype, "isWebcam", {
        get: function () {
            return this.state.isWebcam;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActiveStore.prototype, "image", {
        get: function () {
            return this.state.image;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        action
    ], ActiveStore.prototype, "selectTool", null);
    __decorate([
        action
    ], ActiveStore.prototype, "selectWebcam", null);
    __decorate([
        action
    ], ActiveStore.prototype, "setImage", null);
    __decorate([
        action
    ], ActiveStore.prototype, "newImage", void 0);
    __decorate([
        computed
    ], ActiveStore.prototype, "webcamLabel", null);
    __decorate([
        computed
    ], ActiveStore.prototype, "tool", null);
    __decorate([
        computed
    ], ActiveStore.prototype, "isWebcam", null);
    __decorate([
        computed
    ], ActiveStore.prototype, "image", null);
    return ActiveStore;
}());

/**
 * Creates a Image conatiner
 * this is the base of the PhotoEditor SDK
 */
var ImageContainerMediator = /** @class */ (function () {
    function ImageContainerMediator(editor) {
        this.editor = editor;
    }
    /**
     * Sets/updates background image to the given image conatiner
     * @param image
     */
    ImageContainerMediator.prototype.setBackgroundImage = function (image) {
        if (!this.container) {
            this.container = this.engine.addImage({ image: image, blendMode: BlendMode.NORMAL, opacity: 1 });
        }
        else {
            this.container.setData({ image: image });
        }
    };
    ImageContainerMediator.prototype.getchildren = function () {
        return this.container.getChildren();
    };
    /**
     * Based on image type, loads the image as elemnt or as url
     */
    ImageContainerMediator.prototype.addImageToContainer = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var imageUrl = _this.editor.activeStore.image;
            var imageElement;
            if (ActiveStore.isImageElement(imageUrl)) {
                imageElement = imageUrl;
                _this.setBackgroundImage(imageElement);
                resolve();
            }
            else {
                var imageRawUrl = _this.editor.libraryStore.getRawUrl(imageUrl);
                _this.getImageElement(imageRawUrl)
                    .then(function (element) {
                    imageElement = element;
                    _this.setBackgroundImage(imageElement);
                    resolve();
                })
                    .catch(function (error) {
                    // eslint-disable-next-line prefer-promise-reject-errors
                    reject({ identifier: 'imageLoading', message: error.message });
                });
            }
        });
    };
    /**
     * Loads image before adding to the image container
     * @param imageUrl
     */
    ImageContainerMediator.prototype.getImageElement = function (imageUrl) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var image = new Image();
            image.addEventListener('load', function () {
                resolve(image);
            });
            image.addEventListener('error', function (error) {
                reject(error);
            });
            image.crossOrigin = _this.editor.configStore.config.engine.crossOrigin;
            image.src = imageUrl;
        });
    };
    /** Returns the image container id, if it exists */
    ImageContainerMediator.prototype.getImgageContainerId = function () {
        return this.container ? this.container.getID() : '';
    };
    Object.defineProperty(ImageContainerMediator.prototype, "engine", {
        /** Internal getters */
        get: function () {
            return this.editor.engine;
        },
        enumerable: true,
        configurable: true
    });
    return ImageContainerMediator;
}());

/**
 * Creates and handles output container
 * An output container is a special type of container, which is used to define the area
 * of the world that gets rendered by the engine. It also defines the resolution which
 * this output should be rendered at.
 */
var OutputContainerMediator = /** @class */ (function () {
    function OutputContainerMediator(editor) {
        var _this = this;
        /**
         * Applying transform for a new image
         * starts with setting image size as resolution and setting image container center as position
         */
        this.applyNewImageTransform = function () {
            var _a = _this.editor.engineMediator.image.container.getBounds(), size = _a.size, width = _a.width, height = _a.height;
            var outputContainer = _this.container;
            outputContainer.setTransform(RectTransform.IDENTITY);
            outputContainer.setResolution(size);
            outputContainer.setPivot(0.5, 0.5);
            outputContainer.setPosition({ x: width / 2, y: height / 2 });
        };
        this.editor = editor;
    }
    Object.defineProperty(OutputContainerMediator.prototype, "engine", {
        get: function () {
            return this.editor.engine;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputContainerMediator.prototype, "container", {
        get: function () {
            return this.engine.getOutputContainer();
        },
        enumerable: true,
        configurable: true
    });
    return OutputContainerMediator;
}());

function proportionalScale(bounds, toFit) {
    var boundsAspect = bounds.width / bounds.height;
    var toFitAspect = toFit.width / toFit.height;
    if (boundsAspect > toFitAspect) {
        return bounds.height / toFit.height;
    }
    return bounds.width / toFit.width;
}

var initialState$2 = {
    transform: RectTransform.IDENTITY,
};
/**
 * Creates and Handles preview container
 * A preview instance encapsulates the necessary data for the engine to render
 * a preview of its output into a separate canvas at an optionally lower quality.
 */
var PreviewContainerMediator = /** @class */ (function () {
    function PreviewContainerMediator(editor) {
        /**
         * Initial transform is being used in case of transform tool
         * To go back to this transfom when transform tool is left
         */
        this.initialTransform = RectTransform.IDENTITY;
        this.editor = editor;
        this.state = observable(initialState$2);
    }
    PreviewContainerMediator.prototype.createPreview = function (canvas) {
        this.container = this.editor.engine.createPreview(canvas);
    };
    /**
     * Initial Settings
     * Runs on every image change
     * Preview transform depends on output resolution and canvas size
     */
    PreviewContainerMediator.prototype.updateTransform = function (rotation, upateInitial) {
        if (rotation === void 0) { rotation = 0; }
        if (upateInitial === void 0) { upateInitial = true; }
        var transform = this.calculateTransform(rotation);
        if (transform.scale.x) {
            if (upateInitial) {
                this.saveInitialTransform(transform);
            }
            else {
                this.savePreviewTransform(transform);
            }
            this.container.setTransform(this.state.transform);
            return true;
        }
        return false;
    };
    PreviewContainerMediator.prototype.saveInitialTransform = function (transform) {
        this.initialTransform = transform;
        this.savePreviewTransform(transform);
    };
    PreviewContainerMediator.prototype.savePreviewTransform = function (transform) {
        var _this = this;
        runInAction(function () {
            _this.state.transform.position = transform.position;
            _this.state.transform.scale = transform.scale;
            _this.state.transform.rotation = transform.rotation;
            var dpr = Editor.devicePixelRatio;
            _this.previewTransformWithoutDpr = {
                position: new Vector2(transform.position).divide(dpr),
                scale: new Vector2(transform.scale).divide(dpr),
                rotation: transform.rotation,
            };
        });
    };
    Object.defineProperty(PreviewContainerMediator.prototype, "transform", {
        get: function () {
            return this.state.transform;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PreviewContainerMediator.prototype, "position", {
        get: function () {
            return this.state.transform.position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PreviewContainerMediator.prototype, "scale", {
        get: function () {
            return this.state.transform.scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PreviewContainerMediator.prototype, "rotation", {
        get: function () {
            return this.state.transform.rotation;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * includePixelRatio is used only in scale calculation
     * Because Position is used only in the UI
     */
    PreviewContainerMediator.prototype.calculateTransform = function (rotation) {
        if (rotation === void 0) { rotation = 0; }
        var dpr = Editor.devicePixelRatio;
        var _a = this.editor.canvasStore.canvasSize, width = _a.width, height = _a.height;
        var outputSize = this.editor.engine.getOutputDimensions();
        var scaleToFit = proportionalScale({ width: width, height: height }, outputSize);
        var padding = 0.95;
        if (window.innerWidth < 600) {
            padding = 0.98;
        }
        scaleToFit *= padding;
        /** The top-bottom padding has to be min canvasBarHeight * 2 for the controls to show properly */
        var diff = height - outputSize.height * scaleToFit;
        if (diff < this.editor.configStore.measurements.mainCanvasActionBar.height * 2) {
            scaleToFit = proportionalScale({ width: width, height: height - 2 * diff }, outputSize);
            scaleToFit *= padding;
        }
        scaleToFit *= dpr;
        scaleToFit = parseFloat(scaleToFit.toFixed(2));
        var position = { x: (width * dpr) / 2, y: (height * dpr) / 2 };
        var scale = { x: scaleToFit, y: scaleToFit };
        return new RectTransform(position, scale, rotation);
    };
    __decorate([
        action
    ], PreviewContainerMediator.prototype, "updateTransform", null);
    __decorate([
        action
    ], PreviewContainerMediator.prototype, "savePreviewTransform", null);
    __decorate([
        computed
    ], PreviewContainerMediator.prototype, "transform", null);
    __decorate([
        computed
    ], PreviewContainerMediator.prototype, "position", null);
    __decorate([
        computed
    ], PreviewContainerMediator.prototype, "scale", null);
    __decorate([
        computed
    ], PreviewContainerMediator.prototype, "rotation", null);
    return PreviewContainerMediator;
}());

var _a$1;
/**
 * There is a semi-fixed order in which containers/effects need to be applied to the background image:
 * ArtFilter
 * Filter
 * Adjustments
 * Focus
 * Sprites (Text, Sticker, Text-Design, Brush) with order
 * Overlay
 * Frame
 */
var OrderHelper = /** @class */ (function () {
    function OrderHelper() {
        this.imageContainerOrder = [];
        this.spriteContainerOrder = [];
    }
    OrderHelper.checkTool = function (tool) {
        if ([Tool.STICKER, Tool.TEXT, Tool.TEXT_DESIGN, Tool.BRUSH, Tool.FRAME].indexOf(tool) !== -1) {
            throw new Error('addIndex is used for non sprites, for sprites use addSprite');
        }
    };
    OrderHelper.remove = function (tool, order) {
        var index = order.findIndex(function (o) { return o === tool; });
        if (index !== -1) {
            order.splice(index, 1);
        }
        return undefined;
    };
    OrderHelper.indexForOrder = function (containerIndex, containerOrder, tool) {
        var toolIndex = containerIndex[tool];
        var currentIndex = containerOrder.findIndex(function (o) { return o === tool; });
        if (currentIndex !== -1) {
            return { index: currentIndex, order: containerOrder };
        }
        var length = containerOrder.length;
        if (length) {
            var i = void 0;
            for (i = 0; i < length; i += 1) {
                var thisTool = containerOrder[i];
                var thisToolIndex = containerIndex[thisTool];
                if (toolIndex < thisToolIndex) {
                    containerOrder = __spread(containerOrder.slice(0, i), [tool], containerOrder.slice(i));
                    return { index: i, order: containerOrder };
                }
            }
        }
        containerOrder.push(tool);
        return { index: containerOrder.length - 1, order: containerOrder };
    };
    OrderHelper.prototype.addIndex = function (tool) {
        OrderHelper.checkTool(tool);
        var _a = OrderHelper.indexForOrder(OrderHelper.IMAGE_CONTAINER_INDEX, this.imageContainerOrder, tool), index = _a.index, order = _a.order;
        this.imageContainerOrder = order;
        return index;
    };
    OrderHelper.prototype.removeIndex = function (tool) {
        OrderHelper.checkTool(tool);
        OrderHelper.remove(tool, this.imageContainerOrder);
    };
    OrderHelper.prototype.getSpriteIndex = function (id) {
        var index = this.spriteContainerOrder.findIndex(function (o) { return o === id; });
        return index + this.imageContainerOrder.length - 1;
    };
    OrderHelper.prototype.addSprite = function (id) {
        this.spriteContainerOrder.push(id);
        return this.imageContainerOrder.length + this.spriteContainerOrder.length - 1;
    };
    OrderHelper.prototype.removeSprite = function (id) {
        OrderHelper.remove(id, this.spriteContainerOrder);
    };
    OrderHelper.prototype.renameSprite = function (id, replacement) {
        var index = this.spriteContainerOrder.findIndex(function (s) { return s === id; });
        if (index !== -1) {
            this.spriteContainerOrder[index] = replacement;
        }
    };
    OrderHelper.prototype.getLastSpriteId = function () {
        var length = this.spriteContainerOrder.length;
        return this.spriteContainerOrder[length - 1];
    };
    OrderHelper.prototype.bringToFront = function (id) {
        var index = this.spriteContainerOrder.findIndex(function (o) { return o === id; });
        if (index !== -1) {
            this.spriteContainerOrder.splice(index, 1);
            this.spriteContainerOrder.push(id);
        }
        return this.getLastSpriteIndex();
    };
    OrderHelper.prototype.getLastSpriteIndex = function () {
        return this.imageContainerOrder.length + this.spriteContainerOrder.length - 1;
    };
    OrderHelper.IMAGE_CONTAINER_INDEX = (_a$1 = {},
        _a$1[Tool.ART_FILTER] = 0,
        _a$1[Tool.FILTER] = 1,
        _a$1[Tool.ADJUSTMENT] = 2,
        _a$1[Tool.FOCUS] = 3,
        _a$1[Tool.OVERLAY] = 4,
        _a$1);
    return OrderHelper;
}());

/**
 * Mediator class between Engine and Editor
 * Takes care of creating an engine instance and handles instances of containers
 */
var EngineMediator = /** @class */ (function () {
    function EngineMediator(editor) {
        this.orderHelper = new OrderHelper();
        var engineConfig = editor.configStore.config.engine;
        this.engine = new LegacyEngineAdapter(__assign({}, engineConfig, { license: editor.configStore.config.license, assetProvider: editor.configStore.assetProvider }));
        this.image = new ImageContainerMediator(editor);
        this.output = new OutputContainerMediator(editor);
        this.preview = new PreviewContainerMediator(editor);
        this.editor = editor;
    }
    EngineMediator.prototype.render = function (preview) {
        return this.engine.render(preview);
    };
    EngineMediator.prototype.previewSpaceToWorldSpace = function (point, useOutputWithoutFlip) {
        var previewTransform = this.preview.previewTransformWithoutDpr;
        if (isNumber(point)) {
            var originInWorld = this.editor.engine.convertPointFromPreviewIntoWorldSpace(Vector2.ZERO, previewTransform, useOutputWithoutFlip);
            var vecInWorld = this.editor.engine.convertPointFromPreviewIntoWorldSpace({ x: point, y: 0 }, previewTransform, useOutputWithoutFlip);
            return Vector2.distance(new Vector2(originInWorld), new Vector2(vecInWorld));
        }
        return this.editor.engine.convertPointFromPreviewIntoWorldSpace(point, previewTransform, useOutputWithoutFlip);
    };
    EngineMediator.prototype.worldSpaceToPreviewSpace = function (point) {
        var previewTransform = this.preview.previewTransformWithoutDpr;
        if (isNumber(point)) {
            var originInPreview = this.editor.engine.convertPointFromWorldIntoPreviewSpace(Vector2.ZERO, previewTransform);
            var vecInWorld = this.editor.engine.convertPointFromWorldIntoPreviewSpace({ x: point, y: 0 }, previewTransform);
            return Vector2.distance(new Vector2(originInPreview), new Vector2(vecInWorld));
        }
        return this.editor.engine.convertPointFromWorldIntoPreviewSpace(point, previewTransform);
    };
    EngineMediator.prototype.outputSpaceToWorldSpace = function (point) {
        if (isNumber(point)) {
            return ConversionUtils.getScalarInWorldSpace(point, this.editor.engine.getOutputContainer());
        }
        return ConversionUtils.getPointInWorldSpace(point, this.editor.engine.getOutputContainer());
    };
    EngineMediator.prototype.previewSpaceToOutputSpace = function (point) {
        var previewTransform = this.preview.previewTransformWithoutDpr;
        if (isNumber(point)) {
            var originInWorld = this.editor.engine.convertPointFromPreviewIntoOutputSpace(Vector2.ZERO, previewTransform);
            var vecInWorld = this.editor.engine.convertPointFromPreviewIntoOutputSpace({ x: point, y: 0 }, previewTransform);
            return Vector2.distance(new Vector2(originInWorld), new Vector2(vecInWorld));
        }
        return this.editor.engine.convertPointFromPreviewIntoOutputSpace(point, previewTransform);
    };
    EngineMediator.prototype.previewSpaceToFlippedPreviewSpace = function (point) {
        return this.editor.engine.convertPointFromPreviewIntoFlippedPreviewSpace(point);
    };
    return EngineMediator;
}());

var HistoryManager = /** @class */ (function () {
    function HistoryManager() {
        this.snapshots = [];
        this.observeIndex = observable.box(-1);
    }
    HistoryManager.prototype.addSnapshot = function (snapshot) {
        if (this.index === this.snapshots.length - 1) {
            this.snapshots = this.snapshots.concat(JSON.stringify(snapshot));
        }
        else {
            this.snapshots = __spread(this.snapshots.slice(0, this.index + 1), [JSON.stringify(snapshot)]);
        }
        this.observeIndex.set(this.snapshots.length - 1);
    };
    HistoryManager.prototype.getCurrentState = function () {
        return this.snapshots[this.index];
    };
    HistoryManager.prototype.reset = function () {
        this.snapshots = [];
        this.observeIndex.set(-1);
    };
    HistoryManager.prototype.undo = function () {
        if (this.canUndo) {
            this.observeIndex.set(this.index - 1);
            return JSON.parse(this.getCurrentState());
        }
        return null;
    };
    HistoryManager.prototype.redo = function () {
        if (this.canRedo) {
            this.observeIndex.set(this.index + 1);
            return JSON.parse(this.getCurrentState());
        }
        return null;
    };
    HistoryManager.prototype.discardSnapshotsfromIndex = function (index) {
        if (index > 0 && index < this.snapshots.length - 1) {
            this.snapshots = this.snapshots.slice(0, index);
            this.observeIndex.set(this.snapshots.length - 1);
        }
    };
    Object.defineProperty(HistoryManager.prototype, "index", {
        get: function () {
            return this.observeIndex.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HistoryManager.prototype, "canUndo", {
        get: function () {
            return this.index > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HistoryManager.prototype, "canRedo", {
        get: function () {
            return this.snapshots.length - 1 > this.index;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        computed
    ], HistoryManager.prototype, "index", null);
    __decorate([
        computed
    ], HistoryManager.prototype, "canUndo", null);
    __decorate([
        computed
    ], HistoryManager.prototype, "canRedo", null);
    return HistoryManager;
}());

var HistoryStore = /** @class */ (function () {
    function HistoryStore(editor) {
        var _this = this;
        this.localTransformStartIndex = null;
        this.undo = function () {
            var appState = _this.appHistoryManager.undo();
            _this.applyState(appState);
        };
        this.redo = function () {
            var appState = _this.appHistoryManager.redo();
            _this.applyState(appState);
        };
        this.editor = editor;
        this.appHistoryManager = new HistoryManager();
    }
    Object.defineProperty(HistoryStore.prototype, "canUndo", {
        get: function () {
            return this.appHistoryManager.canUndo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HistoryStore.prototype, "canRedo", {
        get: function () {
            return this.appHistoryManager.canRedo;
        },
        enumerable: true,
        configurable: true
    });
    HistoryStore.prototype.getAppState = function () {
        var _a;
        var adjustmentsState = toJS(this.editor.adjustmentsToolStore.state);
        var filterState = toJS(this.editor.filterToolStore.state);
        var focusState = this.editor.focusToolStore.getFocusStateForHistory();
        var overlayState = toJS(this.editor.overlayToolStore.state);
        var frameState = toJS(this.editor.frameToolStore.state);
        var strokes = this.editor.brushToolStore.strokes || { strokes: [] };
        return _a = {},
            _a[Tool.ADJUSTMENT] = adjustmentsState,
            _a[Tool.FILTER] = filterState,
            _a[Tool.FOCUS] = focusState,
            _a[Tool.OVERLAY] = overlayState,
            _a[Tool.FRAME] = frameState,
            _a[Tool.BRUSH] = strokes,
            _a.sprite = {
                spriteIdList: [],
            },
            _a;
    };
    HistoryStore.prototype.addInitialSnapshot = function () {
        var initialState = this.getAppState();
        this.appHistoryManager.addSnapshot({ state: initialState, type: "add" /* ADD */, description: 'Initial State' });
    };
    HistoryStore.prototype.addSnapshot = function (state, type, description) {
        if (state === void 0) { state = this.getAppState(); }
        if (state) {
            if (state.sprite || state.transform) {
                state = __assign({}, this.getAppState(), state);
            }
            this.appHistoryManager.addSnapshot({
                state: state,
                type: type,
                description: description,
            });
            this.editor.configStore.events.onHistoryChange();
        }
    };
    HistoryStore.prototype.saveTransformLocalSnapshotIndex = function () {
        if (this.localTransformStartIndex === null) {
            this.localTransformStartIndex = this.appHistoryManager.index;
        }
    };
    /**
     * Transform tool has to have a local history state,
     * since the crop is saved only when you go out of transform tool
     * So all the local changes in transform are saved as local snapshots
     * localSnapshots will be deleted once you go out of transform tool
     */
    HistoryStore.prototype.removeTransformLocalSnapshots = function () {
        if (this.localTransformStartIndex !== null) {
            this.appHistoryManager.discardSnapshotsfromIndex(this.localTransformStartIndex);
            this.localTransformStartIndex = null;
        }
    };
    HistoryStore.prototype.applyState = function (_a) {
        var state = _a.state;
        return __awaiter(this, void 0, void 0, function () {
            var e_1, _b, tools, tools_1, tools_1_1, tool, _c, e_1_1, error_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 23, , 24]);
                        if (!state) return [3 /*break*/, 22];
                        tools = Object.keys(state);
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 18, 19, 20]);
                        tools_1 = __values(tools), tools_1_1 = tools_1.next();
                        _d.label = 2;
                    case 2:
                        if (!!tools_1_1.done) return [3 /*break*/, 17];
                        tool = tools_1_1.value;
                        _c = tool;
                        switch (_c) {
                            case Tool.FILTER: return [3 /*break*/, 3];
                            case Tool.ADJUSTMENT: return [3 /*break*/, 5];
                            case Tool.OVERLAY: return [3 /*break*/, 6];
                            case Tool.FRAME: return [3 /*break*/, 8];
                            case Tool.FOCUS: return [3 /*break*/, 10];
                            case Tool.BRUSH: return [3 /*break*/, 11];
                            case 'sprite': return [3 /*break*/, 12];
                            case 'localTransform': return [3 /*break*/, 14];
                            case Tool.TRANSFORM: return [3 /*break*/, 15];
                        }
                        return [3 /*break*/, 16];
                    case 3: return [4 /*yield*/, this.editor.filterToolStore.updateStateFromHistory(state[tool])];
                    case 4:
                        _d.sent();
                        return [3 /*break*/, 16];
                    case 5:
                        this.editor.adjustmentsToolStore.updateStateFromHistory(state[tool]);
                        return [3 /*break*/, 16];
                    case 6: return [4 /*yield*/, this.editor.overlayToolStore.updateStateFromHistory(state[tool])];
                    case 7:
                        _d.sent();
                        return [3 /*break*/, 16];
                    case 8: return [4 /*yield*/, this.editor.frameToolStore.updateStateFromHistory(state[tool])];
                    case 9:
                        _d.sent();
                        return [3 /*break*/, 16];
                    case 10:
                        this.editor.focusToolStore.updateStateFromHistory(state[tool], this.editor.canvasStore.sizeVector);
                        return [3 /*break*/, 16];
                    case 11:
                        this.editor.brushToolStore.updateStateFromHistory(state[tool]);
                        return [3 /*break*/, 16];
                    case 12: return [4 /*yield*/, this.editor.spriteStore.updateStateFromHistory(state[tool], this.editor.canvasStore.sizeVector)];
                    case 13:
                        _d.sent();
                        return [3 /*break*/, 16];
                    case 14:
                        this.editor.transformToolStore.updateLocalStateFromHistory(state.localTransform);
                        return [3 /*break*/, 16];
                    case 15:
                        this.editor.transformToolStore.updateStateFromHistory(state[tool]);
                        return [3 /*break*/, 16];
                    case 16:
                        tools_1_1 = tools_1.next();
                        return [3 /*break*/, 2];
                    case 17: return [3 /*break*/, 20];
                    case 18:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 20];
                    case 19:
                        try {
                            if (tools_1_1 && !tools_1_1.done && (_b = tools_1.return)) _b.call(tools_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 20: return [4 /*yield*/, this.editor.renderPromise()];
                    case 21:
                        _d.sent();
                        _d.label = 22;
                    case 22: return [3 /*break*/, 24];
                    case 23:
                        error_1 = _d.sent();
                        // eslint-disable-next-line no-console
                        console.error(error_1);
                        this.editor.modalStore.showActionModal({
                            identifier: 'unexpectedError',
                            error: error_1,
                            handlers: {
                                buttonYes: function () {
                                    window.location.reload();
                                },
                            },
                        });
                        return [3 /*break*/, 24];
                    case 24: return [2 /*return*/];
                }
            });
        });
    };
    HistoryStore.prototype.isDirty = function () {
        return this.appHistoryManager.snapshots.length > 1;
    };
    HistoryStore.prototype.reset = function () {
        this.appHistoryManager.reset();
    };
    __decorate([
        action
    ], HistoryStore.prototype, "undo", void 0);
    __decorate([
        action
    ], HistoryStore.prototype, "redo", void 0);
    __decorate([
        computed
    ], HistoryStore.prototype, "canUndo", null);
    __decorate([
        computed
    ], HistoryStore.prototype, "canRedo", null);
    return HistoryStore;
}());

var initialState$3 = {
    canvasSize: { height: 0, width: 0 },
};
var CanvasStore = /** @class */ (function () {
    function CanvasStore(editor) {
        this.canvasClickDisabled = observable.box(false);
        this.editor = editor;
        this.state = observable(initialState$3);
    }
    /**
     * Creating preview
     * Application workflow starts here, when canvas container component is initialised
     * This happens only once
     */
    CanvasStore.prototype.setCanvasElement = function (canvas) {
        this.canvas = canvas;
        this.editor.engineMediator.preview.createPreview(canvas);
        this.updateCanvasDimensions();
        this.editor.init(this.editor.configStore.config.image);
    };
    CanvasStore.prototype.updateCanvasDimensions = function () {
        var dpr = Editor.devicePixelRatio;
        this.canvas.width = this.canvasSize.width * dpr;
        this.canvas.height = this.canvasSize.height * dpr;
        this.canvas.style.width = this.canvasSize.width + "px";
        this.canvas.style.height = this.canvasSize.height + "px";
    };
    /**
     * Updating canvas size
     * happens also when window is resized
     */
    CanvasStore.prototype.saveDimensions = function (_a) {
        var height = _a.height, width = _a.width, render = _a.render;
        var heightOffset = this.editor.configStore.isLayoutAdvanced
            ? 0
            : this.editor.configStore.measurements.basicCanvasOffset;
        this.state.canvasSize.height = height - heightOffset;
        this.state.canvasSize.width = width;
        if (render) {
            this.editor.resize();
        }
    };
    CanvasStore.prototype.disableCanvasClick = function () {
        this.canvasClickDisabled.set(true);
    };
    CanvasStore.prototype.enableCanvasClick = function () {
        this.canvasClickDisabled.set(false);
    };
    Object.defineProperty(CanvasStore.prototype, "isCanvasClickable", {
        get: function () {
            return !this.canvasClickDisabled.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "canvasSize", {
        get: function () {
            return this.state.canvasSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "sizeVector", {
        get: function () {
            return Vector2.fromSize(this.state.canvasSize);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasStore.prototype, "sizeVectorMagnitude", {
        get: function () {
            return this.sizeVector.magnitude;
        },
        enumerable: true,
        configurable: true
    });
    CanvasStore.prototype.getContainersAtPreviewPoint = function (point) {
        var _this = this;
        var containers = this.editor.engine
            .getContainersAtPreviewPoint(point, this.editor.engineMediator.preview.previewTransformWithoutDpr)
            .map(function (container) { return container.getID(); })
            .filter(function (id) { return id !== _this.editor.engineMediator.image.getImgageContainerId(); });
        this.editor.spriteStore.onCanvasClick(containers);
    };
    __decorate([
        action
    ], CanvasStore.prototype, "setCanvasElement", null);
    __decorate([
        action
    ], CanvasStore.prototype, "updateCanvasDimensions", null);
    __decorate([
        action
    ], CanvasStore.prototype, "saveDimensions", null);
    __decorate([
        action
    ], CanvasStore.prototype, "disableCanvasClick", null);
    __decorate([
        action
    ], CanvasStore.prototype, "enableCanvasClick", null);
    __decorate([
        computed
    ], CanvasStore.prototype, "isCanvasClickable", null);
    __decorate([
        computed
    ], CanvasStore.prototype, "canvasSize", null);
    __decorate([
        computed
    ], CanvasStore.prototype, "sizeVector", null);
    __decorate([
        computed
    ], CanvasStore.prototype, "sizeVectorMagnitude", null);
    return CanvasStore;
}());

var initialState$4 = {
    type: null,
    modalIdentifier: null,
    show: false,
};
var ModalStore = /** @class */ (function () {
    function ModalStore(editor) {
        var _this = this;
        this.errorMessage = '';
        this.showActionModal = function (_a) {
            var identifier = _a.identifier, error = _a.error, handlers = _a.handlers;
            _this.state.show = true;
            _this.state.modalIdentifier = identifier;
            _this.handlers = __assign({}, (handlers || {}), { close: _this.hideModal });
            _this.errorMessage = error || '';
        };
        this.hideModal = function () {
            _this.state.show = false;
            _this.state.type = null;
        };
        this.configStore = editor.configStore;
        this.state = observable(initialState$4);
    }
    ModalStore.prototype.showInfoModal = function (identifier) {
        this.state.type = ModalType.INFO;
        this.state.modalIdentifier = identifier;
        this.state.show = true;
    };
    ModalStore.prototype.showModalOfType = function (type) {
        this.state.type = type;
        this.state.show = true;
    };
    Object.defineProperty(ModalStore.prototype, "infoModalProps", {
        get: function () {
            if (this.state.modalIdentifier) {
                var props = this.configStore.locale.infoModals[this.state.modalIdentifier];
                return {
                    show: this.state.show,
                    heading: props ? props.heading : '',
                    body: props ? props.body : '',
                };
            }
            return {
                show: false,
                heading: '',
                body: '',
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModalStore.prototype, "modalProps", {
        get: function () {
            var locale = this.configStore.locale;
            var props = this.getProps(ModalType.WARNING) || this.getProps(ModalType.ERROR);
            var preHeadingLocale = { error: locale.common.error, warning: locale.common.warning };
            if (this.show && props && props.message) {
                var type = props.type, message = props.message;
                var error = this.errorMessage;
                // eslint-disable-next-line no-template-curly-in-string
                message.body = message.body ? message.body.replace('${error}', error) : '';
                return { type: type, message: message, show: this.show, handlers: this.handlers, preHeadingLocale: preHeadingLocale };
            }
            return { show: initialState$4.show, handlers: this.handlers, preHeadingLocale: preHeadingLocale };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModalStore.prototype, "show", {
        get: function () {
            return this.state.show;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModalStore.prototype, "type", {
        get: function () {
            return this.state.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModalStore.prototype, "identifier", {
        get: function () {
            return this.state.modalIdentifier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModalStore.prototype, "positionOffset", {
        get: function () {
            var _a = this.configStore, isLayoutAdvanced = _a.isLayoutAdvanced, measurements = _a.measurements;
            var xOffset = measurements.advancedToolControlBar.width + measurements.advancedUIToolbar.width;
            var yOffset = measurements.basicCanvasOffset;
            return isLayoutAdvanced ? { x: xOffset / 2, y: 0 } : { x: 0, y: -yOffset };
        },
        enumerable: true,
        configurable: true
    });
    ModalStore.prototype.getProps = function (type) {
        var identifier = this.state.modalIdentifier;
        var locale = this.configStore.locale;
        if (type && Object.prototype.hasOwnProperty.call(locale[type + "Modals"], identifier)) {
            var message = locale[type + "Modals"][identifier];
            return { type: type, message: message };
        }
        return null;
    };
    __decorate([
        action
    ], ModalStore.prototype, "showActionModal", void 0);
    __decorate([
        action
    ], ModalStore.prototype, "showInfoModal", null);
    __decorate([
        action
    ], ModalStore.prototype, "showModalOfType", null);
    __decorate([
        computed
    ], ModalStore.prototype, "infoModalProps", null);
    __decorate([
        action
    ], ModalStore.prototype, "hideModal", void 0);
    __decorate([
        computed
    ], ModalStore.prototype, "modalProps", null);
    __decorate([
        computed
    ], ModalStore.prototype, "show", null);
    __decorate([
        computed
    ], ModalStore.prototype, "type", null);
    __decorate([
        computed
    ], ModalStore.prototype, "identifier", null);
    __decorate([
        computed
    ], ModalStore.prototype, "positionOffset", null);
    return ModalStore;
}());

var ScaleStore = /** @class */ (function () {
    function ScaleStore(editor) {
        var _this = this;
        this.defaultScale = 1;
        this.SCALE_LEVELS = [8.33, 12.5, 16.66, 25, 33.33, 50, 66.66, 100, 125, 150, 200, 300, 400, 500, 600].map(function (z) { return z / 100; });
        this.state = { position: { x: 0, y: 0 }, scaleIndex: -1 };
        this.offset = { x: 0, y: 0 };
        this.in = function () {
            if (_this.canZoomIn) {
                _this.state.scaleIndex += 1;
                _this.scaleRender();
            }
        };
        this.out = function () {
            if (_this.canZoomOut) {
                _this.state.scaleIndex -= 1;
                var _a = _this.checkOffset({ x: 0, y: 0 }), canDragX = _a.canDragX, canDragY = _a.canDragY, maxOffsetX = _a.maxOffsetX, maxOffsetY = _a.maxOffsetY;
                if (!canDragY) {
                    _this.offset.y = maxOffsetY;
                }
                if (!canDragX) {
                    _this.offset.x = maxOffsetX;
                }
                _this.savePosition();
                _this.scaleRender();
            }
        };
        this.setOffset = function (offset) {
            var _a = _this.checkOffset(offset), canDragX = _a.canDragX, canDragY = _a.canDragY;
            if (canDragX) {
                _this.offset.x = offset.x;
            }
            if (canDragY) {
                _this.offset.y = offset.y;
            }
            _this.scaleRender();
        };
        this.editor = editor;
    }
    ScaleStore.prototype.setInitialTransform = function (scale) {
        var _this = this;
        if (scale === void 0) { scale = 0; }
        var transform = this.editor.engineMediator.preview.transform;
        runInAction(function () {
            _this.setDefaultScale(Math.abs(scale || transform.scale.x));
            _this.setPosition(transform.position);
        });
    };
    ScaleStore.prototype.resetScale = function () {
        this.state.scaleIndex = -1;
    };
    ScaleStore.prototype.resetPosition = function () {
        var _a = this.editor.canvasStore.canvas, width = _a.width, height = _a.height;
        this.setPosition({ x: width / 2, y: height / 2 });
    };
    ScaleStore.prototype.resetOffset = function () {
        this.offset = { x: 0, y: 0 };
    };
    ScaleStore.prototype.setPosition = function (position) {
        this.state.position.x = position.x;
        this.state.position.y = position.y;
    };
    ScaleStore.prototype.savePosition = function () {
        this.setPosition(this.getPositionWithOffset());
        this.offset = { x: 0, y: 0 };
    };
    /**
     * Default Zoom scale is defined for every time an image is added to the container
     * calculated image scale is added to the ZOOM_LEVELS and is also set as defaultScale
     */
    ScaleStore.prototype.setDefaultScale = function (scale) {
        var _this = this;
        if (this.defaultScale !== 1) {
            var index = this.SCALE_LEVELS.findIndex(function (l) { return l === _this.defaultScale; });
            if (index !== -1) {
                this.SCALE_LEVELS = __spread(this.SCALE_LEVELS.slice(0, index), this.SCALE_LEVELS.slice(index + 1));
            }
        }
        scale = parseFloat(scale.toFixed(2));
        var defaultIndex = this.SCALE_LEVELS.findIndex(function (level, index) {
            if (index === 0) {
                return scale < level;
            }
            if (index === _this.SCALE_LEVELS.length - 1) {
                return level < scale;
            }
            return _this.SCALE_LEVELS[index - 1] < scale && scale < level;
        });
        if (defaultIndex !== -1) {
            this.SCALE_LEVELS = __spread(this.SCALE_LEVELS.slice(0, defaultIndex), [scale], this.SCALE_LEVELS.slice(defaultIndex));
            if (defaultIndex === this.state.scaleIndex) {
                this.resetScale();
            }
            this.state.scaleIndex = defaultIndex;
            this.defaultScale = scale;
        }
        else {
            var index = this.SCALE_LEVELS.findIndex(function (l) { return l === scale; });
            if (index === this.state.scaleIndex) {
                this.resetScale();
            }
            if (index !== -1) {
                this.state.scaleIndex = index;
                this.defaultScale = scale;
            }
        }
    };
    ScaleStore.prototype.setScaleToDefault = function () {
        this.state.scaleIndex = this.defaultIndex;
    };
    ScaleStore.prototype.checkOffset = function (offset) {
        var dpr = window.devicePixelRatio || 1;
        var scaledSize = this.scaledSize;
        var previewSize = this.previewSize;
        var previewPosition = this.editor.engineMediator.preview.initialTransform.position;
        var scaledPosition = this.getPositionWithOffset(offset);
        var widthOffset = ((scaledSize.width - previewSize.width) * dpr) / 2;
        var heightOffset = ((scaledSize.height - previewSize.height) * dpr) / 2;
        var offsetX = previewPosition.x - scaledPosition.x;
        var offsetY = previewPosition.y - scaledPosition.y;
        var centerOffsetX = Math.abs(offsetX);
        var centerOffsetY = Math.abs(offsetY);
        var negativeX = offsetX > 0;
        var negativeY = offsetY > 0;
        var maxOffsetX = centerOffsetX - widthOffset;
        var maxOffsetY = centerOffsetY - heightOffset;
        return {
            canDragX: maxOffsetX < 0,
            canDragY: maxOffsetY < 0,
            maxOffsetX: negativeX ? -maxOffsetX : maxOffsetX,
            maxOffsetY: negativeY ? -maxOffsetY : maxOffsetY,
        };
    };
    ScaleStore.prototype.calculateScale = function (rotation, size, oldScale) {
        if (rotation === void 0) { rotation = 0; }
        if (size === void 0) { size = this.previewSize; }
        if (oldScale === void 0) { oldScale = this.defaultScale; }
        var width = size.width, height = size.height;
        var previewVector = new Vector2({ x: width, y: height });
        var rotatedVector = new Vector2(Math.abs(previewVector.x * Math.cos(rotation)) + Math.abs(previewVector.y * Math.sin(rotation)), Math.abs(previewVector.x * Math.sin(rotation)) + Math.abs(previewVector.y * Math.cos(rotation)));
        var distanceToCorner = previewVector
            .subtract(rotatedVector)
            .divide(2)
            .multiply(oldScale).abs;
        if (distanceToCorner.y > distanceToCorner.x) {
            return (distanceToCorner.y * 2) / previewVector.y + oldScale;
        }
        return (distanceToCorner.x * 2) / previewVector.x + oldScale;
    };
    Object.defineProperty(ScaleStore.prototype, "defaultIndex", {
        get: function () {
            var _this = this;
            return this.SCALE_LEVELS.findIndex(function (l) { return l === _this.defaultScale; });
        },
        enumerable: true,
        configurable: true
    });
    ScaleStore.prototype.getPositionWithOffset = function (offset) {
        if (offset === void 0) { offset = this.offset; }
        var position = this.position;
        return { x: position.x - offset.x, y: position.y - offset.y };
    };
    ScaleStore.prototype.scaleRender = function (isSetDefault) {
        if (isSetDefault === void 0) { isSetDefault = false; }
        var position = this.editor.scale.getPositionWithOffset();
        var scaleValue = isSetDefault ? this.defaultScale : this.scale;
        var scale = { x: scaleValue, y: scaleValue };
        this.editor.engineMediator.preview.container.setScale(scale);
        this.editor.engineMediator.preview.container.setPosition(position);
        this.editor.engineMediator.preview.savePreviewTransform({
            scale: scale,
            position: position,
            rotation: 0,
        });
        if (!isSetDefault) {
            this.editor.render();
        }
    };
    Object.defineProperty(ScaleStore.prototype, "scale", {
        get: function () {
            var index = this.state.scaleIndex;
            return index !== -1 ? this.SCALE_LEVELS[index] : this.defaultScale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleStore.prototype, "zoomLevel", {
        get: function () {
            var dpr = window.devicePixelRatio || 1;
            return ((this.scale / dpr) * 100).toFixed(1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleStore.prototype, "canDrag", {
        get: function () {
            return this.defaultScale < this.scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleStore.prototype, "canZoomOut", {
        get: function () {
            return this.state.scaleIndex > this.defaultIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleStore.prototype, "canZoomIn", {
        get: function () {
            return this.SCALE_LEVELS.length - 1 > this.state.scaleIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleStore.prototype, "position", {
        get: function () {
            return this.state.position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleStore.prototype, "scaledSize", {
        get: function () {
            var index = this.state.scaleIndex;
            var scale = index !== -1 ? this.SCALE_LEVELS[index] : this.defaultScale;
            var previewSize = this.previewSize;
            return {
                width: (previewSize.width * scale) / this.defaultScale,
                height: (previewSize.height * scale) / this.defaultScale,
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScaleStore.prototype, "previewSize", {
        get: function () {
            return this.editor.getPreviewSize();
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        observable
    ], ScaleStore.prototype, "state", void 0);
    __decorate([
        action
    ], ScaleStore.prototype, "in", void 0);
    __decorate([
        action
    ], ScaleStore.prototype, "out", void 0);
    __decorate([
        action
    ], ScaleStore.prototype, "setInitialTransform", null);
    __decorate([
        action
    ], ScaleStore.prototype, "resetScale", null);
    __decorate([
        action
    ], ScaleStore.prototype, "resetPosition", null);
    __decorate([
        action
    ], ScaleStore.prototype, "setPosition", null);
    __decorate([
        action
    ], ScaleStore.prototype, "savePosition", null);
    __decorate([
        action
    ], ScaleStore.prototype, "setDefaultScale", null);
    __decorate([
        action
    ], ScaleStore.prototype, "setScaleToDefault", null);
    __decorate([
        computed
    ], ScaleStore.prototype, "scale", null);
    __decorate([
        computed
    ], ScaleStore.prototype, "zoomLevel", null);
    __decorate([
        computed
    ], ScaleStore.prototype, "canDrag", null);
    __decorate([
        computed
    ], ScaleStore.prototype, "canZoomOut", null);
    __decorate([
        computed
    ], ScaleStore.prototype, "canZoomIn", null);
    __decorate([
        computed
    ], ScaleStore.prototype, "position", null);
    __decorate([
        computed
    ], ScaleStore.prototype, "scaledSize", null);
    return ScaleStore;
}());

var vertices = [
    [0, 0],
    [0, 1],
    [1, 0],
    [1, 1],
];
/**
 * Calculates vertices of a rectangle based on size, position, pivot and rotation
 */
var RectStore = /** @class */ (function () {
    function RectStore(editor, store, pivot, considerRotation) {
        if (pivot === void 0) { pivot = 'center'; }
        if (considerRotation === void 0) { considerRotation = true; }
        this.considerRotation = true;
        this.store = store;
        this.m = pivot === 'center' ? RectStore.movePivotTo([0.5, 0.5]) : vertices;
        this.considerRotation = considerRotation;
        this.configStore = editor.configStore;
    }
    RectStore.floor = function (n) {
        return Math.floor(n);
    };
    RectStore.movePivotTo = function (pivot) {
        return vertices.map(function (v) { return [v[0] - pivot[0], v[1] - pivot[1]]; });
    };
    Object.defineProperty(RectStore.prototype, "position", {
        get: function () {
            return this.store.position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectStore.prototype, "size", {
        get: function () {
            return this.store.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectStore.prototype, "rotation", {
        get: function () {
            return this.considerRotation ? this.store.rotationWRTOutputRotation : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectStore.prototype, "leftTop", {
        get: function () {
            var width = this.m[0][0] * this.size.width;
            var height = this.m[0][1] * this.size.height;
            var position = this.position;
            return RectStore.coordinatesWithRotation({ width: width, height: height }, this.rotation, position);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectStore.prototype, "leftBottom", {
        get: function () {
            var width = this.m[1][0] * this.size.width;
            var height = this.m[1][1] * this.size.height;
            var position = this.position;
            return RectStore.coordinatesWithRotation({ width: width, height: height }, this.rotation, position);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectStore.prototype, "rightTop", {
        get: function () {
            var width = this.m[2][0] * this.size.width;
            var height = this.m[2][1] * this.size.height;
            var position = this.position;
            return RectStore.coordinatesWithRotation({ width: width, height: height }, this.rotation, position);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectStore.prototype, "rightBottom", {
        get: function () {
            var width = this.m[3][0] * this.size.width;
            var height = this.m[3][1] * this.size.height;
            var position = this.position;
            return RectStore.coordinatesWithRotation({ width: width, height: height }, this.rotation, position);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectStore.prototype, "leftBottomHandle", {
        get: function () {
            var width = this.m[1][0] * this.size.width;
            var height = this.m[1][1] * this.size.height + this.configStore.measurements.canvasControls.sprite.rotateHandle.height;
            var position = this.position;
            return RectStore.coordinatesWithRotation({ width: width, height: height }, this.rotation, position);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectStore.prototype, "rightBottomHandle", {
        get: function () {
            var width = this.m[3][0] * this.size.width;
            var height = this.m[3][1] * this.size.height + this.configStore.measurements.canvasControls.sprite.rotateHandle.height;
            var position = this.position;
            return RectStore.coordinatesWithRotation({ width: width, height: height }, this.rotation, position);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectStore.prototype, "leftMid", {
        get: function () {
            var leftTop = new Vector2(this.leftTop);
            var leftBottom = new Vector2(this.leftBottom);
            return leftTop.add(leftBottom).divide(2);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectStore.prototype, "rightMid", {
        get: function () {
            var rightTop = new Vector2(this.rightTop);
            var rightBottom = new Vector2(this.rightBottom);
            return rightTop.add(rightBottom).divide(2);
        },
        enumerable: true,
        configurable: true
    });
    RectStore.coordinatesWithRotation = function (_a, rotation, origin) {
        var width = _a.width, height = _a.height;
        return new Vector2({
            x: width * Math.cos(rotation) - height * Math.sin(rotation) + origin.x,
            y: width * Math.sin(rotation) + height * Math.cos(rotation) + origin.y,
        }).floored;
    };
    __decorate([
        computed
    ], RectStore.prototype, "position", null);
    __decorate([
        computed
    ], RectStore.prototype, "size", null);
    __decorate([
        computed
    ], RectStore.prototype, "rotation", null);
    __decorate([
        computed
    ], RectStore.prototype, "leftTop", null);
    __decorate([
        computed
    ], RectStore.prototype, "leftBottom", null);
    __decorate([
        computed
    ], RectStore.prototype, "rightTop", null);
    __decorate([
        computed
    ], RectStore.prototype, "rightBottom", null);
    __decorate([
        computed
    ], RectStore.prototype, "leftBottomHandle", null);
    __decorate([
        computed
    ], RectStore.prototype, "rightBottomHandle", null);
    __decorate([
        computed
    ], RectStore.prototype, "leftMid", null);
    __decorate([
        computed
    ], RectStore.prototype, "rightMid", null);
    return RectStore;
}());

var Transformations = /** @class */ (function () {
    function Transformations(editor) {
        this.transforms = {
            output: JSON.stringify(RectTransform.IDENTITY),
            preview: JSON.stringify(RectTransform.IDENTITY),
        };
        this.editor = editor;
    }
    Transformations.rotateOutput = function (rotation, point) {
        rotation %= 360;
        switch (rotation) {
            case 90:
            case -270:
                return point.swapped.multiply(-1, 1);
            case 180:
            case -180:
                return point.multiply(-1);
            case 270:
            case -90:
                return point.swapped.multiply(1, -1);
            default:
                return point;
        }
    };
    Transformations.prototype.onLeave = function () {
        var dpr = Editor.devicePixelRatio;
        var _a = this.transformToolStore.rotateFlipState, flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically, previewRotation = _a.rotation, outputRotation = _a.outputRotation;
        /** setting resolution */
        var containerP = this.engineMediator.preview.container;
        var containerO = this.editor.outputContainer;
        containerO.setResolution(toJS(this.transformToolStore.localOutputImageSize));
        containerO.setData({ flipVertically: flipVertically, flipHorizontally: flipHorizontally });
        var scaleP = containerP.getScale();
        this.saveTransforms();
        /** Correct order of application of transform is scale, rotate, translate */
        /** Scale */
        var scaleFactor = 1;
        if (this.transformToolStore.lockResolution) {
            var _b = this.transformToolStore, size = _b.cropMaskSize, defaultImageResolution = _b.defaultImageSize;
            var defaultCropSize = this.transformToolStore.defaultCropMaskSize;
            var wouldHaveBeenOutputResolution = {
                height: (size.height * defaultImageResolution.height) / defaultCropSize.height,
                width: (size.width * defaultImageResolution.width) / defaultCropSize.width,
            };
            scaleFactor = wouldHaveBeenOutputResolution.width / this.transformToolStore.localOutputImageSize.width;
        }
        var previewScale = Math.abs(scaleP.x);
        var outputScale = scaleFactor / (previewScale / this.transformToolStore.defaultScale);
        var scale = { x: outputScale, y: outputScale };
        /** Rotation */
        var rotation = -(previewRotation - outputRotation);
        /** Position */
        var initialPreviewPosition = this.editor.previewToOutput(new Vector2(this.engineMediator.preview.initialTransform.position).divide(dpr));
        var previewCenter = this.editor.previewToOutput(new Vector2(this.transformToolStore.leftTop)
            .add(new Vector2(this.transformToolStore.rightBottom))
            .divide(2)
            .add(new Vector2(this.transformToolStore.unRotatedDefaults.cropMaskPosition)));
        var oldPosition = new Vector2(initialPreviewPosition).multiply(scaleFactor);
        var translatedPosition = Transformations.rotateOutput((this.transformToolStore.outputRotation * 180) / Math.PI, new Vector2(previewCenter));
        var offset = translatedPosition.subtract(oldPosition);
        var oldOutputPosition = new Vector2(containerO.getPosition());
        var position = oldOutputPosition.add(offset);
        containerO.setTransform({ scale: scale, position: position, rotation: rotation });
        /** Preview */
        this.editor.engineMediator.preview.updateTransform(0, false);
        this.editor.scale.setInitialTransform();
        /** Updating ui control positions */
        this.editor.spriteStore.updateCanvasControls();
        this.editor.focusToolStore.updateCanvasControls();
    };
    Transformations.prototype.onEnter = function () {
        /** Set scale and resolution to default */
        this.editor.scale.setScaleToDefault();
        /** Update container transforms */
        var containerP = this.engineMediator.preview.container;
        var containerO = this.editor.outputContainer;
        var previewTransform = JSON.parse(this.transforms.preview);
        containerO.setResolution(toJS(this.transformToolStore.defaultImageSize));
        containerP.setTransform(previewTransform);
        containerO.setTransform(JSON.parse(this.transforms.output));
        /** Updating flip state */
        var scaleP = previewTransform.scale;
        this.editor.outputContainer.setData({ flipVertically: false, flipHorizontally: false });
        this.transformToolStore.transformStore.updateFlip({ flipVertically: scaleP.y < 0, flipHorizontally: scaleP.x < 0 });
        /** Save preview transform for conversions */
        this.engineMediator.preview.savePreviewTransform(previewTransform);
        /** Set the scale based on rotation 0 */
        var scale = this.engineMediator.preview.calculateTransform().scale;
        this.editor.scale.setInitialTransform(scale.x);
    };
    Transformations.prototype.rotateOutputContainer = function (negative) {
        var _this = this;
        if (negative === void 0) { negative = false; }
        this.editor.outputContainer.rotate90(negative);
        this.transformToolStore.transformStore.setOutputRotation(this.editor.outputContainer.getRotation());
        var rotation = this.transformToolStore.rotateFlipState.rotation;
        /** Everytime output resolution is changed preview transform has to be recalculated and default scale is to set */
        this.engineMediator.preview.updateTransform(rotation);
        runInAction(function () {
            /** preview scale has to be updated, when there's some rotation */
            _this.editor.scale.setInitialTransform();
            var scale = _this.getScaleWithFlip(rotation);
            _this.engineMediator.preview.container.setScale(scale);
            /** Updating crop controls */
            _this.transformToolStore.setCropDefaults(true);
            _this.transformToolStore.updateCropMask();
        });
        this.editor.render();
    };
    /**
     * When changed tool from transform or exported, before that
     * for each change in the transform tool, preview container transform is set and rendered
     */
    Transformations.prototype.applyPreviewTransform = function () {
        var _a = this.transformToolStore.rotateFlipState, rotation = _a.rotation, flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
        var scaledPosition = this.editor.scale.getPositionWithOffset();
        var scale = this.getScaleWithFlip();
        var flippedRotation = rotation;
        if (flipHorizontally) {
            flippedRotation = flipRotationHorizontally(flippedRotation);
        }
        if (flipVertically) {
            flippedRotation = flipRotationHorizontally(flippedRotation);
        }
        var transform = {
            position: scaledPosition,
            rotation: flippedRotation,
            scale: scale,
        };
        this.engineMediator.preview.savePreviewTransform(transform);
        this.engineMediator.preview.container.setTransform(transform);
    };
    Transformations.prototype.getScaleWithFlip = function (rotation) {
        if (rotation === void 0) { rotation = this.transformToolStore.rotateFlipState.rotation; }
        var _a = this.transformToolStore.rotateFlipState, flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
        var xFactor = flipHorizontally ? -1 : 1;
        var yFactor = flipVertically ? -1 : 1;
        var scale = this.editor.scale.calculateScale(rotation);
        return { x: scale * xFactor, y: scale * yFactor };
    };
    Transformations.prototype.saveTransforms = function () {
        var preview = JSON.stringify(this.engineMediator.preview.container.getTransform());
        var output = JSON.stringify(this.editor.outputContainer.getTransform());
        this.transforms = { preview: preview, output: output };
    };
    Transformations.prototype.saveTransformsBasedOnFlip = function () {
        var preview = this.engineMediator.preview.container.getTransform();
        var scale = preview.scale;
        var _a = this.editor.outputContainer.getData(), flipVertically = _a.flipVertically, flipHorizontally = _a.flipHorizontally;
        var output = JSON.stringify(this.editor.outputContainer.getTransform());
        this.transforms = {
            preview: JSON.stringify(__assign({}, preview, { scale: { x: flipHorizontally ? -scale.x : scale.x, y: flipVertically ? -scale.y : scale.y } })),
            output: output,
        };
    };
    Object.defineProperty(Transformations.prototype, "engineMediator", {
        get: function () {
            return this.editor.engineMediator;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transformations.prototype, "transformToolStore", {
        get: function () {
            return this.editor.transformToolStore;
        },
        enumerable: true,
        configurable: true
    });
    return Transformations;
}());

var initialFolderState$1 = 'identity';
var TransformToolStore = /** @class */ (function () {
    function TransformToolStore(editor) {
        var _this = this;
        /**
         * When output rotation of the image is changed, the cropDefaults are changed accordingly
         * ie, the outputSize height and width get swapped, cropMask is rendered at a diffferent position with a different scale
         * The unrotatedDefaults are needed for calculation of PreviewContainer position
         */
        this.unRotatedDefaults = {
            cropMaskPosition: { x: 0, y: 0 },
            scale: 1,
        };
        this.defaultAngle = 0;
        this.dragMode = observable.box(false);
        this.minCropSize = 0;
        /**
         * Default crop values
         * Changed only when following is chaned has been changed or
         * 1. window is resized
         * 2. Added new image
         * 3. Output rotation is changed
         *
         * position: top-left position of the preview box (calculated from preview container position)
         * Note: Preview container has a pivot 0.5(center position), and position here is top left ie, pivot 0
         * cropMaskSize: max size of the preview box (calculated from outputconatiner size)
         * image size: default image size
         * scale: based on the image size and canvas container area, scale is calculated
         */
        this.defaults = {
            cropMaskPosition: { x: 0, y: 0 },
            cropMaskSize: { width: 0, height: 0 },
            imageSize: { width: 0, height: 0 },
            scale: 1,
        };
        /**
         * This represents the transform tool control inputs crop size values
         * output size always depends on crop size and default image size
         */
        this.localOutputSize = { width: 0, height: 0 };
        this.defaultIdentifier = 'imgly_transform_common_custom';
        this.checkImage = function (imageSrc) {
            var transformBaseUrl = _this.editor.configStore.config.assetBaseUrl;
            var length = transformBaseUrl.length;
            if (transformBaseUrl[length - 1] !== '/') {
                transformBaseUrl += '/';
            }
            if (transformBaseUrl + "transform" === imageSrc) {
                return false;
            }
            var img = new Image();
            try {
                img.src = imageSrc;
                return true;
            }
            catch (err) {
                return false;
            }
        };
        this.flipRatio = function () {
            _this.transformStore.flipRatio();
            _this.changeIdentifier(_this.identifier, true);
        };
        this.reset = function () {
            _this.transformStore.resetRotation();
            _this.transformStore.resetOutputRotation();
            _this.transformStore.resetFlip();
            _this.setDefaultAngle(0);
            var rotation = _this.editor.outputContainer.getRotation();
            if (rotation !== 0) {
                _this.engineMediator.output.applyNewImageTransform();
            }
            _this.engineMediator.output.container.setData({
                flipHorizontally: false,
                flipVertically: false,
            });
            _this.engineMediator.preview.updateTransform();
            _this.editor.scale.setInitialTransform();
            _this.setCropDefaults();
            _this.applyInitialCrop();
            _this.editor.render();
        };
        this.changeLocalOutputSize = function (size) {
            _this.localOutputSize.height = Math.floor(size.height);
            _this.localOutputSize.width = Math.floor(size.width);
        };
        this.changeDefaultScale = function (scale) {
            _this.defaults.scale = scale;
        };
        this.changeLocalOutputHeight = function (height) {
            _this.localOutputSize.height = Math.floor(height);
        };
        this.changeLocalOutputWidth = function (width) {
            _this.localOutputSize.width = Math.floor(width);
        };
        this.changeLockResolution = function () {
            _this.transformStore.changeLockResolution();
            _this.addSnapshot();
        };
        this.rotateClockwise = function () {
            _this.rotateOutputContainer(false);
        };
        this.rotateAntiClockwise = function () {
            _this.rotateOutputContainer(true);
        };
        this.flipHorizontally = function (withsideEffects) {
            if (withsideEffects === void 0) { withsideEffects = true; }
            _this.transformStore.flipHorizontally();
            _this.editor.spriteStore.reverseTextHorizontally();
            _this.transformRender(withsideEffects);
            if (withsideEffects) {
                _this.addSnapshot();
            }
        };
        this.flipVertically = function (withsideEffects) {
            if (withsideEffects === void 0) { withsideEffects = true; }
            _this.transformStore.flipVertically();
            _this.editor.spriteStore.reverseTextVertically();
            _this.transformRender(withsideEffects);
            if (withsideEffects) {
                _this.addSnapshot();
            }
        };
        this.applyDefaultCrop = function (addSnapshot) {
            if (addSnapshot === void 0) { addSnapshot = false; }
            if (_this.identifier === 'identity') {
                _this.changeIdentifier(_this.defaultIdentifier, addSnapshot);
            }
        };
        this.updateCropMask = function () {
            _this.changeIdentifier(_this.identifier, true);
        };
        this.onLeftTop = function (_a) {
            var x = _a.x, y = _a.y;
            var ratio = _this.getRatio();
            var size = {
                width: _this.rightTop.x - x,
                height: _this.leftBottom.y - y,
            };
            if (ratio === '*') {
                _this.changeCropAndOutputSize(size);
                _this.changePosition({ x: x, y: y });
            }
            else {
                var leftTop = new Vector2(_this.leftTop.x, _this.leftTop.y);
                var propportionalSize = _this.proportionalSize(ratio, size);
                var newLeftTop = new Vector2(x, y);
                var offset = newLeftTop.subtract(leftTop);
                if (_this.changePosition(leftTop.add(new Vector2(offset.y * ratio, offset.y)))) {
                    _this.changeCropAndOutputSize(propportionalSize);
                }
            }
        };
        this.onLeftBottom = function (_a) {
            var x = _a.x, y = _a.y;
            var ratio = _this.getRatio();
            var size = {
                width: _this.rightBottom.x - x,
                height: y - _this.leftTop.y,
            };
            if (ratio === '*') {
                var isSizeChanged = _this.changeCropAndOutputSize(size);
                if (isSizeChanged) {
                    _this.changePositionX(x);
                }
            }
            else {
                var leftBottom = new Vector2(_this.leftBottom.x, _this.leftBottom.y);
                var propportionalSize = _this.proportionalSize(ratio, size);
                var newLeftBottom = new Vector2(x, y);
                var offset = leftBottom.subtract(newLeftBottom);
                var proportionalLeftBottom = leftBottom.add(new Vector2(offset.y * ratio, offset.y));
                if (_this.changePositionX(proportionalLeftBottom.x)) {
                    _this.changeCropAndOutputSize(propportionalSize);
                }
            }
        };
        this.onRightTop = function (_a) {
            var x = _a.x, y = _a.y;
            var ratio = _this.getRatio();
            var size = {
                width: x - _this.leftTop.x,
                height: _this.rightBottom.y - y,
            };
            if (ratio === '*') {
                _this.changeCropAndOutputSize(size);
                _this.changePositionY(y);
            }
            else {
                var rightTop = new Vector2(_this.rightTop.x, _this.rightTop.y);
                var propportionalSize = _this.proportionalSize(ratio, size);
                var newRightTop = new Vector2(x, y);
                var offset = newRightTop.subtract(rightTop);
                var proportionalLeftBottom = rightTop.add(new Vector2(offset.y * ratio, offset.y));
                if (_this.changePositionY(proportionalLeftBottom.y)) {
                    var toBerightTop = {
                        x: _this.leftTop.x + propportionalSize.width,
                        y: _this.leftTop.y,
                    };
                    var defaultSize = _this.defaults.cropMaskSize;
                    if (toBerightTop.x <= defaultSize.width && toBerightTop.y >= 0) {
                        _this.changeCropAndOutputSize(propportionalSize);
                    }
                }
            }
        };
        this.onRightBottom = function (_a) {
            var x = _a.x, y = _a.y;
            var ratio = _this.getRatio();
            var size = { width: x - _this.leftBottom.x, height: y - _this.rightTop.y };
            if (ratio === '*') {
                _this.changeCropAndOutputSize(size);
            }
            else {
                var propportionalSize = _this.proportionalSize(ratio, size);
                var toBeRightBottom = {
                    x: _this.leftTop.x + propportionalSize.width,
                    y: _this.leftTop.y + propportionalSize.height,
                };
                var defaultSize = _this.defaults.cropMaskSize;
                if (toBeRightBottom.x <= defaultSize.width && toBeRightBottom.y <= defaultSize.height) {
                    _this.changeCropAndOutputSize(propportionalSize);
                }
            }
        };
        this.onBlurWidth = function () {
            var width = _this.localOutputSize.width || _this.minCropSize;
            var transform = _this.entityManager.items.find(function (option) { return option.identifier === _this.identifier; });
            var defaultImageSize = _this.defaults.imageSize;
            if (transform && transform.ratio) {
                var newwidth = Math.max(width > defaultImageSize.width ? defaultImageSize.width : width, _this.minCropSize);
                var newheight = _this.localOutputSize.height;
                if (transform.ratio === '*') {
                    _this.changeLocalOutputWidth(newwidth);
                }
                else {
                    var boundaryLocalImageSize = TransformToolStore.placeCropMask(transform.ratio, defaultImageSize);
                    newwidth = Math.min(newwidth, boundaryLocalImageSize.width);
                    newheight = newwidth / transform.ratio;
                    _this.changeLocalOutputSize({
                        height: newheight,
                        width: newwidth,
                    });
                }
                _this.updatePreviewSizeWRTImageSize();
                _this.addSnapshot();
            }
        };
        this.onBlurHeight = function () {
            var height = _this.localOutputSize.height || _this.minCropSize;
            var transform = _this.entityManager.items.find(function (option) { return option.identifier === _this.identifier; });
            var defaultImageSize = _this.defaults.imageSize;
            if (transform && transform.ratio) {
                var newheight = Math.max(height > defaultImageSize.height ? defaultImageSize.height : height, _this.minCropSize);
                var newwidth = _this.localOutputSize.width;
                if (transform.ratio === '*') {
                    _this.changeLocalOutputHeight(newheight);
                }
                else {
                    var boundaryLocalImageSize = TransformToolStore.placeCropMask(transform.ratio, defaultImageSize);
                    newheight = Math.min(newheight, boundaryLocalImageSize.height);
                    newwidth = newheight * transform.ratio;
                    _this.changeLocalOutputSize({
                        height: newheight,
                        width: newwidth,
                    });
                }
                _this.updatePreviewSizeWRTImageSize();
                _this.addSnapshot();
            }
        };
        this.editor = editor;
        this.selectedCategory = initialFolderState$1;
        this.transformStore = new TransformStore(editor);
        this.transformations = new Transformations(editor);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _a = this.config, enableRotation = _a.enableRotation, enableFlip = _a.enableFlip, config = __rest(_a, ["enableRotation", "enableFlip"]);
        var assets = this.editor.assetProvider.getAssets('transform');
        this.entityManager = new EntityMapper(assets, __assign({}, config, { categoryKey: '', itemKey: 'thumbnailURI', flattenCategories: false, locale: __assign({}, this.locale.items, this.locale.categories), getAssetPath: this.editor.getAssetPath('transform') }));
        this.rect = new RectStore(this.editor, this.transformStore, 'topLeft', false);
        this.defaultIdentifier = this.entityManager.items[0].identifier;
        this.minCropSize = this.editor.configStore.measurements.crop.minSize;
    }
    TransformToolStore.inRadians = function (deg) {
        return (deg * Math.PI) / 180;
    };
    /**
     * Calculates size of the cropmask based on image size
     * @param ratio
     * @param imageSize
     * @returns { height, width, yChanged }
     * height, width: will be the size of the crop mask
     * yChaned: If the y value is changed the position of the cropmask has to be changed, yChanged gived an indicator for that
     */
    TransformToolStore.placeCropMask = function (ratio, imageSize) {
        if (imageSize.height * ratio > imageSize.width) {
            var height = imageSize.width / ratio;
            return { height: height, width: imageSize.width, yChanged: true };
        }
        var width = imageSize.height * ratio;
        return { height: imageSize.height, width: width, yChanged: false };
    };
    TransformToolStore.prototype.changeIdentifier = function (identifier, addSnapshot) {
        if (addSnapshot === void 0) { addSnapshot = false; }
        this.transformStore.changeIdentifier(identifier);
        var cropSize = this.getCropMask(identifier, this.defaults.imageSize);
        if (cropSize) {
            this.transformStore.changeRatio(cropSize.ratio);
            this.changeLocalOutputSize(cropSize);
            this.updatePreviewSizeWRTImageSize();
            if (cropSize.yChanged !== undefined) {
                this.updateInitialCropMaskPosition(cropSize.yChanged);
            }
            if (addSnapshot) {
                this.addSnapshot();
            }
        }
    };
    TransformToolStore.prototype.setDragMode = function (mode) {
        this.dragMode.set(mode);
    };
    TransformToolStore.prototype.getCropMask = function (identifier, size) {
        var transform = this.getTransform(identifier);
        if (transform) {
            if (transform.ratio) {
                var ratio = this.isRatioFlipped ? 1 / transform.ratio : transform.ratio;
                switch (transform.ratio) {
                    case '*':
                        this.changePosition({ x: 0, y: 0 });
                        return __assign({}, size, { yChanged: undefined, ratio: '*' });
                    default:
                        return __assign({}, TransformToolStore.placeCropMask(ratio, size), { ratio: transform.ratio });
                }
            }
            else {
                this.transformStore.changeForceDimensions(transform.forceDimensions);
                this.transformStore.changeLockResolution(transform.lockDimensions);
                var _a = transform.dimensions, x = _a.x, y = _a.y;
                return __assign({}, TransformToolStore.placeCropMask(x / y, size), { ratio: null });
            }
        }
        return null;
    };
    TransformToolStore.prototype.setCropDefaults = function (rotated) {
        if (rotated === void 0) { rotated = false; }
        var imageSize = this.editor.outputContainer.getResolution();
        this.setDefaultImageSize(imageSize);
        var size = this.editor.getPreviewSize();
        var position = this.editor.engineMediator.preview.previewTransformWithoutDpr.position;
        this.setDefaultCropSize(size);
        this.setDefaultCropPosition({
            x: position.x - size.width / 2,
            y: position.y - size.height / 2,
        });
        this.changeDefaultScale(this.editor.scale.defaultScale);
        if (!rotated) {
            this.unRotatedDefaults.cropMaskPosition = this.defaultCropMaskPosition;
            this.unRotatedDefaults.scale = this.defaultScale;
        }
    };
    TransformToolStore.prototype.setDefaultImageSize = function (size) {
        this.defaults.imageSize = size;
        this.localOutputSize = size;
    };
    TransformToolStore.prototype.setDefaultCropSize = function (size) {
        this.defaults.cropMaskSize.height = size.height;
        this.defaults.cropMaskSize.width = size.width;
    };
    TransformToolStore.prototype.setDefaultCropPosition = function (position) {
        this.defaults.cropMaskPosition.x = position.x;
        this.defaults.cropMaskPosition.y = position.y;
    };
    TransformToolStore.prototype.resetCrop = function () {
        this.state.cropState = observable.map({});
        this.state.identifier = 'identity';
    };
    TransformToolStore.prototype.toggleCategorySelection = function (identifier) {
        this.selectedCategory = this.selectedCategory === identifier ? initialFolderState$1 : identifier;
    };
    TransformToolStore.prototype.pureReset = function () {
        this.transformStore.resetRotation();
        this.transformStore.resetOutputRotation();
        this.transformStore.resetFlip();
        this.resetCrop();
    };
    TransformToolStore.prototype.changePosition = function (position) {
        return this.transformStore.changePosition(position, this.defaults.cropMaskSize);
    };
    TransformToolStore.prototype.changePositionX = function (x) {
        return this.transformStore.changePositionX(x, this.defaults.cropMaskSize.width);
    };
    TransformToolStore.prototype.changePositionY = function (y) {
        return this.transformStore.changePositionY(y, this.defaults.cropMaskSize.height);
    };
    /**
     * Changes crop and output height
     * checks for limitations like if minCropHeight is exceeded
     * @param height
     * @returns if all the condiditon are satisfied, height has changed
     */
    TransformToolStore.prototype.changeCropAndOutputHeight = function (height) {
        if (height && height >= this.minCropSize) {
            this.transformStore.changeHeight(height);
            if (!this.lockResolution) {
                this.changeLocalOutputHeight((height * this.defaults.imageSize.height) / this.defaults.cropMaskSize.height);
            }
            return true;
        }
        return false;
    };
    /**
     * Changes crop and output width
     * checks for limitations like if minCropWidth is exceeded
     * @param width
     * @returns if all the condiditon are satisfied, width has changed
     */
    TransformToolStore.prototype.changeCropAndOutputWidth = function (width) {
        if (width && width >= this.minCropSize) {
            this.transformStore.changeWidth(width);
            if (!this.lockResolution) {
                this.changeLocalOutputWidth((width * this.defaults.imageSize.width) / this.defaults.cropMaskSize.width);
            }
            return true;
        }
        return false;
    };
    /**
     * Changes crop and output size
     * checks for limitations like if minCropSize is exceeded
     * @param size
     * @returns { widthChanged: boolean, heightChanged: boolean } if all the condiditon are satisfied, width/height has changed
     */
    TransformToolStore.prototype.changeCropAndOutputSize = function (size) {
        var widthChanged = this.changeCropAndOutputHeight(size.height);
        var heightChanged = this.changeCropAndOutputWidth(size.width);
        return { widthChanged: widthChanged, heightChanged: heightChanged };
    };
    TransformToolStore.prototype.transformRender = function (withsideEffects) {
        if (withsideEffects === void 0) { withsideEffects = true; }
        this.transformations.applyPreviewTransform();
        if (withsideEffects) {
            this.editor.render();
        }
    };
    TransformToolStore.prototype.addSnapshot = function (desc) {
        if (desc === void 0) { desc = ''; }
        if (this.state.identifier !== 'identity') {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            var _a = this.state, cropState = _a.cropState, state = __rest(_a, ["cropState"]);
            this.editor.addLocalTransformSnapshot(__assign({}, state, this.cropState, { localOutputSize: toJS(this.localOutputSize), outputSize: this.engineMediator.output.container.getResolution(), defaults: toJS(this.defaults), previewTransform: this.engineMediator.preview.container.getTransform(), outputTransform: this.engineMediator.output.container.getTransform() }), desc);
        }
    };
    /**
     * There are different states to be saved when inside transform tool and when ouside transform tool
     * that's why 2 types of snaphots LocalSnapshots and Snapshots
     */
    TransformToolStore.prototype.updateLocalStateFromHistory = function (state) {
        var tool = this.editor.activeStore.tool;
        if (tool === Tool.TRANSFORM) {
            this.transformStore.changeLockResolution(state.lockResolution);
            this.transformStore.changeForceDimensions(state.forceDimensions);
            this.transformStore.changeIdentifier(state.identifier);
            this.transformStore.setRotation(state.rotationInDegrees);
            this.setDefaultAngle(state.rotationInDegrees);
            this.transformStore.setOutputRotation(state.outputRotation);
            this.transformStore.updateFlip(state);
            this.engineMediator.output.container.setRotation(state.outputRotation);
            this.setDefaultImageSize(state.defaults.imageSize);
            this.changeLocalOutputSize(state.localOutputSize);
            this.transformStore.changeSize(state.size);
            this.changePosition(state.position);
            this.setDefaultCropSize(state.defaults.cropMaskSize);
            this.setDefaultCropPosition(state.defaults.cropMaskPosition);
            this.changeDefaultScale(state.defaults.scale);
            this.engineMediator.output.container.setResolution(state.outputSize);
            this.engineMediator.output.container.setTransform(state.outputTransform);
            this.engineMediator.preview.container.setTransform(state.previewTransform);
        }
    };
    TransformToolStore.prototype.updateStateFromHistory = function (state) {
        var tool = this.editor.activeStore.tool;
        if (tool !== Tool.TRANSFORM) {
            this.engineMediator.output.container.setTransform(state.outputTransform);
            this.engineMediator.preview.container.setTransform(state.previewTransform);
            this.engineMediator.output.container.setResolution(state.outputSize);
            this.changeLocalOutputSize(state.outputSize);
        }
    };
    Object.defineProperty(TransformToolStore.prototype, "serializableState", {
        get: function () {
            var _a = this.rotateFlipState, flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
            var outputRotation = ((this.editor.engineMediator.output.container.getRotation() * 180) / Math.PI) % 360;
            var normalizedOutputRotation = outputRotation < 0 ? outputRotation + 360 : outputRotation;
            var _b = this, leftTop = _b.leftTop, leftBottom = _b.leftBottom, rightTop = _b.rightTop, rightBottom = _b.rightBottom, identifier = _b.identifier, defaultCropMaskSize = _b.defaultCropMaskSize, rotationInDegrees = _b.rotationInDegrees;
            var rotation = (rotationInDegrees * Math.PI) / 180;
            var start = leftTop;
            var end = rightBottom;
            if ([0, 90, 180, 270].indexOf(normalizedOutputRotation) !== -1) {
                switch (normalizedOutputRotation) {
                    case 90:
                        start = { x: defaultCropMaskSize.height - leftBottom.y, y: leftBottom.x };
                        end = { x: defaultCropMaskSize.height - rightTop.y, y: rightTop.x };
                        break;
                    case 180:
                        start = { x: defaultCropMaskSize.width - rightBottom.x, y: defaultCropMaskSize.height - rightBottom.y };
                        end = { x: defaultCropMaskSize.width - leftTop.x, y: defaultCropMaskSize.height - leftTop.y };
                        break;
                    case 270:
                        start = { x: rightTop.y, y: defaultCropMaskSize.width - rightTop.x };
                        end = { x: leftBottom.y, y: defaultCropMaskSize.width - leftBottom.x };
                        break;
                }
                /** 90 and 270 for v4 and v5 are interchanged ¯\_(ツ)_/¯ */
                if (normalizedOutputRotation === 90) {
                    normalizedOutputRotation = 270;
                }
                else if (normalizedOutputRotation === 270) {
                    normalizedOutputRotation = 90;
                }
            }
            else {
                normalizedOutputRotation = 0;
            }
            return {
                flipHorizontally: flipHorizontally,
                flipVertically: flipVertically,
                rotation: rotation,
                start: start,
                end: end,
                identifier: identifier,
                outputRotation: normalizedOutputRotation,
            };
        },
        enumerable: true,
        configurable: true
    });
    TransformToolStore.prototype.updateStateFromSerialization = function (state) {
        var transformCheck = [state.start.x !== 0, state.start.y !== 0, state.end.x !== 1, state.end.y !== 1];
        var rotation = Math.round((state.rotation * 180) / Math.PI);
        this.transformStore.setRotation(rotation > 180 ? rotation - 360 : rotation);
        var _a = this.applyOutputRotation(state), height = _a.height, width = _a.width, centerPosition = _a.centerPosition;
        var start = {
            x: centerPosition.x - width / 2,
            y: centerPosition.y - height / 2,
        };
        if (transformCheck.some(function (result) { return result; })) {
            this.changePosition(start);
            this.transformStore.changeSize({ width: width, height: height });
            var _b = this.defaults, cropMaskSize = _b.cropMaskSize, imageSize = _b.imageSize;
            var outputSize = {
                height: (height * imageSize.height) / cropMaskSize.height,
                width: (width * imageSize.width) / cropMaskSize.width,
            };
            this.changeLocalOutputSize(outputSize);
        }
        this.editor.outputContainer.setData({
            flipHorizontally: state.flipHorizontally,
            flipVertically: state.flipVertically,
        });
        if (state.flipHorizontally) {
            this.flipHorizontally(false);
        }
        if (state.flipVertically) {
            this.flipVertically(false);
        }
    };
    TransformToolStore.prototype.applyOutputRotation = function (state) {
        var start = state.start, end = state.end;
        var width = Math.abs(start.x - end.x);
        var height = Math.abs(start.y - end.y);
        var cropMaskSize = this.defaults.cropMaskSize;
        var centerPosition = {
            x: (start.x + end.x) / 2,
            y: (start.y + end.y) / 2,
        };
        if (state.outputRotation !== undefined) {
            switch (state.outputRotation) {
                case 90:
                    this.transformations.rotateOutputContainer();
                    return {
                        height: height,
                        width: width,
                        centerPosition: {
                            x: cropMaskSize.width - centerPosition.y,
                            y: centerPosition.x,
                        },
                    };
                case 180:
                    this.transformations.rotateOutputContainer();
                    this.transformations.rotateOutputContainer();
                    return {
                        height: height,
                        width: width,
                        centerPosition: {
                            x: cropMaskSize.width - centerPosition.x,
                            y: cropMaskSize.height - centerPosition.y,
                        },
                    };
                case 270:
                    this.transformations.rotateOutputContainer(true);
                    return {
                        height: width,
                        width: height,
                        centerPosition: {
                            x: centerPosition.y,
                            y: cropMaskSize.height - centerPosition.x,
                        },
                    };
            }
        }
        this.transformations.rotateOutputContainer(true);
        this.transformations.rotateOutputContainer();
        return { height: height, width: width, centerPosition: centerPosition };
    };
    TransformToolStore.prototype.setDefaultAngle = function (angle) {
        this.defaultAngle = angle;
    };
    TransformToolStore.prototype.updateCanvasControls = function (oldDefaultSize) {
        var oldPosition = toJS(this.cropMaskPosition);
        var oldSize = toJS(this.cropMaskSize);
        var newDefaultSize = toJS(this.defaults.cropMaskSize);
        this.changeCropAndOutputSize({
            height: (newDefaultSize.height * oldSize.height) / oldDefaultSize.height,
            width: (newDefaultSize.width * oldSize.width) / oldDefaultSize.width,
        });
        this.changePosition({
            y: (newDefaultSize.height * oldPosition.y) / oldDefaultSize.height,
            x: (newDefaultSize.width * oldPosition.x) / oldDefaultSize.width,
        });
    };
    /**
     * When changed tool from transform or exported, before that
     * the preview transform is reset and the output transform is inverted
     */
    TransformToolStore.prototype.onLeave = function () {
        this.transformations.onLeave();
    };
    /**
     * When changed tool to transform, before that
     * the output transform is reset and the preview transform is updated accordingly
     */
    TransformToolStore.prototype.onEnter = function () {
        this.transformations.onEnter();
    };
    TransformToolStore.prototype.saveTransforms = function () {
        this.transformations.saveTransforms();
    };
    TransformToolStore.prototype.saveTransformsBasedOnFlip = function () {
        this.transformations.saveTransformsBasedOnFlip();
    };
    TransformToolStore.prototype.setRotation = function (rotation) {
        this.transformStore.setRotation(rotation);
        this.transformRender();
    };
    TransformToolStore.prototype.rotateOutputContainer = function (negative) {
        if (negative === void 0) { negative = false; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.setDragMode(true);
                        this.transformations.rotateOutputContainer(negative);
                        return [4 /*yield*/, this.editor.wait()];
                    case 1:
                        _a.sent();
                        this.setDragMode(false);
                        return [2 /*return*/];
                }
            });
        });
    };
    TransformToolStore.prototype.applyInitialCrop = function () {
        this.changeIdentifier(this.defaultIdentifier, false);
    };
    TransformToolStore.prototype.clickableCanvas = function (isClickable) {
        this.editor.clickableCanvas(isClickable);
    };
    TransformToolStore.prototype.proportionalSize = function (ratio, size, defaultSize) {
        if (defaultSize === void 0) { defaultSize = this.defaults.cropMaskSize; }
        if (size.height * ratio > defaultSize.width) {
            return { height: size.width / ratio, width: size.width };
        }
        return { height: size.height, width: size.height * ratio };
    };
    TransformToolStore.prototype.updateInitialCropMaskPosition = function (yChanged) {
        var cropMaskSize = this.cropMaskSize;
        var defaultCropMaskSize = this.defaults.cropMaskSize;
        if (yChanged) {
            this.changePosition({ x: 0, y: Math.abs(defaultCropMaskSize.height - cropMaskSize.height) / 2 });
        }
        else {
            this.changePosition({ x: Math.abs(defaultCropMaskSize.width - cropMaskSize.width) / 2, y: 0 });
        }
    };
    TransformToolStore.prototype.updatePreviewSizeWRTImageSize = function () {
        var localOutputSize = toJS(this.localOutputSize);
        var defaultImageSize = toJS(this.defaults.imageSize);
        var defaultCropSize = toJS(this.defaults.cropMaskSize);
        var newCropSize = {
            height: (defaultCropSize.height * localOutputSize.height) / defaultImageSize.height,
            width: (defaultCropSize.width * localOutputSize.width) / defaultImageSize.width,
        };
        this.transformStore.changeSize(newCropSize);
    };
    TransformToolStore.prototype.getScaleWithFlip = function (rotation) {
        if (rotation === void 0) { rotation = this.rotateFlipState.rotation; }
        return this.transformations.getScaleWithFlip(rotation);
    };
    Object.defineProperty(TransformToolStore.prototype, "cropState", {
        get: function () {
            return this.transformStore.selectedCrop;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "identifier", {
        get: function () {
            return this.transformStore.identifier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "ratio", {
        get: function () {
            return this.transformStore.ratio;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "isRatioFlipped", {
        get: function () {
            return this.transformStore.isRatioFlipped;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "height", {
        get: function () {
            return this.transformStore.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "width", {
        get: function () {
            return this.transformStore.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "localOutputImageSize", {
        get: function () {
            return this.localOutputSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "localOutputHeight", {
        get: function () {
            return this.localOutputSize.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "localOutputWidth", {
        get: function () {
            return this.localOutputSize.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "lockResolution", {
        get: function () {
            return this.transformStore.lockResolution;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "forceDimensions", {
        get: function () {
            return this.transformStore.forceDimensions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "rotationInDegrees", {
        get: function () {
            return this.transformStore.rotationInDegrees;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "outputRotation", {
        get: function () {
            return this.transformStore.outputRotation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "isDragMode", {
        get: function () {
            return this.dragMode.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "rotateFlipState", {
        /** In radians */
        get: function () {
            var _a = this.transformStore.state, flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically, rotationInDegrees = _a.rotationInDegrees, outputRotation = _a.outputRotation;
            return {
                flipHorizontally: flipHorizontally,
                flipVertically: flipVertically,
                rotation: TransformToolStore.inRadians(rotationInDegrees),
                outputRotation: outputRotation,
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "selectedCategoryIdentifier", {
        get: function () {
            return this.selectedCategory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "categories", {
        get: function () {
            return this.entityManager.categories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "entities", {
        get: function () {
            return this.entityManager.getEntities(this.selectedCategoryIdentifier);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "items", {
        get: function () {
            return this.entityManager.categories.reduce(function (acc, category) {
                var items = EntityMapper.isCategory(category) ? category.items : [category];
                return __spread(acc, items);
            }, []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "config", {
        get: function () {
            return this.editor.configStore.config[Tool.TRANSFORM];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "locale", {
        get: function () {
            return this.editor.configStore.locale[Tool.TRANSFORM];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "isOptionSelected", {
        get: function () {
            return this.identifier !== 'identity';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "leftTop", {
        get: function () {
            return this.rect.leftTop;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "leftBottom", {
        get: function () {
            return this.rect.leftBottom;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "rightTop", {
        get: function () {
            return this.rect.rightTop;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "rightBottom", {
        get: function () {
            return this.rect.rightBottom;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "cropMaskPosition", {
        get: function () {
            return this.transformStore.position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "cropMaskSize", {
        get: function () {
            return this.transformStore.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "state", {
        get: function () {
            return this.transformStore.state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "defaultImageSize", {
        get: function () {
            return this.defaults.imageSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "defaultCropMaskSize", {
        get: function () {
            return this.defaults.cropMaskSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "defaultCropMaskPosition", {
        get: function () {
            return this.defaults.cropMaskPosition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "defaultScale", {
        get: function () {
            return this.defaults.scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransformToolStore.prototype, "engineMediator", {
        get: function () {
            return this.editor.engineMediator;
        },
        enumerable: true,
        configurable: true
    });
    TransformToolStore.prototype.getRatio = function () {
        var transform = this.getTransform(this.identifier);
        if (transform) {
            if (Object.prototype.hasOwnProperty.call(transform, 'ratio')) {
                if (this.lockResolution) {
                    return this.localOutputWidth / this.localOutputHeight;
                }
                return transform.ratio;
            }
            var _a = transform.dimensions, x = _a.x, y = _a.y;
            return x / y;
        }
        return '*';
    };
    TransformToolStore.prototype.getTransform = function (identifier) {
        return this.entityManager.items.find(function (option) { return option.identifier === identifier; });
    };
    __decorate([
        observable
    ], TransformToolStore.prototype, "selectedCategory", void 0);
    __decorate([
        observable
    ], TransformToolStore.prototype, "defaults", void 0);
    __decorate([
        observable
    ], TransformToolStore.prototype, "localOutputSize", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "changeIdentifier", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "setDragMode", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "setCropDefaults", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "setDefaultImageSize", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "setDefaultCropSize", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "setDefaultCropPosition", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "flipRatio", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "resetCrop", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "toggleCategorySelection", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "pureReset", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "reset", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "changePosition", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "changePositionX", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "changePositionY", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "changeCropAndOutputHeight", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "changeCropAndOutputWidth", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "changeCropAndOutputSize", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "onLeave", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "onEnter", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "changeLocalOutputSize", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "changeDefaultScale", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "changeLocalOutputHeight", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "changeLocalOutputWidth", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "changeLockResolution", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "setRotation", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "rotateClockwise", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "rotateAntiClockwise", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "rotateOutputContainer", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "flipHorizontally", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "flipVertically", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "applyDefaultCrop", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "applyInitialCrop", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "updateCropMask", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "clickableCanvas", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "onLeftTop", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "onLeftBottom", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "onRightTop", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "onRightBottom", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "proportionalSize", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "onBlurWidth", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "onBlurHeight", void 0);
    __decorate([
        action
    ], TransformToolStore.prototype, "updateInitialCropMaskPosition", null);
    __decorate([
        action
    ], TransformToolStore.prototype, "updatePreviewSizeWRTImageSize", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "cropState", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "identifier", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "ratio", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "isRatioFlipped", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "height", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "width", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "localOutputImageSize", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "localOutputHeight", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "localOutputWidth", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "lockResolution", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "forceDimensions", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "rotationInDegrees", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "outputRotation", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "isDragMode", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "rotateFlipState", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "selectedCategoryIdentifier", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "categories", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "entities", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "items", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "config", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "locale", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "isOptionSelected", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "leftTop", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "leftBottom", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "rightTop", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "rightBottom", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "cropMaskPosition", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "cropMaskSize", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "state", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "defaultImageSize", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "defaultCropMaskSize", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "defaultCropMaskPosition", null);
    __decorate([
        computed
    ], TransformToolStore.prototype, "defaultScale", null);
    return TransformToolStore;
}());

var defaultIdentifier = 'imgly_font_open_sans_bold';
var defaultTextColorId = 'white';
var defaultBackgroundColorId = 'transparent';
var textDefaultState = {
    text: 'Write Something',
    identifier: defaultIdentifier,
    fontSize: 73.3,
    defaultFontSize: 73.3,
    fontFamily: 'Open Sans',
    fontStyle: '',
    fontWeight: 'bold',
    lineHeight: 1,
    alignment: 'center',
    textColor: ColorObject[defaultTextColorId],
    backgroundColor: ColorObject[defaultBackgroundColorId] || [0, 0, 0, 0],
    width: 0,
};
var textInitialState = {};

var FONT_WEIGHTS = {
    100: 'Extra Light',
    200: 'Light',
    300: 'Book',
    400: 'Regular',
    500: 'Medium',
    600: 'Semibold',
    700: 'Bold',
    800: 'Black',
    900: 'Extra Black',
    bold: 'Bold',
    normal: 'Regular',
    lighter: 'Lighter',
};
var TextToolStore = /** @class */ (function () {
    function TextToolStore(editor) {
        var _this = this;
        this.state = observable.map(textInitialState);
        this.loadingObservable = observable.box(false);
        this.activeBackgroundColorId = observable.box(defaultBackgroundColorId);
        this.activeTextColorId = observable.box(defaultTextColorId);
        this.add = function () {
            var callback = function () {
                _this.editor.spriteStore.addText({
                    state: {
                        identifier: textDefaultState.identifier,
                        text: textDefaultState.text,
                        textColor: textDefaultState.textColor,
                        backgroundColor: textDefaultState.backgroundColor,
                        textColorId: defaultTextColorId,
                        backgroundColorId: defaultBackgroundColorId,
                        lineHeight: textDefaultState.lineHeight,
                        alignment: textDefaultState.alignment,
                        fontSize: 0,
                    },
                });
            };
            _this.loadfonts(callback);
        };
        this.setEditMode = function (editMode) {
            _this.editor.spriteStore.setEditMode(editMode);
        };
        this.changeFont = function (identifier) {
            var option = _this.fonts.find(function (item) { return item.identifier === identifier; });
            _this.changeIdentifier(option, _this.id);
            if (_this.id) {
                _this.addSnapshot("edit" /* EDIT */, _this.locale.history.fontFamily);
            }
        };
        this.changeIdentifier = function (option, id) {
            runInAction(function () {
                if (option && id) {
                    var text = _this.state.get(id);
                    if (text) {
                        _this.editor.spriteStore.setContainerProperties(id, {
                            fontIdentifier: option.identifier,
                        }, true);
                        var properties = _this.editor.spriteStore.getContainerProperties(id);
                        text.identifier = properties.fontIdentifier;
                        text.fontFamily = option.fontFamily;
                        text.fontStyle = option.fontStyle;
                        text.fontWeight = option.fontWeight;
                        text.fontSize = properties.fontSize;
                        text.width = properties.width;
                        text.defaultFontSize = text.fontSize;
                        _this.editor.spriteStore.setDefaultSize(id);
                        _this.state.set(id, text);
                    }
                }
            });
        };
        this.changeFontSize = function (fontSize, updateDefaultFont) {
            if (updateDefaultFont === void 0) { updateDefaultFont = false; }
            if (_this.id) {
                var text = _this.state.get(_this.id);
                if (text) {
                    text.fontSize = fontSize;
                    if (updateDefaultFont) {
                        text.defaultFontSize = fontSize;
                    }
                    _this.state.set(_this.id, text);
                }
            }
        };
        this.updateDefaultFontSize = function () {
            if (_this.id) {
                var text = _this.state.get(_this.id);
                if (text) {
                    text.defaultFontSize = text.fontSize;
                    _this.state.set(_this.id, text);
                }
            }
        };
        this.changeSize = function (id, properties) {
            var text = _this.state.get(id);
            if (text) {
                text.width = properties.width;
                text.fontSize = properties.fontSize;
                text.defaultFontSize = properties.fontSize;
                _this.state.set(id, text);
            }
        };
        this.changeWidth = function (width) {
            if (_this.id) {
                var text = _this.state.get(_this.id);
                if (text) {
                    text.width = width;
                    _this.state.set(_this.id, text);
                    _this.editor.spriteStore.setDefaultSize(_this.id);
                }
            }
        };
        this.changeText = function (value) {
            if (_this.id) {
                var text = _this.state.get(_this.id);
                if (text) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        text: value,
                    }, true);
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    text.text = properties.text;
                    text.fontSize = properties.fontSize;
                    text.defaultFontSize = properties.fontSize;
                    _this.editor.spriteStore.setDefaultSize(_this.id);
                    _this.state.set(_this.id, text);
                    _this.addSnapshot("edit" /* EDIT */, _this.locale.history.edit);
                }
            }
        };
        this.changeLineHeight = function (lineHeight) {
            if (_this.id) {
                var text = _this.state.get(_this.id);
                if (text && lineHeight) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        lineHeight: lineHeight,
                    }, true);
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    text.lineHeight = properties.lineHeight;
                    _this.state.set(_this.id, text);
                }
            }
        };
        this.changeColor = function (textColor, identifier) {
            if (_this.id) {
                var text = _this.state.get(_this.id);
                if (text) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        textColor: textColor,
                    });
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    text.textColor = properties.textColor;
                    _this.activeTextColorId.set(identifier);
                    _this.state.set(_this.id, text);
                }
            }
        };
        this.changeBackgroundColor = function (backgroundColor, identifier) {
            if (_this.id) {
                var text = _this.state.get(_this.id);
                if (text) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        backgroundColor: backgroundColor,
                    });
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    text.backgroundColor = properties.backgroundColor;
                    _this.activeBackgroundColorId.set(identifier);
                    _this.state.set(_this.id, text);
                }
            }
        };
        this.colorSnapshot = function () {
            _this.addSnapshot("edit" /* EDIT */, _this.locale.history.textColor);
        };
        this.backgroundColorSnapshot = function () {
            _this.addSnapshot("edit" /* EDIT */, _this.locale.history.backgroundColor);
        };
        this.changeAlignment = function (alignment) {
            if (_this.id) {
                var text = _this.state.get(_this.id);
                if (text) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        alignment: alignment,
                    });
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    text.alignment = properties.alignment;
                    _this.state.set(_this.id, text);
                    _this.addSnapshot("edit" /* EDIT */, _this.locale.history.alignment);
                }
            }
        };
        this.setFontSize = function (fontSize) {
            if (_this.id) {
                var text = _this.state.get(_this.id);
                if (text) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        fontSize: fontSize,
                    }, true);
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    text.fontSize = properties.fontSize;
                    text.defaultFontSize = properties.fontSize;
                    _this.editor.spriteStore.setDefaultSize(_this.id);
                    _this.state.set(_this.id, text);
                }
            }
        };
        this.editor = editor;
        if (!this.fonts.find(function (i) { return i.identifier === textDefaultState.identifier; })) {
            textDefaultState.identifier = this.fonts[0].identifier;
        }
        textDefaultState.text = this.locale.canvasControls.placeholderText;
    }
    TextToolStore.defaultText = function () {
        return textDefaultState.text;
    };
    Object.defineProperty(TextToolStore, "defaultColors", {
        get: function () {
            return Editor.defaultColors;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore, "defaultBackgroundColors", {
        get: function () {
            return Editor.defaultBackgroundColors;
        },
        enumerable: true,
        configurable: true
    });
    TextToolStore.getDisplayFontStyle = function (font) {
        var weight = font.fontWeight && FONT_WEIGHTS[font.fontWeight].toLowerCase() !== 'regular' ? FONT_WEIGHTS[font.fontWeight] : '';
        var style = font.fontStyle && font.fontStyle.toLowerCase() !== 'normal' ? font.fontStyle : '';
        return (weight + " " + style).trim();
    };
    TextToolStore.prototype.loadfonts = function (callback) {
        var _this = this;
        if (!this.fontsLoaded) {
            var fontManager = this.editor.assetProvider.getFontManager();
            var textFontIDs_1 = this.editor.assetProvider.getFontAssets().map(function (a) { return a.identifier; });
            fontManager
                .loadFontsWithIdentifiers(textFontIDs_1)
                .then(function () {
                _this.loadingObservable.set(true);
                callback();
            })
                .catch(function () {
                _this.editor.modalStore.showActionModal({
                    identifier: 'fontLoading',
                    handlers: {},
                    error: textFontIDs_1[0],
                });
            });
        }
        else {
            callback();
        }
    };
    TextToolStore.prototype.doesTextAssetExist = function (identifier) {
        return this.editor.assetProvider.getFontAssets().findIndex(function (t) { return t.identifier === identifier; }) !== -1;
    };
    TextToolStore.prototype.addOrselect = function () {
        if (!this.state.size) {
            this.add();
        }
        else {
            this.selectLast();
        }
    };
    TextToolStore.prototype.selectLast = function () {
        this.editor.spriteStore.selectHighestOrderSprite(Array.from(this.state.keys()));
    };
    TextToolStore.prototype.duplicate = function () {
        if (this.id) {
            var transform = this.editor.spriteStore.getDuplicateContainerTransform(this.id);
            this.editor.spriteStore.addText({
                state: {
                    identifier: this.identifier,
                    text: this.text,
                    textColor: toJS(this.textColor),
                    lineHeight: this.lineHeight,
                    alignment: this.alignment,
                    fontSize: this.fontSize,
                    backgroundColor: toJS(this.backgroundColor),
                    textColorId: this.activeTextColor,
                    backgroundColorId: this.activeBackgroundColor,
                    width: this.width,
                },
                transform: transform,
            });
        }
    };
    TextToolStore.prototype.bringToFront = function () {
        if (this.id) {
            this.editor.spriteStore.bringToFront(this.id);
        }
    };
    TextToolStore.prototype.delete = function () {
        if (this.id) {
            var identifier = this.id;
            this.editor.spriteStore.removeSprite(identifier);
            this.state.delete(identifier);
            this.selectLast();
        }
    };
    TextToolStore.prototype.toolSnapshot = function () {
        this.addSnapshot("edit" /* EDIT */, this.locale.history.lineSpacing);
    };
    TextToolStore.prototype.addSnapshot = function (type, desc) {
        if (this.currentText) {
            this.editor.spriteStore.addSnapshot(type, desc);
        }
    };
    TextToolStore.prototype.updateStateFromHistory = function (id, text) {
        this.setState(id, text);
        this.editor.spriteStore.setContainerProperties(id, text);
    };
    TextToolStore.prototype.setState = function (id, state) {
        var text = this.state.get(id);
        if (text) {
            if (state.alignment) {
                text.alignment = state.alignment;
            }
            if (state.text) {
                text.text = state.text;
            }
            if (state.lineHeight) {
                text.lineHeight = state.lineHeight;
            }
            if (state.textColor) {
                text.textColor = state.textColor;
                if (state.textColorId) {
                    this.activeTextColorId.set(state.textColorId);
                }
            }
            if (state.backgroundColor) {
                text.backgroundColor = state.backgroundColor;
                if (state.backgroundColorId) {
                    this.activeBackgroundColorId.set(state.backgroundColorId);
                }
            }
            if (state.fontIdentifier) {
                text.identifier = state.fontIdentifier;
            }
            if (state.fontSize) {
                text.fontSize = state.fontSize;
                text.defaultFontSize = state.fontSize;
            }
            if (state.width) {
                text.width = state.width;
            }
        }
        else {
            var option = this.fonts.find(function (item) { return item.identifier === state.fontIdentifier; });
            this.state.set(id, {
                text: state.text,
                identifier: state.fontIdentifier,
                alignment: state.alignment,
                textColor: state.textColor ? state.textColor : textDefaultState.textColor,
                backgroundColor: state.backgroundColor
                    ? state.backgroundColor
                    : textDefaultState.backgroundColor,
                fontFamily: option.fontFamily,
                fontStyle: option.fontStyle,
                fontSize: state.fontSize,
                fontWeight: option.fontWeight,
                lineHeight: state.lineHeight,
                width: state.width,
                defaultFontSize: state.fontSize,
            });
            if (state.textColorId) {
                this.activeTextColorId.set(state.textColorId);
            }
            if (state.backgroundColorId) {
                this.activeBackgroundColorId.set(state.backgroundColorId);
            }
        }
        this.editor.spriteStore.setDefaultSize();
    };
    TextToolStore.prototype.pureReset = function () {
        this.state = observable.map(textInitialState);
    };
    Object.defineProperty(TextToolStore.prototype, "isEditMode", {
        get: function () {
            return this.editor.spriteStore.isEditMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "isTextSelected", {
        get: function () {
            return this.editor.spriteStore.isSpriteText;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "fontsLoaded", {
        get: function () {
            return this.loadingObservable.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "activeTextColor", {
        get: function () {
            return this.activeTextColorId.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "activeBackgroundColor", {
        get: function () {
            return this.activeBackgroundColorId.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "currentText", {
        get: function () {
            if (this.isTextSelected) {
                var text = this.state.get(this.id);
                if (text) {
                    return text;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "text", {
        get: function () {
            if (this.currentText) {
                return this.currentText.text;
            }
            return textDefaultState.text;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "fontSize", {
        get: function () {
            if (this.currentText) {
                return this.currentText.fontSize;
            }
            return textDefaultState.fontSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "defaultFontSize", {
        get: function () {
            if (this.currentText) {
                return this.currentText.defaultFontSize;
            }
            return textDefaultState.defaultFontSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "width", {
        /** since the width is not used for UI so it's saved with world co-ordinates */
        get: function () {
            if (this.currentText) {
                return this.currentText.width;
            }
            return textDefaultState.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "fontFamily", {
        get: function () {
            if (this.currentText) {
                return this.currentText.fontFamily;
            }
            return textDefaultState.fontFamily;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "fontStyle", {
        get: function () {
            if (this.currentText) {
                return this.currentText.fontStyle;
            }
            return textDefaultState.fontStyle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "fontWeight", {
        get: function () {
            if (this.currentText) {
                return this.currentText.fontWeight;
            }
            return textDefaultState.fontWeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "lineHeight", {
        get: function () {
            if (this.currentText) {
                return this.currentText.lineHeight;
            }
            return textDefaultState.lineHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "identifier", {
        get: function () {
            if (this.currentText) {
                return this.currentText.identifier;
            }
            return textDefaultState.identifier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "id", {
        get: function () {
            if (this.isTextSelected) {
                return this.editor.spriteStore.id;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "alignment", {
        get: function () {
            if (this.currentText) {
                return this.currentText.alignment;
            }
            return textDefaultState.alignment;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "textColor", {
        get: function () {
            if (this.currentText) {
                return this.currentText.textColor;
            }
            return textDefaultState.textColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "backgroundColor", {
        get: function () {
            if (this.currentText) {
                return this.currentText.backgroundColor;
            }
            return textDefaultState.backgroundColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "config", {
        get: function () {
            return this.editor.configStore.config[Tool.TEXT];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "locale", {
        get: function () {
            return this.editor.configStore.locale[Tool.TEXT];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "localeColor", {
        get: function () {
            return this.editor.configStore.locale.common.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "rawOptions", {
        get: function () {
            return this.editor.assetProvider.getFontAssetsForText();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "availableOptions", {
        get: function () {
            if (this.config.fonts.length) {
                return this.config.fonts.map(function (f) { return f.identifier; });
            }
            return this.rawOptions.map(function (option) { return option.identifier; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "fonts", {
        get: function () {
            var _this = this;
            return this.rawOptions.reduce(function (acc, font) {
                if (_this.availableOptions.indexOf(font.identifier) !== -1) {
                    return __spread(acc, [
                        {
                            identifier: font.identifier,
                            fontFamily: font.fontFamily,
                            fontStyle: font.fontStyle || '',
                            fontWeight: font.fontWeight || '',
                        },
                    ]);
                }
                return acc;
            }, []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextToolStore.prototype, "fontFamilies", {
        get: function () {
            return __spread(new Set(this.fonts));
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        action
    ], TextToolStore.prototype, "addOrselect", null);
    __decorate([
        action
    ], TextToolStore.prototype, "selectLast", null);
    __decorate([
        action
    ], TextToolStore.prototype, "add", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "duplicate", null);
    __decorate([
        action
    ], TextToolStore.prototype, "bringToFront", null);
    __decorate([
        action
    ], TextToolStore.prototype, "delete", null);
    __decorate([
        action
    ], TextToolStore.prototype, "setEditMode", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "changeFont", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "changeIdentifier", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "changeFontSize", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "updateDefaultFontSize", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "changeSize", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "changeWidth", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "changeText", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "changeLineHeight", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "changeColor", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "changeBackgroundColor", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "changeAlignment", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "updateStateFromHistory", null);
    __decorate([
        action
    ], TextToolStore.prototype, "setState", null);
    __decorate([
        action
    ], TextToolStore.prototype, "setFontSize", void 0);
    __decorate([
        action
    ], TextToolStore.prototype, "pureReset", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "isEditMode", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "isTextSelected", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "fontsLoaded", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "activeTextColor", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "activeBackgroundColor", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "currentText", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "text", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "fontSize", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "defaultFontSize", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "width", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "fontFamily", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "fontStyle", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "fontWeight", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "lineHeight", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "identifier", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "id", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "alignment", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "textColor", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "backgroundColor", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "config", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "locale", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "localeColor", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "rawOptions", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "availableOptions", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "fonts", null);
    __decorate([
        computed
    ], TextToolStore.prototype, "fontFamilies", null);
    return TextToolStore;
}());

var defaultIdentifier$1 = 'imgly_text_design_blocks';
var defaultTextDesignColorId = 'white';
var textDesignDefaultState = {
    identifier: defaultIdentifier$1,
    color: ColorObject[defaultTextDesignColorId],
    isInverted: false,
    text: 'Write Something',
    seed: 0,
    padding: 0,
    width: 0,
};
var textDesignInitialState = {};

var TextDesignToolStore = /** @class */ (function () {
    function TextDesignToolStore(editor) {
        var _this = this;
        this.state = observable.map(textDesignInitialState);
        this.fontsLoaded = false;
        this.activeTextColorId = observable.box(defaultTextDesignColorId);
        this.add = function () {
            var callback = function () {
                _this.editor.spriteStore.addTextDesign({
                    state: {
                        identifier: textDesignDefaultState.identifier,
                        text: textDesignDefaultState.text,
                        color: textDesignDefaultState.color,
                        isInverted: textDesignDefaultState.isInverted,
                        seed: textDesignDefaultState.seed,
                        textColorId: defaultTextDesignColorId,
                        padding: 0,
                    },
                });
            };
            _this.loadfonts(callback);
        };
        this.changeText = function (value) {
            if (_this.id) {
                var textDesign = _this.state.get(_this.id);
                if (textDesign) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        text: value,
                    }, true);
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    textDesign.text = properties.text;
                    _this.state.set(_this.id, textDesign);
                    _this.addSnapshot("edit" /* EDIT */, _this.locale.history.edit);
                }
            }
        };
        this.setEditMode = function (editMode) {
            _this.editor.spriteStore.setEditMode(editMode);
        };
        this.changeSeed = function () {
            if (_this.id) {
                var textDesign = _this.state.get(_this.id);
                if (textDesign) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        seed: Math.floor(Math.random() * 1000),
                    }, true);
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    textDesign.seed = properties.seed;
                    _this.state.set(_this.id, textDesign);
                    _this.addSnapshot("edit" /* EDIT */, _this.locale.history.shuffle);
                }
            }
        };
        this.changeIdentifier = function (identifier, addSnapshot) {
            if (addSnapshot === void 0) { addSnapshot = true; }
            if (_this.id && identifier !== _this.identifier) {
                var id = _this.id;
                var textDesignState = _this.state.get(id);
                var transform = _this.editor.spriteStore.getContainerTransform(id);
                _this.editor.spriteStore.addTextDesign({
                    spriteId: id,
                    state: {
                        identifier: identifier,
                        text: textDesignState.text,
                        color: toJS(textDesignState.color),
                        isInverted: textDesignState.isInverted,
                        seed: textDesignState.seed,
                        padding: textDesignState.padding,
                        width: textDesignState.width,
                        textColorId: defaultTextDesignColorId,
                    },
                    transform: transform,
                }, addSnapshot, true);
            }
        };
        this.changeColor = function (color, identifier) {
            if (_this.id) {
                var textDesign = _this.state.get(_this.id);
                if (textDesign) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        color: color,
                    });
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    textDesign.color = properties.color;
                    _this.activeTextColorId.set(identifier);
                    _this.state.set(_this.id, textDesign);
                }
            }
        };
        this.colorSnapshot = function () {
            _this.addSnapshot("edit" /* EDIT */, _this.locale.history.color);
        };
        this.invertBackground = function () {
            if (_this.id) {
                var textDesign = _this.state.get(_this.id);
                if (textDesign) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        inverted: !textDesign.isInverted,
                    }, true);
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    textDesign.isInverted = properties.inverted;
                    _this.state.set(_this.id, textDesign);
                    _this.addSnapshot("edit" /* EDIT */, _this.locale.history.invert);
                }
            }
        };
        this.changeWidth = function (width) {
            if (_this.id) {
                var text = _this.state.get(_this.id);
                if (text) {
                    text.width = width;
                    _this.state.set(_this.id, text);
                    _this.editor.spriteStore.setDefaultSize(_this.id);
                }
            }
        };
        this.editor = editor;
        this.entityManager = new EntityMapper([
            {
                identifier: '',
                name: '',
                items: this.editor.assetProvider.getAssets('textdesign'),
            },
        ], __assign({}, this.config, { categoryKey: '', itemKey: 'thumbnailURI', flattenCategories: true, locale: {}, getAssetPath: this.editor.getAssetPath('textdesign') }));
        if (!this.entityManager.items.find(function (i) { return i.identifier === textDesignDefaultState.identifier; })) {
            textDesignDefaultState.identifier = this.entityManager.items[0].identifier;
        }
        textDesignDefaultState.text = this.locale.canvasControls.placeholderText;
    }
    Object.defineProperty(TextDesignToolStore, "colors", {
        get: function () {
            return Editor.defaultColors;
        },
        enumerable: true,
        configurable: true
    });
    TextDesignToolStore.defaultText = function () {
        return textDesignDefaultState.text;
    };
    TextDesignToolStore.prototype.loadfonts = function (callback) {
        var _this = this;
        if (!this.fontsLoaded) {
            var fontManager = this.editor.assetProvider.getFontManager();
            var textDesignFontIds_1 = this.editor.assetProvider.getFontAssetsForTextDesign().map(function (a) { return a.identifier; });
            fontManager
                .loadFontsWithIdentifiers(textDesignFontIds_1)
                .then(function () {
                _this.fontsLoaded = true;
                callback();
            })
                .catch(function () {
                _this.editor.modalStore.showActionModal({
                    identifier: 'fontLoading',
                    handlers: {},
                    error: textDesignFontIds_1[0],
                });
            });
        }
        else {
            callback();
        }
    };
    TextDesignToolStore.prototype.doesTextDesignAssetExist = function (identifier) {
        return this.entityManager.items.findIndex(function (t) { return t.identifier === identifier; }) !== -1;
    };
    TextDesignToolStore.prototype.addOrselect = function () {
        if (!this.state.size) {
            this.add();
        }
        else {
            this.selectLast();
        }
    };
    TextDesignToolStore.prototype.selectLast = function () {
        this.editor.spriteStore.selectHighestOrderSprite(Array.from(this.state.keys()));
    };
    TextDesignToolStore.prototype.updateStateFromHistory = function (id, textdesign) {
        var fromstate = this.state.get(id);
        if (textdesign.identifier === fromstate.identifier) {
            this.setState(id, textdesign);
            this.editor.spriteStore.setContainerProperties(id, textdesign);
        }
        else {
            this.changeIdentifier(textdesign.identifier, false);
        }
    };
    TextDesignToolStore.prototype.setState = function (id, state) {
        var textDesign = this.state.get(id);
        if (textDesign) {
            if (state.inverted) {
                textDesign.isInverted = state.inverted;
            }
            if (state.seed) {
                textDesign.seed = state.seed;
            }
            if (state.color) {
                textDesign.color = state.color;
                if (state.textColorId) {
                    this.activeTextColorId.set(state.textColorId);
                }
            }
            if (state.padding) {
                textDesign.padding = state.padding;
            }
            if (state.width) {
                textDesign.width = state.width;
            }
        }
        else {
            this.state.set(id, {
                text: state.text,
                isInverted: state.inverted,
                identifier: state.identifier,
                seed: state.seed,
                color: state.color ? state.color : textDesignDefaultState.color,
                padding: state.padding,
                width: state.width,
            });
            if (state.textColorId) {
                this.activeTextColorId.set(state.textColorId);
            }
        }
    };
    TextDesignToolStore.prototype.duplicate = function () {
        if (this.id) {
            var transform = this.editor.spriteStore.getDuplicateContainerTransform(this.id);
            this.editor.spriteStore.addTextDesign({
                state: {
                    identifier: this.identifier,
                    text: this.text,
                    color: toJS(this.color),
                    isInverted: this.isInverted,
                    seed: this.seed,
                    padding: this.padding,
                    width: this.width,
                    textColorId: this.activeTextColor,
                },
                transform: transform,
            });
        }
    };
    TextDesignToolStore.prototype.bringToFront = function () {
        if (this.id) {
            this.editor.spriteStore.bringToFront(this.id);
        }
    };
    TextDesignToolStore.prototype.addSnapshot = function (type, desc) {
        if (this.currentTextDesign) {
            this.editor.spriteStore.addSnapshot(type, desc);
        }
    };
    TextDesignToolStore.prototype.delete = function (id) {
        if (id === void 0) { id = this.id; }
        if (id) {
            this.editor.spriteStore.removeSprite(id);
            this.state.delete(id);
            this.selectLast();
        }
    };
    TextDesignToolStore.prototype.pureReset = function () {
        this.state = observable.map(textDesignInitialState);
    };
    Object.defineProperty(TextDesignToolStore.prototype, "isTextDesignSelected", {
        get: function () {
            return this.editor.spriteStore.isSpriteTextDesign;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "isEditMode", {
        get: function () {
            return this.editor.spriteStore.isEditMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "activeTextColor", {
        get: function () {
            return this.activeTextColorId.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "currentTextDesign", {
        get: function () {
            if (this.isTextDesignSelected && this.id) {
                var textDesign = this.state.get(this.id);
                if (textDesign) {
                    return textDesign;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "id", {
        get: function () {
            if (this.isTextDesignSelected) {
                return this.editor.spriteStore.id;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "text", {
        get: function () {
            if (this.currentTextDesign) {
                return this.currentTextDesign.text;
            }
            return textDesignDefaultState.text;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "seed", {
        get: function () {
            if (this.currentTextDesign) {
                return this.currentTextDesign.seed;
            }
            return textDesignDefaultState.seed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "padding", {
        get: function () {
            if (this.currentTextDesign) {
                return this.currentTextDesign.padding;
            }
            return textDesignDefaultState.padding;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "width", {
        /** since the width is not used for UI so it's saved with world co-ordinates */
        get: function () {
            if (this.currentTextDesign) {
                return this.currentTextDesign.width;
            }
            return textDesignDefaultState.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "identifier", {
        get: function () {
            if (this.currentTextDesign) {
                return this.currentTextDesign.identifier;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "isInverted", {
        get: function () {
            if (this.currentTextDesign) {
                return this.currentTextDesign.isInverted;
            }
            return textDesignDefaultState.isInverted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "color", {
        get: function () {
            if (this.currentTextDesign) {
                return this.currentTextDesign.color;
            }
            return textDesignDefaultState.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "config", {
        get: function () {
            return this.editor.configStore.config[Tool.TEXT_DESIGN];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "locale", {
        get: function () {
            return this.editor.configStore.locale[Tool.TEXT_DESIGN];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "localeColor", {
        get: function () {
            return this.editor.configStore.locale.common.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDesignToolStore.prototype, "entities", {
        get: function () {
            return this.entityManager.getEntities();
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        action
    ], TextDesignToolStore.prototype, "addOrselect", null);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "selectLast", null);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "add", void 0);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "updateStateFromHistory", null);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "setState", null);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "changeText", void 0);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "setEditMode", void 0);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "duplicate", null);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "bringToFront", null);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "delete", null);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "changeSeed", void 0);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "changeIdentifier", void 0);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "changeColor", void 0);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "invertBackground", void 0);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "changeWidth", void 0);
    __decorate([
        action
    ], TextDesignToolStore.prototype, "pureReset", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "isTextDesignSelected", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "isEditMode", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "activeTextColor", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "currentTextDesign", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "id", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "text", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "seed", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "padding", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "width", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "identifier", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "isInverted", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "color", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "config", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "locale", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "localeColor", null);
    __decorate([
        computed
    ], TextDesignToolStore.prototype, "entities", null);
    return TextDesignToolStore;
}());

/**
 * LoadImage based on the resize parameter resolves with 2 images
 * 1. image in the original size
 * 2. resized image (used in custom sticker upload to create smaller size thumbnails)
 * TODO wantedWidth could be a parameter to this function
 * @param src
 * @param resize
 */
function loadImage(src, resize) {
    if (resize === void 0) { resize = false; }
    return new Promise(function (resolve, reject) {
        var image = new Image();
        image.addEventListener('load', function () {
            var smallImage = null;
            if (resize) {
                // create a canvas and get its context.
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');
                // set the dimensions at the wanted size.
                var wantedWidth = 150;
                var wantedHeight = (wantedWidth * image.height) / image.width;
                canvas.width = wantedWidth;
                canvas.height = wantedHeight;
                // resize the image with the canvas method drawImage();
                ctx.drawImage(image, 0, 0, wantedWidth, wantedHeight);
                smallImage = canvas.toDataURL();
            }
            resolve({ image: src, smallImage: smallImage });
        });
        image.addEventListener('error', function () {
            reject();
        });
        image.src = src;
    });
}
function loadFile(file, resize) {
    var _this = this;
    if (resize === void 0) { resize = false; }
    return new Promise(function (resolve, reject) {
        var reader = new FileReader();
        reader.onload = function (evt) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                loadImage(evt.target.result, resize)
                    .then(function (imageData) {
                    resolve(__assign({}, imageData, { name: file.name || '', type: file.type, id: uuid() }));
                })
                    .catch(function (e) {
                    reject(e);
                });
                return [2 /*return*/];
            });
        }); };
        reader.readAsDataURL(file);
    });
}

var vectorToSize = function (v) { return ({ height: v.y, width: v.x }); };
var initialSpriteState = {};
var notSelectedId = 'none';
var defaultLocalTransform = {
    position: { x: 0, y: 0 },
    rotation: 0,
};
/**
 * There is a lot of common functionalities between the sprites based on the UI state
 * the position, rotation and size, flipState
 * All the calculations are handled at this store for sprites i.e., this one acts as a RootStore
 * Other tool spectific states are handled in the respective toolstore
 *
 * The biggest difference between effect stores and sprites is
 * There can be multiple instances of a sprite
 *
 * sticker => opacity, tintColor(for shapes)
 * text => fontfamily, fontStyle, color, background, lineHeight, alignment
 * textDesign => text color, seed
 */
var SpriteStore = /** @class */ (function () {
    function SpriteStore(editor) {
        var _this = this;
        this.state = observable.map(initialSpriteState);
        this.selectedId = observable.box(notSelectedId);
        this.editMode = observable.box(false);
        this.dragMode = observable.box(false);
        this.minLength = 0;
        this.setEditMode = function (editMode) {
            if (_this.currentSprite) {
                if ([Tool.TEXT, Tool.TEXT_DESIGN].indexOf(_this.tool) !== -1) {
                    if (editMode) {
                        _this.editor.modalStore.showModalOfType(ModalType.TEXT_EDIT);
                    }
                    else {
                        _this.editor.modalStore.hideModal();
                    }
                    _this.editMode.set(editMode);
                }
            }
        };
        this.onWidthDrag = function (_a) {
            var x = _a.x, y = _a.y;
            var position = new Vector2(_this.currentSprite.position);
            var newPosition = new Vector2(x, y);
            var length = newPosition.subtract(position).magnitude;
            var width = _this.editor.previewToWorld(2 * length);
            if (width > _this.minLength) {
                _this.setContainerProperties(_this.id, { width: width }, true);
                if (_this.isSpriteText) {
                    var properties = _this.getContainerProperties(_this.id);
                    _this.textToolStore.changeWidth(properties.width);
                }
            }
        };
        this.onPaddingDrag = function (_a) {
            var x = _a.x, y = _a.y;
            var position = new Vector2(_this.currentSprite.position);
            var newPosition = new Vector2(x, y);
            var length = newPosition.subtract(position).floored.abs.x;
            var padding = length - _this.defaultSize.width / 2;
            if (padding >= 0) {
                _this.setContainerProperties(_this.id, { padding: _this.editor.previewToWorld(padding) }, true);
            }
        };
        this.reverseTextHorizontally = function () {
            Object.values(_this.container).forEach(function (container) {
                if (container.type === 'text' || container.type === 'text-design') {
                    container.setFlipHorizontally(!container.getFlipHorizontally());
                }
            });
        };
        this.reverseTextVertically = function () {
            Object.values(_this.container).forEach(function (container) {
                if (container.type === 'text' || container.type === 'text-design') {
                    container.setFlipVertically(!container.getFlipVertically());
                }
            });
        };
        this.updatePositionAndSize = function (id, updateRotation) {
            if (id === void 0) { id = _this.id; }
            if (updateRotation === void 0) { updateRotation = false; }
            var _a = _this.getSizePositionFromContainer(id), position = _a.position, size = _a.size;
            var sprite = _this.state.get(id);
            if (sprite) {
                sprite.position.x = position.x;
                sprite.position.y = position.y;
                sprite.size.width = size.width;
                sprite.size.height = size.height;
                if (updateRotation) {
                    var rotation = _this.container[id].getRotation();
                    _this.container[id].setRotation(rotation);
                    sprite.rotation = _this.container[id].getRotation();
                }
                _this.state.set(id, sprite);
            }
        };
        this.getDefaultSize = function (id) {
            if (id === void 0) { id = _this.id; }
            var selectedContainer = _this.container[id];
            if (selectedContainer) {
                var sizeInWorldSpace = selectedContainer.getSizeInWorldSpace();
                return {
                    width: Math.floor(_this.editor.worldToPreview(sizeInWorldSpace.width)),
                    height: Math.floor(_this.editor.worldToPreview(sizeInWorldSpace.height)),
                };
            }
            return { width: 0, height: 0 };
        };
        this.editor = editor;
        this.container = {};
        this.stickerToolStore = new StickerToolStore(editor);
        this.textToolStore = new TextToolStore(editor);
        this.textDesignToolStore = new TextDesignToolStore(editor);
        this.rect = new RectStore(this.editor, this);
        this.minLength = this.editor.configStore.measurements.canvasControls.sprite.minSize / Math.sqrt(2);
    }
    SpriteStore.magnitude = function (x, y) {
        return new Vector2(x, y || x).magnitude;
    };
    SpriteStore.sizeMagnitude = function (size) {
        return Vector2.fromSize(size).magnitude;
    };
    SpriteStore.prototype.addSticker = function (stickerArgs, addSnapshot) {
        if (addSnapshot === void 0) { addSnapshot = true; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addStickerAsync(stickerArgs, addSnapshot)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    SpriteStore.prototype.addStickerAsync = function (_a, addSnapshot) {
        var spriteId = _a.spriteId, state = _a.state, transform = _a.transform;
        if (addSnapshot === void 0) { addSnapshot = true; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_b) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        transform = _this.getTransform(transform);
                        var identifier = state.identifier;
                        var index = _this.editor.orderHelper.addSprite(identifier);
                        _this.editor.engine
                            .addStickerFromAssets(identifier, _this.editor.engineMediator.image.container, index)
                            .then(function (stickerContainer) { return __awaiter(_this, void 0, void 0, function () {
                            var id, defaultsize, scale, size, value, _a, flipHorizontally, flipVertically, data;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        // Set Id
                                        if (spriteId) {
                                            stickerContainer.setData({ id: spriteId });
                                        }
                                        id = stickerContainer.getID();
                                        this.container[id] = stickerContainer;
                                        this.editor.orderHelper.renameSprite(identifier, id);
                                        defaultsize = this.getDefaultSize(id);
                                        stickerContainer.setPivot(0.5, 0.5);
                                        if (transform.scale) {
                                            scale = transform.scale;
                                        }
                                        else if (transform.size) {
                                            scale = {
                                                x: transform.size.width / defaultsize.width,
                                                y: transform.size.height / defaultsize.height,
                                            };
                                        }
                                        else {
                                            size = this.editor.shortestOutputSide * 0.4;
                                            value = SpriteStore.magnitude(size) / SpriteStore.sizeMagnitude(stickerContainer.getSizeInWorldSpace());
                                            scale = { x: value, y: value };
                                        }
                                        _a = this.editor.outputContainer.getData(), flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
                                        stickerContainer.setFlipHorizontally(flipHorizontally);
                                        stickerContainer.setFlipVertically(flipVertically);
                                        stickerContainer.setTransform({
                                            position: transform.position,
                                            scale: scale,
                                            rotation: transform.rotation,
                                        });
                                        if (state.flipHorizontally !== undefined) {
                                            stickerContainer.setFlipHorizontally(state.flipHorizontally);
                                        }
                                        this.setContainerProperties(id, __assign({}, state));
                                        data = stickerContainer.getData();
                                        this.setInitialSpriteState(id, Tool.STICKER, defaultsize);
                                        this.stickerToolStore.setState(id, __assign({}, data, { identifier: identifier }));
                                        // render
                                        return [4 /*yield*/, this.editor.renderPromise()];
                                    case 1:
                                        // render
                                        _b.sent();
                                        if (addSnapshot) {
                                            this.selectedId.set(id);
                                            this.addSnapshot("add" /* ADD */, this.stickerLocale.add);
                                        }
                                        resolve();
                                        return [2 /*return*/];
                                }
                            });
                        }); })
                            .catch(function (err) {
                            // eslint-disable-next-line no-console
                            console.error(err);
                            reject();
                        });
                    })];
            });
        });
    };
    SpriteStore.prototype.addText = function (textAgrs, addSnapshot) {
        if (addSnapshot === void 0) { addSnapshot = true; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addTextAsync(textAgrs, addSnapshot)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    SpriteStore.prototype.addTextAsync = function (_a, addSnapshot) {
        var _this = this;
        var spriteId = _a.spriteId, state = _a.state, transform = _a.transform;
        if (addSnapshot === void 0) { addSnapshot = true; }
        return new Promise(function (resolve, reject) {
            transform = _this.getTransform(transform);
            var index = _this.editor.orderHelper.addSprite(state.identifier);
            var size = _this.editor.shortestOutputSide;
            var textData = {
                fontIdentifier: state.identifier,
                text: state.text,
                width: state.width || size * 0.6,
                fontSize: state.fontSize || size * 0.1,
                lineHeight: state.lineHeight,
                alignment: state.alignment,
                textColor: state.textColor,
                backgroundColor: state.backgroundColor,
            };
            if (state.backgroundColor === textDefaultState.backgroundColor) {
                delete textData.backgroundColor;
            }
            _this.editor.engine
                .addTextWithFontLoading(textData, _this.editor.engineMediator.image.container, index)
                .then(function (textContainer) { return __awaiter(_this, void 0, void 0, function () {
                var id, _a, flipHorizontally, flipVertically, defaultsize, data;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // Set Id
                            if (spriteId) {
                                textContainer.setData({ id: spriteId });
                            }
                            id = textContainer.getID();
                            this.container[id] = textContainer;
                            this.editor.orderHelper.renameSprite(state.identifier, this.id);
                            _a = this.editor.outputContainer.getData(), flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
                            textContainer.setFlipHorizontally(flipHorizontally);
                            textContainer.setFlipVertically(flipVertically);
                            defaultsize = this.getDefaultSize(id);
                            textContainer.setPivot(0.5, 0.5);
                            textContainer.setPosition(transform.position);
                            textContainer.setRotation(transform.rotation);
                            // Set Text tool state and transform as sprite state
                            this.setInitialSpriteState(id, Tool.TEXT, defaultsize);
                            data = textContainer.getData();
                            this.textToolStore.setState(id, __assign({}, data, { backgroundColorId: state.backgroundColorId, textColorId: state.textColorId }));
                            // render
                            return [4 /*yield*/, this.editor.renderPromise()];
                        case 1:
                            // render
                            _b.sent();
                            if (addSnapshot) {
                                this.selectedId.set(id);
                                this.addSnapshot("add" /* ADD */, this.textLocale.add);
                            }
                            resolve();
                            return [2 /*return*/];
                    }
                });
            }); })
                .catch(function (err) {
                // eslint-disable-next-line no-console
                console.error(err);
                reject();
            });
        });
    };
    SpriteStore.prototype.addTextDesign = function (textDesignArgs, addSnapshot, deleteOldId) {
        if (addSnapshot === void 0) { addSnapshot = true; }
        if (deleteOldId === void 0) { deleteOldId = false; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.addTextDesignAsync(textDesignArgs, addSnapshot, deleteOldId)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    SpriteStore.prototype.addTextDesignAsync = function (_a, addSnapshot, deleteOldId) {
        var _this = this;
        var spriteId = _a.spriteId, state = _a.state, transform = _a.transform;
        if (addSnapshot === void 0) { addSnapshot = true; }
        if (deleteOldId === void 0) { deleteOldId = false; }
        return new Promise(function (resolve, reject) {
            transform = _this.getTransform(transform);
            var index = _this.editor.orderHelper.addSprite(state.identifier);
            var size = _this.editor.shortestOutputSide;
            var textDesignData = {
                width: state.width || size * 0.6,
                text: state.text,
                color: state.color,
                inverted: state.isInverted,
                seed: state.seed,
                padding: state.padding,
            };
            _this.editor.engine
                .addTextDesignAsync(state.identifier, textDesignData, _this.editor.engineMediator.image.container, index)
                .then(function (textDesignContainer) { return __awaiter(_this, void 0, void 0, function () {
                var id, _a, flipHorizontally, flipVertically, defaultsize, data;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            // Set Id
                            if (spriteId) {
                                if (deleteOldId) {
                                    this.pureRemoveSprite(spriteId);
                                    this.textDesignToolStore.state.delete(spriteId);
                                }
                                textDesignContainer.setData({ id: spriteId });
                            }
                            id = textDesignContainer.getID();
                            this.container[id] = textDesignContainer;
                            this.editor.orderHelper.renameSprite(state.identifier, this.id);
                            _a = this.editor.outputContainer.getData(), flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
                            textDesignContainer.setFlipHorizontally(flipHorizontally);
                            textDesignContainer.setFlipVertically(flipVertically);
                            // Set textdesign container properties
                            textDesignContainer.setPivot(0.5, 0.5);
                            textDesignContainer.setPosition(transform.position);
                            textDesignContainer.setRotation(transform.rotation);
                            defaultsize = this.getDefaultSize(id);
                            this.setInitialSpriteState(id, Tool.TEXT_DESIGN, defaultsize);
                            data = textDesignContainer.getData();
                            this.textDesignToolStore.setState(id, __assign({}, data, { identifier: state.identifier, textColorId: state.textColorId }));
                            // render
                            return [4 /*yield*/, this.editor.renderPromise()];
                        case 1:
                            // render
                            _b.sent();
                            if (addSnapshot) {
                                this.selectedId.set(id);
                                this.addSnapshot("add" /* ADD */, this.textDesignLocale.add);
                            }
                            resolve();
                            return [2 /*return*/];
                    }
                });
            }); })
                .catch(function (err) {
                // eslint-disable-next-line no-console
                console.error(err);
                reject();
            });
        });
    };
    SpriteStore.prototype.spriteLocalTransform = function () {
        return {
            position: this.editor.previewToOutput(this.position),
            size: this.size,
            rotation: this.rotation,
        };
    };
    SpriteStore.prototype.clickableCanvas = function (isClickable) {
        this.editor.clickableCanvas(isClickable);
    };
    SpriteStore.prototype.setContainerProperties = function (identifier, properties, updatePositionAndSize) {
        if (updatePositionAndSize === void 0) { updatePositionAndSize = false; }
        // @ts-ignore TS2349
        this.container[identifier].setData(properties);
        if (updatePositionAndSize) {
            this.updatePositionAndSize();
        }
        this.editor.render();
    };
    SpriteStore.prototype.setContainerPosition = function (identifier, position) {
        this.container[identifier].setPosition(position);
    };
    /**
     * Removes the sprite from state and orderHelper
     * Without effects, ie rendering
     * @param id
     * @returns if the deletion was successful
     */
    SpriteStore.prototype.pureRemoveSprite = function (id) {
        this.editor.engine.removeContainer(this.container[id]);
        var index = this.container[id].getIndexInParent();
        if (index === -1) {
            delete this.container[id];
            this.state.delete(id);
            this.editor.orderHelper.removeSprite(id);
            return true;
        }
        return false;
    };
    /**
     * Delets the sprite regardless of which tool it is
     * @param id
     */
    SpriteStore.prototype.deleteSprite = function (id) {
        if (id === void 0) { id = this.id; }
        var sprite = this.state.get(id);
        if (sprite.tool === Tool.STICKER) {
            this.stickerToolStore.delete();
        }
        else if (sprite.tool === Tool.TEXT) {
            this.textToolStore.delete();
        }
        else if (sprite.tool === Tool.TEXT_DESIGN) {
            this.textDesignToolStore.delete();
        }
    };
    /**
     * Removes the sprite from state and orderHelper
     * With effects, ie rendering
     * @param id
     */
    SpriteStore.prototype.removeSprite = function (id) {
        var removed = this.pureRemoveSprite(id);
        if (removed) {
            this.selectLast();
            this.spriteSnapshot('delete');
            this.editor.render();
        }
    };
    /**
     * Whenever there are canvas controls involved,
     * the state for history (undo/redo) has to be relative to the canvas size,
     * because a user could change the screen size in the middle of the application
     * that's why the controls (position and size) and in turn the state (position and size state)
     * applied to the engine should be relative to the current canvasSize
     */
    SpriteStore.prototype.addSnapshot = function (type, desc) {
        var sprite = this.getSpriteState();
        var relativeTo = this.editor.canvasStore.sizeVector;
        var vector = relativeTo;
        Object.keys(sprite.common).forEach(function (id) {
            sprite.common[id].position = new Vector2(sprite.common[id].position).divide(vector);
            sprite.common[id].size = vectorToSize(Vector2.fromSize(sprite.common[id].size).divide(vector));
        });
        this.editor.addSnapshot({ sprite: sprite }, type, desc);
    };
    SpriteStore.prototype.spriteSnapshot = function (key) {
        this.addSnapshot("edit" /* EDIT */, this.historyLocale[key]);
    };
    /**
     * Whenever there are canvas controls involved,
     * the state for history (undo/redo) has to be relative to the canvas size,
     * because a user could change the screen size in the middle of the application
     * that's why the controls controls (position and size) and in turn the state (position and size state)
     * applied to the engine should be relative to the current canvasSize
     */
    SpriteStore.prototype.updateStateFromHistory = function (spriteHistoryState, relativeTo) {
        return __awaiter(this, void 0, void 0, function () {
            var existingIds, ids, deleted, added, id, spriteState, stickerState, textState, textDesignState, convertedSpriteState;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        existingIds = Object.keys(this.container);
                        ids = spriteHistoryState.spriteIdList;
                        if (!(ids.length !== existingIds.length)) return [3 /*break*/, 7];
                        deleted = existingIds.filter(function (e) { return ids.indexOf(e) === -1; });
                        added = ids.filter(function (e) { return existingIds.indexOf(e) === -1; });
                        if (deleted.length) {
                            this.pureRemoveSprite(deleted[0]);
                        }
                        if (!added.length) return [3 /*break*/, 6];
                        id = added[0];
                        spriteState = spriteHistoryState.common ? spriteHistoryState.common[id] : undefined;
                        stickerState = spriteHistoryState.sticker ? spriteHistoryState.sticker[id] : undefined;
                        textState = spriteHistoryState.text ? spriteHistoryState.text[id] : undefined;
                        textDesignState = spriteHistoryState.textdesign ? spriteHistoryState.textdesign[id] : undefined;
                        if (!spriteState) return [3 /*break*/, 6];
                        convertedSpriteState = {
                            spriteId: id,
                            transform: {
                                size: spriteState.size
                                    ? vectorToSize(Vector2.fromSize(spriteState.size).multiply(relativeTo))
                                    : undefined,
                                position: this.editor.previewToWorld(new Vector2(spriteState.position).multiply(relativeTo)),
                                rotation: spriteState.rotation,
                            },
                        };
                        if (!textState) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.addNewText(convertedSpriteState, textState)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 2:
                        if (!textDesignState) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.addNewTextDesign(convertedSpriteState, textDesignState)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 4:
                        if (!stickerState) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.addNewSticker(convertedSpriteState, stickerState)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        this.upateSpriteStateFromHistory(spriteHistoryState, relativeTo);
                        _a.label = 8;
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    SpriteStore.prototype.addNewText = function (spriteState, textState) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.textToolStore.doesTextAssetExist(textState.identifier)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.addTextAsync(__assign({}, spriteState, { state: textState }), false)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2: throw new Error("Text identifier " + textState.identifier + " doesn't exist");
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    SpriteStore.prototype.addNewTextDesign = function (spriteState, textDesignState) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.textDesignToolStore.doesTextDesignAssetExist(textDesignState.identifier)) {
                    this.addTextDesignAsync(__assign({}, spriteState, { state: textDesignState }), false);
                }
                else {
                    throw new Error("Text identifier " + textDesignState.identifier + " doesn't exist");
                }
                return [2 /*return*/];
            });
        });
    };
    SpriteStore.prototype.addNewSticker = function (spriteState, stickerState) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.stickerToolStore.doesStickerAssetExist(stickerState.identifier)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.addStickerAsync(__assign({}, spriteState, { state: stickerState }), false)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2: throw new Error("Text identifier " + stickerState.identifier + " doesn't exist");
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    SpriteStore.prototype.upateSpriteStateFromHistory = function (spriteHistoryState, relativeTo) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                Object.keys(this.container).forEach(function (id) {
                    var spriteState = spriteHistoryState.common ? spriteHistoryState.common[id] : undefined;
                    var stickerState = spriteHistoryState.sticker ? spriteHistoryState.sticker[id] : undefined;
                    var textState = spriteHistoryState.text ? spriteHistoryState.text[id] : undefined;
                    var textDesignState = spriteHistoryState.textdesign ? spriteHistoryState.textdesign[id] : undefined;
                    var spriteC = _this.state.get(id);
                    if (spriteC && spriteState) {
                        _this.state.set(id, spriteC);
                        var position = _this.editor.previewToWorld(new Vector2(spriteState.position).multiply(relativeTo));
                        _this.container[id].setPosition(position);
                        _this.container[id].setRotation(spriteState.rotation);
                        spriteC.rotation = _this.container[id].getRotation();
                        if (stickerState) {
                            var scale = SpriteStore.sizeMagnitude(vectorToSize(Vector2.fromSize(spriteState.size).multiply(relativeTo))) /
                                SpriteStore.sizeMagnitude(spriteState.defaultSize);
                            _this.container[id].setScale({ x: scale, y: scale });
                            _this.stickerToolStore.updateStateFromHistory(id, stickerState);
                        }
                        else if (textState) {
                            _this.textToolStore.updateStateFromHistory(id, __assign({}, textState, { fontIdentifier: textState.identifier }));
                        }
                        else if (textDesignState) {
                            _this.textDesignToolStore.updateStateFromHistory(id, __assign({}, textDesignState, { inverted: textDesignState.isInverted }));
                        }
                        _this.updatePositionAndSize(id);
                        if (textState) {
                            _this.setDefaultSize(id);
                        }
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    SpriteStore.prototype.getSpriteState = function () {
        var _a;
        var commonStates = toJS(this.state);
        var textState = toJS(this.textToolStore.state);
        var textDesignState = toJS(this.textDesignToolStore.state);
        return _a = {
                common: commonStates
            },
            _a[Tool.STICKER] = toJS(this.stickerToolStore.state),
            _a[Tool.TEXT] = textState,
            _a[Tool.TEXT_DESIGN] = textDesignState,
            _a.spriteIdList = Object.keys(this.container),
            _a;
    };
    SpriteStore.prototype.updateStateFromSerialization = function (state, customstickers) {
        return __awaiter(this, void 0, void 0, function () {
            var imagePromises, imageData_1, e_1, i, id, spriteState, stickerState, textState, textDesignState, size, zeroInPreview, sizeInPreview, _a, flipHorizontally, flipVertically, outputRotation, rotation, convertedSpriteState;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(customstickers && customstickers.length)) return [3 /*break*/, 4];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        imagePromises = customstickers.map(function (c) { return loadImage(c.raster.data, true); });
                        return [4 /*yield*/, Promise.all(imagePromises)];
                    case 2:
                        imageData_1 = _b.sent();
                        this.stickerToolStore.addCustomStickerAsset(customstickers.map(function (c, i) { return ({
                            image: imageData_1[i].image,
                            smallImage: imageData_1[i].smallImage,
                            name: c.name,
                            type: c.raster.type,
                            id: c.identifier,
                        }); }));
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _b.sent();
                        this.editor.modalStore.hideModal();
                        this.editor.modalStore.showActionModal({ identifier: 'stickerLoading' });
                        return [3 /*break*/, 4];
                    case 4:
                        i = 0;
                        _b.label = 5;
                    case 5:
                        if (!(i < state.spriteIdList.length)) return [3 /*break*/, 12];
                        id = state.spriteIdList[i];
                        spriteState = state.common ? state.common[id] : undefined;
                        stickerState = state.sticker ? state.sticker[id] : undefined;
                        textState = state.text ? state.text[id] : undefined;
                        textDesignState = state.textdesign ? state.textdesign[id] : undefined;
                        if (!spriteState) return [3 /*break*/, 11];
                        size = spriteState.size;
                        if (spriteState.size) {
                            zeroInPreview = this.editor.worldToPreview({ x: 0, y: 0 });
                            sizeInPreview = this.editor.worldToPreview({ x: spriteState.size.width, y: spriteState.size.height });
                            size = {
                                height: Math.abs(sizeInPreview.y - zeroInPreview.y),
                                width: Math.abs(sizeInPreview.x - zeroInPreview.x),
                            };
                        }
                        _a = this.editor.outputContainer.getData(), flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
                        outputRotation = this.editor.outputContainer.getRotation();
                        rotation = applyFlipToRotation({
                            rotation: spriteState.rotation + outputRotation,
                            flipHorizontally: flipHorizontally,
                            flipVertically: flipVertically,
                        });
                        convertedSpriteState = {
                            spriteId: id,
                            transform: {
                                size: size,
                                position: spriteState.position,
                                rotation: rotation,
                            },
                        };
                        if (!textState) return [3 /*break*/, 7];
                        // eslint-disable-next-line no-await-in-loop
                        return [4 /*yield*/, this.addNewText(convertedSpriteState, textState)];
                    case 6:
                        // eslint-disable-next-line no-await-in-loop
                        _b.sent();
                        return [3 /*break*/, 11];
                    case 7:
                        if (!textDesignState) return [3 /*break*/, 9];
                        // eslint-disable-next-line no-await-in-loop
                        return [4 /*yield*/, this.addNewTextDesign(convertedSpriteState, textDesignState)];
                    case 8:
                        // eslint-disable-next-line no-await-in-loop
                        _b.sent();
                        return [3 /*break*/, 11];
                    case 9:
                        if (!stickerState) return [3 /*break*/, 11];
                        // eslint-disable-next-line no-await-in-loop
                        return [4 /*yield*/, this.addNewSticker(convertedSpriteState, stickerState)];
                    case 10:
                        // eslint-disable-next-line no-await-in-loop
                        _b.sent();
                        _b.label = 11;
                    case 11:
                        i += 1;
                        return [3 /*break*/, 5];
                    case 12: return [2 /*return*/];
                }
            });
        });
    };
    Object.defineProperty(SpriteStore.prototype, "serializableState", {
        get: function () {
            var _this = this;
            var sprite = this.editor.spriteStore.getSpriteState();
            Object.keys(sprite.common).forEach(function (id) {
                sprite.common[id].size = _this.container[id].getSizeInWorldSpace();
                sprite.common[id].position = _this.container[id].getPosition();
                sprite.common[id].order = _this.container[id].getIndexInParent();
                var _a = _this.editor.outputContainer.getData(), flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
                var outputRotation = _this.editor.outputContainer.getRotation();
                sprite.common[id].rotation = applyFlipToRotation({
                    rotation: sprite.common[id].rotation - outputRotation,
                    flipHorizontally: flipHorizontally,
                    flipVertically: flipVertically,
                });
            });
            var ids = this.editor.spriteStore.stickerToolStore.customStickerIds;
            var customStickers = ids
                .map(function (_a) {
                var identifier = _a.identifier, type = _a.type;
                var sticker = _this.editor.spriteStore.stickerToolStore.entities.find(function (s) { return identifier === s.identifier; });
                if (sticker) {
                    var stickerAsset = _this.editor.assetProvider.getStickerAsset(sticker.identifier);
                    if (isStickerAssetDynamic(stickerAsset)) {
                        return {
                            identifier: identifier,
                            raster: {
                                type: type,
                                name: sticker.name,
                                data: stickerAsset.sticker,
                            },
                        };
                    }
                }
                return undefined;
            })
                .filter(Boolean);
            return {
                sprite: sprite,
                customStickers: customStickers,
            };
        },
        enumerable: true,
        configurable: true
    });
    SpriteStore.prototype.updateCanvasControls = function () {
        var _this = this;
        Object.keys(this.container).forEach(function (id) {
            _this.updatePositionAndSize(id, true);
            var sprite = _this.state.get(id);
            if (sprite) {
                if (sprite.tool === Tool.TEXT) {
                    var properties = _this.getContainerProperties(id);
                    _this.textToolStore.changeSize(id, properties);
                    _this.setDefaultSize(id);
                }
                else if (sprite.tool === Tool.TEXT_DESIGN) {
                    var properties = _this.getContainerProperties(id);
                    _this.textToolStore.changeWidth(properties.width);
                }
            }
        });
    };
    SpriteStore.prototype.setDragMode = function (mode) {
        this.dragMode.set(mode);
    };
    SpriteStore.prototype.setPosition = function (point) {
        var sprite = this.currentSprite;
        var selectedContainer = this.container[this.id];
        if (sprite && selectedContainer) {
            selectedContainer.setPosition(this.editor.previewToWorld(point));
            var position = this.getSizePositionFromContainer().position;
            sprite.position.x = position.x;
            sprite.position.y = position.y;
            this.state.set(this.id, sprite);
            this.editor.render();
        }
    };
    SpriteStore.prototype.setSize = function (size) {
        var sprite = this.currentSprite;
        if (sprite) {
            sprite.size.width = size.width;
            sprite.size.height = size.height;
            this.state.set(this.id, sprite);
        }
    };
    SpriteStore.prototype.setDefaultSize = function (id) {
        if (id === void 0) { id = this.id; }
        var sprite = this.state.get(id);
        if (sprite) {
            var defaultSize = this.getDefaultSize(id);
            sprite.defaultSize.width = defaultSize.width;
            sprite.defaultSize.height = defaultSize.height;
            this.state.set(id, sprite);
        }
    };
    SpriteStore.prototype.setRotation = function (rotation) {
        var sprite = this.currentSprite;
        if (sprite) {
            var _a = this.editor.outputContainer.getData(), flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
            var outputRotation = this.editor.outputContainer.getRotation();
            var flippedRotation = applyFlipToRotation({
                rotation: rotation + outputRotation,
                flipHorizontally: flipHorizontally,
                flipVertically: flipVertically,
            });
            this.container[this.id].setRotation(flippedRotation);
            sprite.rotation = this.container[this.id].getRotation();
            this.state.set(this.id, sprite);
            this.editor.render();
        }
    };
    SpriteStore.prototype.onCanvasClick = function (containerIds) {
        if (!this.isEditMode) {
            this.selectHighestOrderSprite(containerIds);
        }
    };
    SpriteStore.prototype.select = function (id) {
        var sprite = this.state.get(id);
        if (sprite) {
            var activeTool = this.editor.activeStore.tool;
            if (activeTool !== sprite.tool) {
                this.editor.activeStore.selectTool(sprite.tool);
            }
            this.selectedId.set(id);
        }
    };
    SpriteStore.prototype.selectLast = function () {
        var id = this.editor.orderHelper.getLastSpriteId();
        if (id) {
            this.select(id);
        }
    };
    SpriteStore.prototype.selectNext = function () {
        var _this = this;
        if (this.currentSprite) {
            var container = this.container[this.id];
            var order_1 = container.getIndexInParent();
            if (order_1) {
                var id = Object.keys(this.container).find(function (key) { return _this.container[key].getIndexInParent() === order_1 - 1; });
                if (id) {
                    this.select(id);
                }
            }
        }
    };
    SpriteStore.prototype.deselect = function () {
        this.selectedId.set(notSelectedId);
    };
    SpriteStore.prototype.bringToFront = function (id) {
        var order = this.editor.orderHelper.bringToFront(id);
        this.container[id].setIndexInParent(order);
        this.spriteSnapshot('order');
        this.editor.render();
    };
    SpriteStore.prototype.flipHorizontally = function (id) {
        var sticker = this.container[id];
        sticker.setFlipHorizontally(!sticker.getFlipHorizontally());
        this.spriteSnapshot('flip');
        this.editor.render();
    };
    SpriteStore.prototype.pureReset = function () {
        var _this = this;
        this.selectedId.set(notSelectedId);
        Array.from(this.state.keys()).forEach(function (id) {
            _this.pureRemoveSprite(id);
        });
        this.stickerToolStore.pureReset();
        this.textToolStore.pureReset();
        this.textDesignToolStore.pureReset();
    };
    SpriteStore.prototype.selectHighestOrderSprite = function (ids) {
        var _this = this;
        var drawingId = this.editor.brushToolStore.containerId();
        ids = ids.filter(function (i) { return i !== drawingId; });
        if (ids.length < 1) {
            this.deselect();
            return;
        }
        var idWithHighestOrder = '';
        var index = 0;
        ids.forEach(function (id) {
            var sprite = _this.container[id];
            var currentIndex = (sprite && sprite.getIndexInParent()) || 0;
            if (currentIndex >= index) {
                index = currentIndex;
                idWithHighestOrder = id;
            }
        });
        this.select(idWithHighestOrder);
    };
    SpriteStore.prototype.onCornerDrag = function (_a) {
        var x = _a.x, y = _a.y;
        if (this.currentSprite) {
            var position = new Vector2(this.currentSprite.position);
            var newPosition = new Vector2(x, y);
            var length_1 = newPosition.subtract(position).magnitude;
            var scale = (length_1 * 2) / this.defaultLength;
            if (length_1 > this.minLength) {
                if (this.isSpriteSticker) {
                    /**
                     * When the image is cropped, the preview has to be scaled to fit to the screen,
                     * defaultSize of sticker has to consider the scale change for resize calculation
                     * the scalefactor here is the relative to the change in previwscale before and after crop
                     */
                    var previewScale = this.editor.engineMediator.preview.container.getScale();
                    var defaultScale = this.editor.transformToolStore.defaultScale;
                    var scaleFactor = defaultScale / previewScale.x;
                    if (this.stickerToolStore.resizeMode !== 'unrestricted') {
                        this.setScaleInContainer({ x: scale * scaleFactor, y: scale * scaleFactor });
                    }
                    else {
                        var rotation = this.rotationWRTOutputRotation;
                        var _b = this.defaultSize, width = _b.width, height = _b.height;
                        var newPoint = newPosition.subtract(position);
                        var cos = Math.cos(rotation);
                        var sin = Math.sin(rotation);
                        var newWidth = Math.max(Math.abs(newPoint.x * cos * 2 + newPoint.y * sin * 2), this.minLength) * scaleFactor;
                        var newHeight = Math.max(Math.abs(newPoint.x * -sin * 2 + newPoint.y * cos * 2), this.minLength) * scaleFactor;
                        this.setScaleInContainer({ x: newWidth / width, y: newHeight / height });
                    }
                }
                else {
                    this.setFontSizeInContainer(scale);
                }
            }
            this.editor.render();
        }
    };
    Object.defineProperty(SpriteStore.prototype, "currentSprite", {
        get: function () {
            if (this.isSpriteSelected) {
                return this.state.get(this.id);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "padding", {
        get: function () {
            return this.textDesignToolStore.padding;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "isEditMode", {
        get: function () {
            return this.editMode.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "isDragMode", {
        get: function () {
            return this.dragMode.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "id", {
        get: function () {
            return this.selectedId.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "isSpriteSelected", {
        get: function () {
            return this.id !== notSelectedId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "position", {
        get: function () {
            if (this.currentSprite) {
                return this.currentSprite.position; // center position
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "tool", {
        get: function () {
            if (this.currentSprite) {
                return this.currentSprite.tool;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "size", {
        get: function () {
            if (this.currentSprite) {
                return this.currentSprite.size;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "rotation", {
        get: function () {
            if (this.currentSprite) {
                return this.currentSprite.rotation;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "rotationInQuadrant", {
        get: function () {
            var _a = this.editor.outputContainer.getData(), flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
            var outputRotation = this.editor.outputContainer.getRotation();
            if (this.currentSprite) {
                var rotation = applyFlipToRotation({
                    rotation: this.rotation + outputRotation,
                    flipHorizontally: flipHorizontally,
                    flipVertically: flipVertically,
                });
                var degrees = ((rotation * 180) / Math.PI + 360) % 360;
                var q1 = degrees >= 0 && degrees < 90;
                var q2 = degrees >= 90 && degrees < 180;
                var q3 = degrees >= 180 && degrees < 270;
                if (q1) {
                    return 'q1';
                }
                if (q2) {
                    return 'q2';
                }
                if (q3) {
                    return 'q3';
                }
                return 'q4';
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "rotationWRTOutputRotation", {
        get: function () {
            if (this.currentSprite) {
                var _a = this.editor.outputContainer.getData(), flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
                var outputRotation = this.editor.outputContainer.getRotation();
                return applyFlipToRotation({
                    rotation: this.currentSprite.rotation - outputRotation,
                    flipHorizontally: flipHorizontally,
                    flipVertically: flipVertically,
                });
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "flipHorizontal", {
        get: function () {
            if (this.currentSprite) {
                return this.currentSprite.flipHorizontally;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "defaultSize", {
        get: function () {
            if (this.currentSprite) {
                return this.currentSprite.defaultSize;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "defaultLength", {
        get: function () {
            if (this.currentSprite) {
                return SpriteStore.sizeMagnitude(this.currentSprite.defaultSize);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "isSpriteSticker", {
        get: function () {
            return this.tool === Tool.STICKER;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "isSpriteText", {
        get: function () {
            return this.tool === Tool.TEXT;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "isSpriteTextDesign", {
        get: function () {
            return this.tool === Tool.TEXT_DESIGN;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "spritePosition", {
        /** left top Position, without rotation */
        get: function () {
            if (this.currentSprite) {
                var _a = this.currentSprite.position, x = _a.x, y = _a.y;
                var _b = this.currentSprite.size, height = _b.height, width = _b.width;
                return {
                    x: RectStore.floor(x - width / 2),
                    y: RectStore.floor(y - height / 2),
                };
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "currentRect", {
        get: function () {
            if (this.currentSprite) {
                return this.rect;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "leftTopPosition", {
        get: function () {
            if (this.currentSprite) {
                return this.rect.leftTop;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "leftBottomPosition", {
        get: function () {
            if (this.currentSprite) {
                return this.rect.leftBottom;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "leftMidPosition", {
        get: function () {
            if (this.currentSprite) {
                return this.rect.leftMid;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "leftMidPadPosition", {
        get: function () {
            if (this.currentSprite) {
                var leftMid = this.rect.leftMid;
                return { x: leftMid.x - this.padding, y: leftMid.y };
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "rightTopPosition", {
        get: function () {
            if (this.currentSprite) {
                return this.rect.rightTop;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "rightBottomPosition", {
        get: function () {
            if (this.currentSprite) {
                return this.rect.rightBottom;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "rightMidPosition", {
        get: function () {
            if (this.currentSprite) {
                return this.rect.rightMid;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "rightMidPadPosition", {
        get: function () {
            if (this.currentSprite) {
                var rightMid = this.rect.rightMid;
                return { x: rightMid.x + this.padding, y: rightMid.y };
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "leftBottomHandlePosition", {
        get: function () {
            if (this.currentSprite) {
                return this.rect.leftBottomHandle;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "rightBottomHandlePosition", {
        get: function () {
            if (this.currentSprite) {
                return this.rect.rightBottomHandle;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "historyLocale", {
        get: function () {
            if (this.isSpriteSticker) {
                return this.stickerLocale;
            }
            if (this.isSpriteText) {
                return this.textDesignLocale;
            }
            return this.textLocale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "stickerLocale", {
        get: function () {
            return this.editor.configStore.locale[Tool.STICKER].history;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "textLocale", {
        get: function () {
            return this.editor.configStore.locale[Tool.TEXT].history;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpriteStore.prototype, "textDesignLocale", {
        get: function () {
            return this.editor.configStore.locale[Tool.TEXT_DESIGN].history;
        },
        enumerable: true,
        configurable: true
    });
    SpriteStore.prototype.getOutputProperties = function () {
        return this.editor.outputContainer.getData();
    };
    SpriteStore.prototype.getContainerProperties = function (identifier) {
        return this.container[identifier].getData();
    };
    SpriteStore.prototype.getContainerTransform = function (identifier) {
        return this.container[identifier].getTransform();
    };
    SpriteStore.prototype.getDuplicateContainerTransform = function (identifier) {
        var transform = this.container[identifier].getTransform();
        var size = this.editor.shortestOutputSide * 0.1;
        var position = new Vector2(transform.position).add(new Vector2(size, size));
        return __assign({}, transform, { position: position });
    };
    SpriteStore.prototype.getDuplicateContainerFlip = function (identifier) {
        return this.container[identifier].getFlipHorizontally();
    };
    SpriteStore.prototype.getTransform = function (transform) {
        var position = this.editor.outputToWorld(defaultLocalTransform.position);
        if (!transform) {
            var outputRotation = this.editor.outputContainer.getRotation();
            return { rotation: outputRotation, position: position };
        }
        return __assign({ position: position }, transform);
    };
    SpriteStore.prototype.setInitialSpriteState = function (id, tool, defaultSize) {
        if (defaultSize === void 0) { defaultSize = { height: 0, width: 0 }; }
        var selectedContainer = this.container[id];
        var _a = this.getSizePositionFromContainer(id), position = _a.position, size = _a.size;
        var rotation = selectedContainer.getRotation();
        this.state.set(id, {
            tool: tool,
            position: position,
            rotation: rotation,
            size: size,
            defaultSize: defaultSize,
            flipHorizontally: false,
        });
    };
    SpriteStore.prototype.setScaleInContainer = function (scale) {
        var selectedContainer = this.container[this.id];
        selectedContainer.setScale(scale);
        var sprite = this.currentSprite;
        if (sprite) {
            var size = this.getSizePositionFromContainer().size;
            sprite.size = size;
            this.state.set(this.id, sprite);
        }
    };
    SpriteStore.prototype.setFontSizeInContainer = function (scale) {
        var sprite = this.currentSprite;
        var selectedText = this.textToolStore.currentText;
        var selectedTextDesign = this.textDesignToolStore.currentTextDesign;
        if (sprite) {
            if (selectedText) {
                var newSize = { fontSize: Math.floor(this.textToolStore.defaultFontSize * scale) };
                var newWidth = { width: this.editor.previewToWorld(this.defaultSize.width * scale) };
                var data = this.isSpriteText ? __assign({}, newWidth, newSize) : newWidth;
                if (newWidth.width > this.minLength && newSize.fontSize) {
                    this.setContainerProperties(this.id, data, true);
                    var _a = this.getContainerProperties(this.id), fontSize = _a.fontSize, width = _a.width;
                    this.textToolStore.changeFontSize(fontSize, true);
                    this.textToolStore.changeWidth(width);
                }
            }
            else if (selectedTextDesign) {
                var width = this.editor.previewToWorld(this.defaultSize.width * scale);
                if (width > this.minLength) {
                    this.setContainerProperties(this.id, { width: width }, true);
                    var widthFromContainer = this.getContainerProperties(this.id).width;
                    this.textDesignToolStore.changeWidth(widthFromContainer);
                }
            }
        }
    };
    SpriteStore.prototype.getSizePositionFromContainer = function (id) {
        if (id === void 0) { id = this.id; }
        var selectedContainer = this.container[id];
        if (selectedContainer) {
            var position = this.editor.worldToPreview(selectedContainer.getPosition());
            var sizeInWorldSpace = selectedContainer.getSizeInWorldSpace();
            var size = {
                width: Math.floor(this.editor.worldToPreview(sizeInWorldSpace.width)),
                height: Math.floor(this.editor.worldToPreview(sizeInWorldSpace.height)),
            };
            return { position: position, size: size };
        }
        return {
            position: { x: 0, y: 0 },
            size: { height: 1, width: 1 },
        };
    };
    __decorate([
        action
    ], SpriteStore.prototype, "addSticker", null);
    __decorate([
        action
    ], SpriteStore.prototype, "addStickerAsync", null);
    __decorate([
        action
    ], SpriteStore.prototype, "addText", null);
    __decorate([
        action
    ], SpriteStore.prototype, "addTextAsync", null);
    __decorate([
        action
    ], SpriteStore.prototype, "addTextDesign", null);
    __decorate([
        action
    ], SpriteStore.prototype, "addTextDesignAsync", null);
    __decorate([
        action
    ], SpriteStore.prototype, "clickableCanvas", null);
    __decorate([
        action
    ], SpriteStore.prototype, "setContainerProperties", null);
    __decorate([
        action
    ], SpriteStore.prototype, "setContainerPosition", null);
    __decorate([
        action
    ], SpriteStore.prototype, "pureRemoveSprite", null);
    __decorate([
        action
    ], SpriteStore.prototype, "deleteSprite", null);
    __decorate([
        action
    ], SpriteStore.prototype, "removeSprite", null);
    __decorate([
        action
    ], SpriteStore.prototype, "addSnapshot", null);
    __decorate([
        action
    ], SpriteStore.prototype, "updateStateFromHistory", null);
    __decorate([
        action
    ], SpriteStore.prototype, "addNewText", null);
    __decorate([
        action
    ], SpriteStore.prototype, "addNewTextDesign", null);
    __decorate([
        action
    ], SpriteStore.prototype, "addNewSticker", null);
    __decorate([
        action
    ], SpriteStore.prototype, "upateSpriteStateFromHistory", null);
    __decorate([
        action
    ], SpriteStore.prototype, "updateStateFromSerialization", null);
    __decorate([
        action
    ], SpriteStore.prototype, "updateCanvasControls", null);
    __decorate([
        action
    ], SpriteStore.prototype, "setEditMode", void 0);
    __decorate([
        action
    ], SpriteStore.prototype, "setDragMode", null);
    __decorate([
        action
    ], SpriteStore.prototype, "setPosition", null);
    __decorate([
        action
    ], SpriteStore.prototype, "setSize", null);
    __decorate([
        action
    ], SpriteStore.prototype, "setDefaultSize", null);
    __decorate([
        action
    ], SpriteStore.prototype, "setRotation", null);
    __decorate([
        action
    ], SpriteStore.prototype, "onCanvasClick", null);
    __decorate([
        action
    ], SpriteStore.prototype, "select", null);
    __decorate([
        action
    ], SpriteStore.prototype, "selectLast", null);
    __decorate([
        action
    ], SpriteStore.prototype, "selectNext", null);
    __decorate([
        action
    ], SpriteStore.prototype, "deselect", null);
    __decorate([
        action
    ], SpriteStore.prototype, "bringToFront", null);
    __decorate([
        action
    ], SpriteStore.prototype, "flipHorizontally", null);
    __decorate([
        action
    ], SpriteStore.prototype, "pureReset", null);
    __decorate([
        action
    ], SpriteStore.prototype, "onCornerDrag", null);
    __decorate([
        action
    ], SpriteStore.prototype, "onWidthDrag", void 0);
    __decorate([
        action
    ], SpriteStore.prototype, "onPaddingDrag", void 0);
    __decorate([
        action
    ], SpriteStore.prototype, "reverseTextHorizontally", void 0);
    __decorate([
        action
    ], SpriteStore.prototype, "reverseTextVertically", void 0);
    __decorate([
        computed
    ], SpriteStore.prototype, "currentSprite", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "padding", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "isEditMode", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "isDragMode", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "id", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "isSpriteSelected", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "position", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "tool", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "size", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "rotation", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "rotationInQuadrant", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "rotationWRTOutputRotation", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "flipHorizontal", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "defaultSize", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "defaultLength", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "isSpriteSticker", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "isSpriteText", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "isSpriteTextDesign", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "spritePosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "currentRect", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "leftTopPosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "leftBottomPosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "leftMidPosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "leftMidPadPosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "rightTopPosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "rightBottomPosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "rightMidPosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "rightMidPadPosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "leftBottomHandlePosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "rightBottomHandlePosition", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "historyLocale", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "stickerLocale", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "textLocale", null);
    __decorate([
        computed
    ], SpriteStore.prototype, "textDesignLocale", null);
    return SpriteStore;
}());

var initialState$5 = {
    options: [],
    query: '',
};
var LibraryStore = /** @class */ (function () {
    function LibraryStore(editor) {
        var _this = this;
        this.initProvider = function (Provider) {
            if (Provider) {
                // @ts-ignore TS2351
                _this.libraryProvider = new Provider();
            }
        };
        this.addOptionsToSelectedCategory = function (categories, selectedCategory, options) {
            var index = categories.findIndex(function (category) { return category.identifier === selectedCategory; });
            if (index !== -1) {
                return __spread(categories.slice(0, index + 1), options, categories.slice(index + 1));
            }
            return categories;
        };
        this.configStore = editor.configStore;
        this.state = observable(initialState$5);
        this.selectedCategory = '';
    }
    LibraryStore.prototype.saveScrollbar = function (simpleBar) {
        this.scrollbar = simpleBar;
    };
    LibraryStore.prototype.recalculateScrollContainer = function () {
        var _this = this;
        setTimeout(function () { return _this.scrollbar.recalculate(); }, 0);
    };
    LibraryStore.prototype.fetchImages = function (query) {
        if (query === void 0) { query = ''; }
        return __awaiter(this, void 0, void 0, function () {
            var promises, _a, imageCategories, images_1, options_1;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.libraryProvider) return [3 /*break*/, 2];
                        promises = [this.libraryProvider.getCategories(), this.libraryProvider.searchImages(query)];
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _a = __read.apply(void 0, [_b.sent(), 2]), imageCategories = _a[0], images_1 = _a[1];
                        options_1 = imageCategories
                            .map(function (category) {
                            var imgs = images_1.filter(function (image) { return image.category === category.name; });
                            return {
                                identifier: category.name,
                                defaultName: category.name,
                                coverImage: category.coverImageUrl,
                                options: imgs.map(function (image, index) { return ({
                                    defaultName: "image" + index,
                                    identifier: image.thumbUrl,
                                    coverImage: image.thumbUrl,
                                    rawUrl: image.rawUrl,
                                }); }),
                            };
                        })
                            .filter(function (category) { return category.options.length; });
                        runInAction(function () {
                            _this.state.query = query;
                            _this.state.options = options_1;
                        });
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    LibraryStore.prototype.toggleCategorySelection = function (identifier) {
        this.selectedCategory = this.selectedCategory !== identifier ? identifier : '';
    };
    Object.defineProperty(LibraryStore.prototype, "selectedCategoryIdentifier", {
        get: function () {
            return this.selectedCategory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibraryStore.prototype, "images", {
        get: function () {
            return this.state.options
                .map(function (category) { return category.options; })
                .reduce(function (acc, category) { return __spread(acc, category); }, []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibraryStore.prototype, "query", {
        get: function () {
            return this.state.query;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibraryStore.prototype, "config", {
        get: function () {
            return this.configStore.config[Tool.LIBRARY];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibraryStore.prototype, "locale", {
        get: function () {
            return this.configStore.locale[Tool.LIBRARY];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibraryStore.prototype, "categories", {
        get: function () {
            return this.state.options.map(function (category, index) { return ({
                type: CardType.LARGE,
                identifier: category.defaultName,
                defaultName: category.defaultName,
                coverImage: category.coverImage,
                delay: index * 0.08,
                items: category.options.map(function (item, itemIndex) { return (__assign({ type: CardType.MEDIUM, delay: itemIndex * 0.08 }, item)); }),
            }); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibraryStore.prototype, "options", {
        get: function () {
            var selectedCategory = this.selectedCategory;
            var index = this.state.options.findIndex(function (category) { return category.defaultName === selectedCategory; });
            return index !== -1
                ? this.state.options[index].options.map(function (option, optionIndex) { return (__assign({ type: CardType.MEDIUM, delay: optionIndex * 0.08 }, option)); })
                : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LibraryStore.prototype, "categoriesAndOptions", {
        get: function () {
            return this.addOptionsToSelectedCategory(this.categories, this.selectedCategory, this.options);
        },
        enumerable: true,
        configurable: true
    });
    LibraryStore.prototype.getRawUrl = function (url) {
        var imageIndex = this.images.findIndex(function (image) { return image.identifier === url; });
        if (imageIndex !== -1) {
            return this.images[imageIndex].rawUrl;
        }
        return url;
    };
    __decorate([
        observable
    ], LibraryStore.prototype, "selectedCategory", void 0);
    __decorate([
        action
    ], LibraryStore.prototype, "saveScrollbar", null);
    __decorate([
        action
    ], LibraryStore.prototype, "recalculateScrollContainer", null);
    __decorate([
        action
    ], LibraryStore.prototype, "initProvider", void 0);
    __decorate([
        action
    ], LibraryStore.prototype, "fetchImages", null);
    __decorate([
        action
    ], LibraryStore.prototype, "toggleCategorySelection", null);
    __decorate([
        computed
    ], LibraryStore.prototype, "selectedCategoryIdentifier", null);
    __decorate([
        computed
    ], LibraryStore.prototype, "images", null);
    __decorate([
        computed
    ], LibraryStore.prototype, "query", null);
    __decorate([
        computed
    ], LibraryStore.prototype, "config", null);
    __decorate([
        computed
    ], LibraryStore.prototype, "locale", null);
    __decorate([
        computed
    ], LibraryStore.prototype, "categories", null);
    __decorate([
        computed
    ], LibraryStore.prototype, "options", null);
    __decorate([
        computed
    ], LibraryStore.prototype, "categoriesAndOptions", null);
    return LibraryStore;
}());

var Edges;
(function (Edges) {
    Edges["LEADING"] = "leading";
    Edges["CENTER"] = "center";
    Edges["TRAILING"] = "trailing";
})(Edges || (Edges = {}));
var initialState$6 = {
    horizontalGuides: [],
    verticalGuides: [],
    rotationGuides: [],
};
var SnappingStore = /** @class */ (function () {
    function SnappingStore(editor) {
        var _this = this;
        this.previewTopLeftPosition = { x: 0, y: 0 };
        /**
         * Get the current value of the guide
         */
        this.getGuideValue = function (direction, name) {
            var _a = _this.editor.getPreviewSize(), previewHeight = _a.height, previewWidth = _a.width;
            var _b = _this.configStore.config.snapping.position, snapToLeft = _b.snapToLeft, snapToRight = _b.snapToRight, snapToTop = _b.snapToTop, snapToBottom = _b.snapToBottom;
            // the values are all based on the smallest side of the preview
            var smallestSide = Math.min(previewHeight, previewWidth);
            var value = 0;
            if (name === 'bottom') {
                value = Math.round(previewHeight - smallestSide * snapToBottom);
            }
            else if (name === 'top') {
                value = Math.round(smallestSide * snapToTop);
            }
            else if (name === 'right') {
                value = Math.round(previewWidth - smallestSide * snapToRight);
            }
            else if (name === 'left') {
                value = Math.round(smallestSide * snapToLeft);
            }
            else if (direction === 'vertical' && name === 'center') {
                value = Math.round(previewWidth / 2);
            }
            else if (direction === 'horizontal' && name === 'center') {
                value = Math.round(previewHeight / 2);
            }
            return value;
        };
        /**
         * Only show the guides which are specified in the position config
         */
        this.getVerticalGuidesFromConfig = function () {
            var _a = _this.configStore.config.snapping.position, snapToVerticalCenter = _a.snapToVerticalCenter, snapToLeft = _a.snapToLeft, snapToRight = _a.snapToRight;
            var verticalGuides = [];
            if (snapToVerticalCenter) {
                verticalGuides.push({
                    value: _this.getGuideValue('vertical', 'center'),
                    edge: Edges.CENTER,
                    isVisible: false,
                    direction: 'vertical',
                });
            }
            if (snapToLeft) {
                verticalGuides.push({
                    value: _this.getGuideValue('vertical', 'left'),
                    edge: Edges.LEADING,
                    isVisible: false,
                    direction: 'vertical',
                });
            }
            if (snapToRight) {
                verticalGuides.push({
                    value: _this.getGuideValue('vertical', 'right'),
                    edge: Edges.TRAILING,
                    isVisible: false,
                    direction: 'vertical',
                });
            }
            return verticalGuides;
        };
        /**
         * Only show the guides which are specified in the position config
         */
        this.getHorizontalGuidesFromConfig = function () {
            var _a = _this.configStore.config.snapping.position, snapToHorizontalCenter = _a.snapToHorizontalCenter, snapToTop = _a.snapToTop, snapToBottom = _a.snapToBottom;
            var horizontalGuides = [];
            if (snapToHorizontalCenter) {
                horizontalGuides.push({
                    value: _this.getGuideValue('horizontal', 'center'),
                    edge: Edges.CENTER,
                    isVisible: false,
                    direction: 'horizontal',
                });
            }
            if (snapToTop) {
                horizontalGuides.push({
                    value: _this.getGuideValue('horizontal', 'top'),
                    edge: Edges.LEADING,
                    isVisible: false,
                    direction: 'horizontal',
                });
            }
            if (snapToBottom) {
                horizontalGuides.push({
                    value: _this.getGuideValue('horizontal', 'bottom'),
                    edge: Edges.TRAILING,
                    isVisible: false,
                    direction: 'horizontal',
                });
            }
            return horizontalGuides;
        };
        /**
         * Only show the guides which are specified in the rotation config
         */
        this.getRotationGuidesFromConfig = function () {
            var angles = _this.configStore.config.snapping.rotation.angles;
            var correctedAngles = [];
            angles.forEach(function (angle) {
                correctedAngles.push(angle);
                correctedAngles.push(angle + 360);
                correctedAngles.push(angle - 360);
            });
            var uniqueAngles = correctedAngles.filter(function (item, pos) { return correctedAngles.indexOf(item) === pos; });
            return uniqueAngles.map(function (angle) { return ({
                value: (angle * Math.PI) / 180,
                edge: Edges.CENTER,
                isVisible: false,
                position: { x: 0, y: 0 },
            }); });
        };
        /**
         * This function will return the necessary values for all four corners taking the rotation into account.
         */
        this.getSpriteDimensions = function (_a) {
            var leftTop = _a.leftTop, leftBottom = _a.leftBottom, rightTop = _a.rightTop, rightBottom = _a.rightBottom;
            var minY = Math.min(leftTop.y, rightTop.y, leftBottom.y, rightBottom.y);
            var maxY = Math.max(leftTop.y, rightTop.y, leftBottom.y, rightBottom.y);
            var minX = Math.min(leftTop.x, rightTop.x, leftBottom.x, rightBottom.x);
            var maxX = Math.max(leftTop.x, rightTop.x, leftBottom.x, rightBottom.x);
            return {
                height: Math.round(maxY - minY),
                width: Math.round(maxX - minX),
            };
        };
        /**
         * Maps a value from a given source range to another target range
         */
        this.mapRange = function (_a) {
            var value = _a.value, fromMin = _a.fromMin, fromLength = _a.fromLength, toMin = _a.toMin, toLength = _a.toLength;
            return ((value - fromMin) * toLength) / fromLength + toMin;
        };
        /**
         * Update the guide positions on resize
         */
        this.updateGuides = function () {
            _this.state.horizontalGuides = _this.getHorizontalGuidesFromConfig();
            _this.state.verticalGuides = _this.getVerticalGuidesFromConfig();
        };
        /**
         * Maps the specified `value` to a new value that is potentially
         * snapped to one of the given `sortedSnapPoints`.
         *
         * @param {Number} value - The value to be potentially snapped to one of the snap points
         * @param {Number[]} sortedSnapPoints - A sorted array of numbers which `value` can snap to
         * @param {Number} threshold - The maximum distance to a snap point required for
         *                             value to be snapped to that point
         * @param {Boolean} extendedRange - Use true for snapping position, false for snapping rotation
         * @returns {Number}
         */
        this.mapToSnapSystem = function (value, sortedSnapPoints, threshold, extendedRange) {
            if (sortedSnapPoints.length === 0) {
                return value;
            }
            if (sortedSnapPoints[0] > value) {
                return value - threshold;
            }
            for (var i = 0; i < sortedSnapPoints.length - 1; i += 1) {
                var inMin = sortedSnapPoints[i];
                var inMax = sortedSnapPoints[i + 1];
                var outMin = inMin + threshold;
                var outMax = inMax - threshold;
                var offset = 0;
                if (extendedRange) {
                    offset = i * threshold * 2;
                    outMin += offset;
                    outMax += offset + threshold * 2;
                }
                var epsilon = 0.00001;
                if (inMin <= value && value <= inMax) {
                    if (value <= inMin + epsilon) {
                        return inMin + offset;
                    }
                    if (value >= inMax - epsilon) {
                        return inMax + offset + (extendedRange ? threshold * 2 : 0);
                    }
                    return _this.mapRange({
                        value: value,
                        fromMin: inMin,
                        fromLength: inMax - inMin,
                        toMin: outMin,
                        toLength: outMax - outMin,
                    });
                }
            }
            if (extendedRange) {
                return value + (sortedSnapPoints.length - 1) * threshold * 2 + threshold;
            }
            return value;
        };
        /**
         * The inverse of the @see {@link mapToSnapSystem} function.
         * This mapping is not continuous.
         *
         * @param {Number} value - The "snapped" value to be remapped into the input space
         * @param {Number[]} sortedSnapPoints - A sorted array of numbers which `value` could be snapped to
         * @param {Number} threshold - The maximum distance to a snap point required for an input value
         *                             to be snapped to that point.
         * @param {Boolean} extendedRange - Use true for snapping position, false for snapping rotation
         * @returns {Number}
         */
        this.mapFromSnapSystem = function (value, sortedSnapPoints, threshold, extendedRange) {
            if (sortedSnapPoints.length === 0) {
                return value;
            }
            if (sortedSnapPoints[0] > value) {
                if (value >= sortedSnapPoints[0] - threshold) {
                    return sortedSnapPoints[0];
                }
                return value + threshold;
            }
            var valueWithOffset = value;
            for (var i = 0; i < sortedSnapPoints.length - 1; i += 1) {
                var outMin = sortedSnapPoints[i];
                var outMax = sortedSnapPoints[i + 1];
                var inMin = outMin + threshold;
                var inMax = outMax - threshold;
                var rangeMax = outMax;
                if (extendedRange) {
                    inMax += threshold * 2;
                    rangeMax += threshold * 2;
                    valueWithOffset = value - i * threshold * 2;
                }
                if (outMin <= valueWithOffset && valueWithOffset <= rangeMax) {
                    if (inMin <= valueWithOffset && valueWithOffset <= inMax) {
                        return _this.mapRange({
                            value: valueWithOffset,
                            fromMin: inMin,
                            fromLength: inMax - inMin,
                            toMin: outMin,
                            toLength: outMax - outMin,
                        });
                    }
                    if (valueWithOffset < inMin) {
                        return outMin;
                    } // valueWithOffset > inMax
                    return outMax;
                }
            }
            valueWithOffset -= threshold * 3;
            var lastSnapPoint = sortedSnapPoints[sortedSnapPoints.length - 1];
            if (valueWithOffset <= lastSnapPoint) {
                return lastSnapPoint;
            }
            return valueWithOffset;
        };
        this.centerSnapValue = function (guide, itemWidth) {
            var halfWidth = itemWidth * 0.5;
            var value = guide.value, edge = guide.edge;
            var centerSnapValue = value;
            if (edge === Edges.LEADING) {
                centerSnapValue += halfWidth;
            }
            else if (edge === Edges.TRAILING) {
                centerSnapValue -= halfWidth;
            }
            return centerSnapValue;
        };
        /**
         * Converts all given general SnappingGuides to guides relative to the
         * item center.
         * @param {Guide[]} guides - The guides that any item edge can snap to
         * @param {Number} itemWidth - The distance between the leading and trailing edge of the item to be snapped
         * @returns {number[]} - Guides that the item center should snap to
         */
        this.mapSnappingGuidesToCenter = function (guides, itemWidth) {
            var centerGuides = [];
            guides.forEach(function (guide) {
                centerGuides.push(_this.centerSnapValue(guide, itemWidth));
            });
            return centerGuides;
        };
        /**
         * Converts a rotational snap threshold given in pixels to the
         * an approximated threshold in radians
         * @param {Number} radiusInPixel - The distance between the cursor position and the item center
         * @param {Number} snapThresholdInPixel - The snapping threshold in pixels
         * @returns {Number} - The snapping threshold in pixels
         */
        this.calcSnapThresholdInRadians = function (radiusInPixel, snapThresholdInPixel) {
            if (radiusInPixel === 0) {
                return 0;
            }
            return snapThresholdInPixel / radiusInPixel;
        };
        /**
         * Calculating preview top-left, everytime preview is updated
         * This position is being used as left and top offset for the snapping guides
         */
        this.calculatePreviewTopLeftPosition = function () {
            var center = _this.editor.engineMediator.preview.container.getPosition();
            var size = _this.editor.getPreviewSize();
            var dpr = Editor.devicePixelRatio;
            _this.previewTopLeftPosition = {
                x: center.x / dpr - size.width / 2,
                y: center.y / dpr - size.height / 2,
            };
        };
        this.snapToRotation = function (rotation, distance, rect) {
            var rotationGuides = _this.state.rotationGuides;
            var _a = _this.configStore.config.snapping.rotation, enabled = _a.enabled, threshold = _a.threshold;
            var _b = _this.previewTopLeftPosition, leftOffset = _b.x, topOffset = _b.y;
            var previewWidth = _this.editor.getPreviewSize().width;
            // will return an angle in radians between 0 and 2 * PI
            var radians = (rotation + Math.PI * 2) % (Math.PI * 2);
            if (enabled) {
                var dragRadius = new Vector2(distance).magnitude;
                var radiansSnapAngles = rotationGuides.map(function (guide) { return guide.value; }).sort(function (a, b) { return a - b; });
                var radiansThreshold = _this.calcSnapThresholdInRadians(dragRadius, threshold);
                if (!_this.rotationOffset) {
                    var offsetRotation = _this.mapToSnapSystem(rotation, radiansSnapAngles, radiansThreshold, false);
                    _this.rotationOffset = offsetRotation - radians;
                }
                radians = _this.mapFromSnapSystem(radians + _this.rotationOffset, radiansSnapAngles, radiansThreshold, false);
                var guidePosition_1 = {
                    // - previewWidth because the guides are 200% in width
                    x: rect.position.x - leftOffset - previewWidth,
                    y: rect.position.y - topOffset,
                };
                rotationGuides.forEach(function (guide) {
                    guide.isVisible = guide.value === radians;
                    guide.position = guidePosition_1;
                });
                return radians;
            }
            return rotation;
        };
        this.snapToPosition = function (newPos, rect) {
            var _a = _this.state, horizontalGuides = _a.horizontalGuides, verticalGuides = _a.verticalGuides;
            var _b = _this.configStore.config.snapping.position, enabled = _b.enabled, threshold = _b.threshold;
            var defaultPosition = new Vector2(_this.previewTopLeftPosition);
            var _c = _this.getSpriteDimensions(rect), height = _c.height, width = _c.width;
            var _d = new Vector2(newPos).subtract(defaultPosition), x = _d.x, y = _d.y;
            if (enabled) {
                var horizontalSnappingPoints = _this.mapSnappingGuidesToCenter(horizontalGuides, height).sort(function (a, b) { return a - b; });
                var verticalSnappingPoints = _this.mapSnappingGuidesToCenter(verticalGuides, width).sort(function (a, b) { return a - b; });
                if (!_this.positionOffset) {
                    var offsetX = _this.mapToSnapSystem(x, verticalSnappingPoints, threshold, true);
                    var offsetY = _this.mapToSnapSystem(y, horizontalSnappingPoints, threshold, true);
                    _this.positionOffset = new Vector2(offsetX, offsetY).subtract(new Vector2(x, y));
                }
                // we have to remove the offset here, so that the snapping is based on the preview space
                // and not the whole canvas area
                var snappedX_1 = _this.mapFromSnapSystem(x + _this.positionOffset.x, verticalSnappingPoints, threshold, true);
                var snappedY_1 = _this.mapFromSnapSystem(y + _this.positionOffset.y, horizontalSnappingPoints, threshold, true);
                snappedX_1 = Math.round(snappedX_1);
                snappedY_1 = Math.round(snappedY_1);
                horizontalGuides.forEach(function (guide) {
                    var snapValue = Math.round(_this.centerSnapValue(guide, height));
                    guide.isVisible = snapValue === snappedY_1;
                });
                verticalGuides.forEach(function (guide) {
                    var snapValue = Math.round(_this.centerSnapValue(guide, width));
                    guide.isVisible = snapValue === snappedX_1;
                });
                return new Vector2(snappedX_1, snappedY_1).add(defaultPosition);
            }
            return { x: x, y: y };
        };
        this.editor = editor;
        this.configStore = editor.configStore;
        this.state = observable(initialState$6);
        this.rotationOffset = null;
        this.positionOffset = null;
        this.state.horizontalGuides = this.getHorizontalGuidesFromConfig();
        this.state.verticalGuides = this.getVerticalGuidesFromConfig();
        this.state.rotationGuides = this.getRotationGuidesFromConfig();
    }
    SnappingStore.prototype.hidePositionGuides = function () {
        this.positionOffset = null;
        this.state.verticalGuides = this.state.verticalGuides.map(function (guide) { return (__assign({}, guide, { isVisible: false })); });
        this.state.horizontalGuides = this.state.horizontalGuides.map(function (guide) { return (__assign({}, guide, { isVisible: false })); });
    };
    SnappingStore.prototype.hideRotationGuides = function () {
        this.rotationOffset = null;
        this.state.rotationGuides = this.state.rotationGuides.map(function (guide) { return (__assign({}, guide, { isVisible: false })); });
    };
    Object.defineProperty(SnappingStore.prototype, "positionGuides", {
        get: function () {
            var _a = this.state, verticalGuides = _a.verticalGuides, horizontalGuides = _a.horizontalGuides;
            return __spread(verticalGuides, horizontalGuides);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SnappingStore.prototype, "rotationGuides", {
        get: function () {
            return this.state.rotationGuides;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        observable
    ], SnappingStore.prototype, "state", void 0);
    __decorate([
        action
    ], SnappingStore.prototype, "snapToRotation", void 0);
    __decorate([
        action
    ], SnappingStore.prototype, "snapToPosition", void 0);
    __decorate([
        action
    ], SnappingStore.prototype, "hidePositionGuides", null);
    __decorate([
        action
    ], SnappingStore.prototype, "hideRotationGuides", null);
    __decorate([
        computed
    ], SnappingStore.prototype, "positionGuides", null);
    __decorate([
        computed
    ], SnappingStore.prototype, "rotationGuides", null);
    return SnappingStore;
}());

/**
 * Mediator class between Serialization and Editor
 * Takes care of getting the state while serializing and sending it back to all the toolStores while deserilaizing
 */
var SerializationMediator = /** @class */ (function () {
    function SerializationMediator(editor) {
        this.editor = editor;
    }
    SerializationMediator.prototype.serialize = function (_a) {
        var _this = this;
        var image = (_a === void 0 ? { image: false } : _a).image;
        this.editor.modalStore.showInfoModal('saving');
        return new Promise(function (resolve, reject) {
            import('./index-1c1dd652.js').then(function (_a) {
                var Serializer = _a.Serializer;
                return __awaiter(_this, void 0, void 0, function () {
                    var _b, transformedImageSize, untransformedImageSize, serialization, state, _c, sprite_1, customStickers, imageData, e_1;
                    return __generator(this, function (_d) {
                        switch (_d.label) {
                            case 0:
                                _d.trys.push([0, 3, , 4]);
                                this.editor.transformToolStore.applyDefaultCrop(false);
                                transformedImageSize = this.editor.engineMediator.output.container.getResolution();
                                untransformedImageSize = this.editor.engineMediator.image.container.getBounds().size;
                                serialization = new Serializer(this.editor.transformToolStore.defaultCropMaskPosition, this.editor.transformToolStore.defaultCropMaskSize, transformedImageSize, untransformedImageSize);
                                state = (_b = {},
                                    _b[Tool.ADJUSTMENT] = toJS(this.editor.adjustmentsToolStore.state),
                                    _b[Tool.FILTER] = toJS(this.editor.filterToolStore.state),
                                    _b[Tool.FOCUS] = toJS(this.editor.focusToolStore.serializableState),
                                    _b[Tool.OVERLAY] = toJS(this.editor.overlayToolStore.state),
                                    _b[Tool.FRAME] = toJS(this.editor.frameToolStore.state),
                                    _b[Tool.BRUSH] = (this.editor.brushToolStore.strokes || { strokes: [] }),
                                    _b);
                                _c = this.editor.spriteStore.serializableState, sprite_1 = _c.sprite, customStickers = _c.customStickers;
                                sprite_1.spriteIdList = sprite_1.spriteIdList.sort(function (firstElId, secondElId) {
                                    var firstElOrder = sprite_1.common[firstElId].order;
                                    var secondElOrder = sprite_1.common[secondElId].order;
                                    return firstElOrder - secondElOrder;
                                });
                                state.sprite = sprite_1;
                                state.customStickers = customStickers;
                                state.transform = this.editor.transformToolStore.serializableState;
                                imageData = null;
                                if (!image) return [3 /*break*/, 2];
                                return [4 /*yield*/, this.editor.engineMediator.engine.export(ExportFormat$1.DATA_URL)];
                            case 1:
                                imageData = _d.sent();
                                _d.label = 2;
                            case 2:
                                this.editor.modalStore.hideModal();
                                resolve(serialization.serialise(state, imageData));
                                return [3 /*break*/, 4];
                            case 3:
                                e_1 = _d.sent();
                                this.editor.modalStore.hideModal();
                                reject(e_1);
                                return [3 /*break*/, 4];
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            });
        });
    };
    SerializationMediator.prototype.deserialize = function (data) {
        var _this = this;
        this.editor.modalStore.showInfoModal('loading');
        /** Resetting all local states */
        this.editor.resetToolStates();
        /** reseting transform containers */
        var isToolTransform = this.editor.activeStore.tool === Tool.TRANSFORM;
        if (!isToolTransform) {
            this.editor.transformToolStore.onEnter();
        }
        this.editor.transformToolStore.reset();
        if (!isToolTransform) {
            this.editor.transformToolStore.onLeave();
        }
        return new Promise(function (resolve, reject) {
            try {
                import('./index-1c1dd652.js').then(function (_a) {
                    var Deserializer = _a.Deserializer;
                    return __awaiter(_this, void 0, void 0, function () {
                        var transformedImageSize, untransformedImageSize, deserializer, error, appState, image;
                        var _this = this;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    transformedImageSize = this.editor.engineMediator.output.container.getResolution();
                                    untransformedImageSize = this.editor.engineMediator.image.container.getBounds().size;
                                    deserializer = new Deserializer(this.editor.transformToolStore.defaultCropMaskPosition, this.editor.transformToolStore.defaultCropMaskSize, transformedImageSize, untransformedImageSize);
                                    error = 'Unexpected error occured';
                                    appState = deserializer.deserialise(data, function (_a) {
                                        var identifier = _a.identifier;
                                        if (identifier === 'unsupportedVersion') {
                                            _this.editor.modalStore.hideModal();
                                            _this.editor.modalStore.showActionModal({
                                                identifier: 'unsupportedSerializationVersion',
                                            });
                                            error = _this.editor.modalStore.modalProps.message.body;
                                        }
                                    });
                                    if (!appState) return [3 /*break*/, 5];
                                    if (!(appState.image && appState.image.data)) return [3 /*break*/, 2];
                                    image = appState.image.data;
                                    this.editor.setImage(image);
                                    this.editor.scale.defaultScale = 1;
                                    this.editor.scale.resetOffset();
                                    this.editor.transformToolStore.reset();
                                    this.editor.activeStore.setImage(image);
                                    return [4 /*yield*/, this.editor.engineMediator.image.addImageToContainer()
                                        /**
                                         * The order in which the transforms are set is imp
                                         * as the values are interdependant
                                         */
                                    ];
                                case 1:
                                    _b.sent();
                                    /**
                                     * The order in which the transforms are set is imp
                                     * as the values are interdependant
                                     */
                                    this.editor.engineMediator.output.applyNewImageTransform();
                                    this.editor.engineMediator.preview.updateTransform();
                                    this.editor.scale.setInitialTransform();
                                    this.editor.transformToolStore.setCropDefaults();
                                    this.editor.historyStore.addInitialSnapshot();
                                    this.editor.transformToolStore.saveTransforms();
                                    _b.label = 2;
                                case 2: return [4 /*yield*/, this.applyUIstate(appState)];
                                case 3:
                                    _b.sent();
                                    return [4 /*yield*/, this.editor.render()];
                                case 4:
                                    _b.sent();
                                    this.editor.modalStore.hideModal();
                                    resolve();
                                    return [3 /*break*/, 6];
                                case 5:
                                    reject(error);
                                    _b.label = 6;
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                });
            }
            catch (e) {
                if (_this.editor.modalStore.identifier === 'loading') {
                    _this.editor.modalStore.hideModal();
                }
                reject(e);
            }
        });
    };
    /**
     * Deserializer converts serialization schema to serializable appState
     * This function makes sure all the toolStores get the expected state
     * @param appState
     */
    SerializationMediator.prototype.applyUIstate = function (appState) {
        return __awaiter(this, void 0, void 0, function () {
            var isToolTransform, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isToolTransform = this.editor.activeStore.tool === Tool.TRANSFORM;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 12, , 13]);
                        if (!appState.transform) return [3 /*break*/, 3];
                        if (!isToolTransform) {
                            this.editor.transformToolStore.onEnter();
                        }
                        this.editor.transformToolStore.updateStateFromSerialization(appState.transform);
                        return [4 /*yield*/, this.editor.wait()];
                    case 2:
                        _a.sent();
                        if (!isToolTransform) {
                            this.editor.transformToolStore.onLeave();
                        }
                        _a.label = 3;
                    case 3:
                        if (!appState.filter) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.editor.filterToolStore.updateStateFromSerialization(appState.filter)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (appState.adjustment) {
                            this.editor.adjustmentsToolStore.updateStateFromSerialization(appState.adjustment);
                        }
                        if (appState.focus) {
                            this.editor.focusToolStore.updateStateFromSerialization(appState.focus);
                        }
                        if (!appState.frame) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.editor.frameToolStore.updateStateFromSerialization(appState.frame)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        if (!appState.overlay) return [3 /*break*/, 9];
                        return [4 /*yield*/, this.editor.overlayToolStore.updateStateFromSerialization(appState.overlay)];
                    case 8:
                        _a.sent();
                        _a.label = 9;
                    case 9:
                        if (!appState.sprite) return [3 /*break*/, 11];
                        appState.sprite.spriteIdList = appState.sprite.spriteIdList.sort(function (firstElId, secondElId) {
                            var firstElOrder = appState.sprite.common[firstElId].order;
                            var secondElOrder = appState.sprite.common[secondElId].order;
                            return firstElOrder - secondElOrder;
                        });
                        return [4 /*yield*/, this.editor.spriteStore.updateStateFromSerialization(appState.sprite, appState.customStickers)];
                    case 10:
                        _a.sent();
                        _a.label = 11;
                    case 11:
                        if (appState.brush) {
                            this.editor.brushToolStore.updateStateFromHistory(appState.brush);
                        }
                        return [3 /*break*/, 13];
                    case 12:
                        error_1 = _a.sent();
                        // eslint-disable-next-line no-console
                        console.error(error_1);
                        this.editor.modalStore.showActionModal({
                            identifier: 'unexpectedError',
                            error: error_1,
                            handlers: {
                                buttonYes: function () {
                                    window.location.reload();
                                },
                            },
                        });
                        return [3 /*break*/, 13];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    return SerializationMediator;
}());

var getUserAgent = function () {
    return (window && window.navigator && window.navigator.userAgent) || '';
};
var isEdge = function (userAgent) {
    if (userAgent === void 0) { userAgent = getUserAgent(); }
    return userAgent.indexOf('Edge') !== -1;
};
var isIE = function (userAgent) {
    if (userAgent === void 0) { userAgent = getUserAgent(); }
    return !!userAgent.match(/msie|trident/i);
};
var isWindows = function (userAgent) {
    if (userAgent === void 0) { userAgent = getUserAgent(); }
    return !!userAgent.match(/windows/i);
};
var isSafari = function (userAgent) {
    if (userAgent === void 0) { userAgent = getUserAgent(); }
    return userAgent.indexOf('Safari') !== -1 && userAgent.indexOf('Chrome') === -1;
};

var getBlobFromDataURL = function (dataURL) {
    var rawData = atob(dataURL.split(',')[1]);
    var mimeString = dataURL
        .split(',')[0]
        .split(':')[1]
        .split(';')[0];
    var arrayBuffer = new ArrayBuffer(rawData.length);
    var intArray = new Uint8Array(arrayBuffer);
    for (var i = 0; i < rawData.length; i += 1) {
        intArray[i] = rawData.charCodeAt(i);
    }
    return new Blob([arrayBuffer], { type: mimeString });
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now$1 = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now$1());
  }

  function debounced() {
    var time = now$1(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject$1(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var lodash_throttle = throttle;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN$1 = 0 / 0;

/** `Object#toString` result references. */
var symbolTag$1 = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim$1 = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary$1 = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal$1 = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt$1 = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$1 = objectProto$1.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max,
    nativeMin$1 = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now$2 = function() {
  return root$1.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce$1(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$2(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin$1(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now$2();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now$2());
  }

  function debounced() {
    var time = now$2(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$2(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$1(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$1(value) {
  return typeof value == 'symbol' ||
    (isObjectLike$1(value) && objectToString$1.call(value) == symbolTag$1);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber$1(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN$1;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$2(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim$1, '');
  var isBinary = reIsBinary$1.test(value);
  return (isBinary || reIsOctal$1.test(value))
    ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex$1.test(value) ? NAN$1 : +value);
}

var lodash_debounce = debounce$1;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$2 = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal$2 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf$2 = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$2 = freeGlobal$2 || freeSelf$2 || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto$2 = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root$2['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$2 = objectProto$2.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root$2, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$1.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject$3(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$1(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject$3(value) ? objectToString$2.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$3(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

var lodash_memoize = memoize;

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle$1 (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

var canUseDom = canUseDOM;

var scrollbarWidth = function () {
    if (typeof document === 'undefined') {
        return 0;
    }
    // IE11 Check
    if (isIE()) {
        return window.innerWidth - document.documentElement.clientWidth;
    }
    var body = document.body;
    var box = document.createElement('div');
    var boxStyle = box.style;
    boxStyle.position = 'fixed';
    boxStyle.left = '0';
    boxStyle.visibility = 'hidden';
    boxStyle.overflowY = 'scroll';
    body.appendChild(box);
    var width = box.getBoundingClientRect().right;
    body.removeChild(box);
    return width;
};
var SimpleBar = /** @class */ (function () {
    function SimpleBar(element, options) {
        var _this = this;
        this.minScrollbarWidth = 20;
        this.initDOM = function () {
            // make sure this element doesn't have the elements yet
            if (Array.prototype.filter.call(_this.el.children, function (child) {
                return child.classList.contains(_this.classNames.wrapper);
            }).length) {
                // assume that element has his DOM already initiated
                _this.wrapperEl = _this.el.querySelector("." + _this.classNames.wrapper);
                _this.contentWrapperEl = _this.el.querySelector("." + _this.classNames.contentWrapper);
                _this.offsetEl = _this.el.querySelector("." + _this.classNames.offset);
                _this.maskEl = _this.el.querySelector("." + _this.classNames.mask);
                _this.contentEl = _this.el.querySelector("." + _this.classNames.contentEl);
                _this.placeholderEl = _this.el.querySelector("." + _this.classNames.placeholder);
                _this.heightAutoObserverWrapperEl = _this.el.querySelector("." + _this.classNames.heightAutoObserverWrapperEl);
                _this.heightAutoObserverEl = _this.el.querySelector("." + _this.classNames.heightAutoObserverEl);
                _this.axis.x.track.el = _this.el.querySelector("." + _this.classNames.track + "." + _this.classNames.horizontal);
                _this.axis.y.track.el = _this.el.querySelector("." + _this.classNames.track + "." + _this.classNames.vertical);
            }
            else {
                // Prepare DOM
                _this.wrapperEl = document.createElement('div');
                _this.contentWrapperEl = document.createElement('div');
                _this.offsetEl = document.createElement('div');
                _this.maskEl = document.createElement('div');
                _this.contentEl = document.createElement('div');
                _this.placeholderEl = document.createElement('div');
                _this.heightAutoObserverWrapperEl = document.createElement('div');
                _this.heightAutoObserverEl = document.createElement('div');
                _this.wrapperEl.classList.add(_this.classNames.wrapper);
                _this.contentWrapperEl.classList.add(_this.classNames.contentWrapper);
                _this.offsetEl.classList.add(_this.classNames.offset);
                _this.maskEl.classList.add(_this.classNames.mask);
                _this.contentEl.classList.add(_this.classNames.contentEl);
                _this.placeholderEl.classList.add(_this.classNames.placeholder);
                _this.heightAutoObserverWrapperEl.classList.add(_this.classNames.heightAutoObserverWrapperEl);
                _this.heightAutoObserverEl.classList.add(_this.classNames.heightAutoObserverEl);
                while (_this.el.firstChild) {
                    _this.contentEl.appendChild(_this.el.firstChild);
                }
                _this.contentWrapperEl.appendChild(_this.contentEl);
                _this.offsetEl.appendChild(_this.contentWrapperEl);
                _this.maskEl.appendChild(_this.offsetEl);
                _this.heightAutoObserverWrapperEl.appendChild(_this.heightAutoObserverEl);
                _this.wrapperEl.appendChild(_this.heightAutoObserverWrapperEl);
                _this.wrapperEl.appendChild(_this.maskEl);
                _this.wrapperEl.appendChild(_this.placeholderEl);
                _this.el.appendChild(_this.wrapperEl);
            }
            if (!_this.axis.x.track.el || !_this.axis.y.track.el) {
                var track = document.createElement('div');
                var scrollbar = document.createElement('div');
                track.classList.add(_this.classNames.track);
                scrollbar.classList.add(_this.classNames.scrollbar);
                track.appendChild(scrollbar);
                _this.axis.x.track.el = track.cloneNode(true);
                _this.axis.x.track.el.classList.add(_this.classNames.horizontal);
                _this.axis.y.track.el = track.cloneNode(true);
                _this.axis.y.track.el.classList.add(_this.classNames.vertical);
                _this.el.appendChild(_this.axis.x.track.el);
                _this.el.appendChild(_this.axis.y.track.el);
            }
            _this.axis.x.scrollbar.el = _this.axis.x.track.el.querySelector("." + _this.classNames.scrollbar);
            _this.axis.y.scrollbar.el = _this.axis.y.track.el.querySelector("." + _this.classNames.scrollbar);
            if (!_this.options.autoHide) {
                _this.axis.x.scrollbar.el.classList.add(_this.classNames.visible);
                _this.axis.y.scrollbar.el.classList.add(_this.classNames.visible);
            }
            _this.el.setAttribute('data-simplebar', 'init');
        };
        this.initListeners = function () {
            // Event listeners
            if (_this.options.autoHide) {
                _this.el.addEventListener('mouseenter', _this.onMouseEnter);
            }
            [
                'mousedown',
                'click',
                'dblclick',
                'touchstart',
                'touchend',
                'touchmove',
            ].forEach(function (e) {
                _this.el.addEventListener(e, _this.onPointerEvent, {
                    capture: true,
                    passive: true,
                });
            });
            _this.el.addEventListener('mousemove', _this.onMouseMove);
            _this.el.addEventListener('mouseleave', _this.onMouseLeave);
            _this.contentWrapperEl.addEventListener('scroll', _this.onScroll);
            // Browser zoom triggers a window resize
            window.addEventListener('resize', _this.onWindowResize);
            _this.resizeObserver = new index(_this.recalculate);
            _this.resizeObserver.observe(_this.el);
            _this.resizeObserver.observe(_this.contentEl);
        };
        this.recalculate = function () {
            var isHeightAuto = _this.heightAutoObserverEl.offsetHeight <= 1;
            var isWidthAuto = _this.heightAutoObserverEl.offsetWidth <= 1;
            _this.elStyles = window.getComputedStyle(_this.el);
            _this.isRtl = _this.elStyles.direction === 'rtl';
            _this.contentEl.style.padding = _this.elStyles.paddingTop + " " + _this.elStyles.paddingRight + " " + _this.elStyles.paddingBottom + " " + _this.elStyles.paddingLeft;
            _this.wrapperEl.style.margin = "-" + _this.elStyles.paddingTop + " -" + _this.elStyles.paddingRight + " -" + _this.elStyles.paddingBottom + " -" + _this.elStyles.paddingLeft;
            _this.contentWrapperEl.style.height = isHeightAuto ? 'auto' : '100%';
            // Determine placeholder size
            _this.placeholderEl.style.width = isWidthAuto
                ? _this.contentEl.offsetWidth + "px"
                : 'auto';
            _this.placeholderEl.style.height = _this.contentEl.scrollHeight + "px";
            // Set isOverflowing to false if scrollbar is not necessary (content is shorter than offset)
            _this.axis.x.isOverflowing =
                _this.contentWrapperEl.scrollWidth > _this.contentWrapperEl.offsetWidth;
            _this.axis.y.isOverflowing =
                _this.contentWrapperEl.scrollHeight > _this.contentWrapperEl.offsetHeight;
            // Set isOverflowing to false if user explicitely set hidden overflow
            _this.axis.x.isOverflowing =
                _this.elStyles.overflowX === 'hidden' ? false : _this.axis.x.isOverflowing;
            _this.axis.y.isOverflowing =
                _this.elStyles.overflowY === 'hidden' ? false : _this.axis.y.isOverflowing;
            _this.axis.x.forceVisible =
                _this.options.forceVisible === 'x' || _this.options.forceVisible === true;
            _this.axis.y.forceVisible =
                _this.options.forceVisible === 'y' || _this.options.forceVisible === true;
            _this.hideNativeScrollbar();
            _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();
            _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();
            _this.axis.x.scrollbar.size = _this.getScrollbarSize('x');
            _this.axis.y.scrollbar.size = _this.getScrollbarSize('y');
            _this.axis.x.scrollbar.el.style.width = _this.axis.x.scrollbar.size + "px";
            _this.axis.y.scrollbar.el.style.height = _this.axis.y.scrollbar.size + "px";
            _this.positionScrollbar('x');
            _this.positionScrollbar('y');
            _this.toggleTrackVisibility('x');
            _this.toggleTrackVisibility('y');
        };
        /**
         * Calculate scrollbar size
         */
        this.getScrollbarSize = function (axis) {
            if (axis === void 0) { axis = 'y'; }
            var contentSize = _this.scrollbarWidth
                ? _this.contentWrapperEl[_this.axis[axis].scrollSizeAttr]
                : _this.contentWrapperEl[_this.axis[axis].scrollSizeAttr] -
                    _this.minScrollbarWidth;
            var trackSize = _this.axis[axis].track.rect[_this.axis[axis].sizeAttr];
            var scrollbarSize;
            if (!_this.axis[axis].isOverflowing) {
                return;
            }
            var scrollbarRatio = trackSize / contentSize;
            // Calculate new height/position of drag handle.
            scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), _this.options.scrollbarMinSize);
            if (_this.options.scrollbarMaxSize) {
                scrollbarSize = Math.min(scrollbarSize, _this.options.scrollbarMaxSize);
            }
            return scrollbarSize;
        };
        this.positionScrollbar = function (axis) {
            if (axis === void 0) { axis = 'y'; }
            var contentSize = _this.contentWrapperEl[_this.axis[axis].scrollSizeAttr];
            var trackSize = _this.axis[axis].track.rect[_this.axis[axis].sizeAttr];
            var hostSize = parseInt(_this.elStyles[_this.axis[axis].sizeAttr], 10);
            var scrollbar = _this.axis[axis].scrollbar;
            var scrollOffset = _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr];
            scrollOffset =
                axis === 'x' &&
                    _this.isRtl &&
                    SimpleBar.getRtlHelpers().isRtlScrollingInverted
                    ? -scrollOffset
                    : scrollOffset;
            var scrollPourcent = scrollOffset / (contentSize - hostSize);
            var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);
            handleOffset =
                axis === 'x' &&
                    _this.isRtl &&
                    SimpleBar.getRtlHelpers().isRtlScrollbarInverted
                    ? handleOffset + (trackSize - scrollbar.size)
                    : handleOffset;
            scrollbar.el.style.transform =
                axis === 'x'
                    ? "translate3d(" + handleOffset + "px, 0, 0)"
                    : "translate3d(0, " + handleOffset + "px, 0)";
        };
        this.toggleTrackVisibility = function (axis) {
            if (axis === void 0) { axis = 'y'; }
            var track = _this.axis[axis].track.el;
            var scrollbar = _this.axis[axis].scrollbar.el;
            if (_this.axis[axis].isOverflowing || _this.axis[axis].forceVisible) {
                track.style.visibility = 'visible';
                _this.contentWrapperEl.style[_this.axis[axis].overflowAttr] = 'scroll';
            }
            else {
                track.style.visibility = 'hidden';
                _this.contentWrapperEl.style[_this.axis[axis].overflowAttr] = 'hidden';
            }
            // Even if forceVisible is enabled, scrollbar itself should be hidden
            scrollbar.style.display = _this.axis[axis].isOverflowing ? 'block' : 'none';
        };
        /**
         * On scroll event handling
         */
        this.onScroll = function () {
            if (!_this.scrollXTicking) {
                window.requestAnimationFrame(_this.scrollX);
                _this.scrollXTicking = true;
            }
            if (!_this.scrollYTicking) {
                window.requestAnimationFrame(_this.scrollY);
                _this.scrollYTicking = true;
            }
        };
        this.scrollX = function () {
            if (_this.axis.x.isOverflowing) {
                _this.showScrollbar('x');
                _this.positionScrollbar('x');
            }
            _this.scrollXTicking = false;
        };
        this.scrollY = function () {
            if (_this.axis.y.isOverflowing) {
                _this.showScrollbar('y');
                _this.positionScrollbar('y');
            }
            _this.scrollYTicking = false;
        };
        this.onMouseEnter = function () {
            _this.showScrollbar('x');
            _this.showScrollbar('y');
        };
        this.onMouseMove = function (e) {
            _this.mouseX = e.clientX;
            _this.mouseY = e.clientY;
            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {
                _this.onMouseMoveForAxis('x');
            }
            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {
                _this.onMouseMoveForAxis('y');
            }
        };
        this.onMouseMoveForAxis = function (axis) {
            if (axis === void 0) { axis = 'y'; }
            _this.axis[axis].track.rect = _this.axis[axis].track.el.getBoundingClientRect();
            _this.axis[axis].scrollbar.rect = _this.axis[axis].scrollbar.el.getBoundingClientRect();
            var isWithinScrollbarBoundsX = _this.isWithinBounds(_this.axis[axis].scrollbar.rect);
            if (isWithinScrollbarBoundsX) {
                _this.axis[axis].scrollbar.el.classList.add(_this.classNames.hover);
            }
            else {
                _this.axis[axis].scrollbar.el.classList.remove(_this.classNames.hover);
            }
            if (_this.isWithinBounds(_this.axis[axis].track.rect)) {
                _this.showScrollbar(axis);
                _this.axis[axis].track.el.classList.add(_this.classNames.hover);
            }
            else {
                _this.axis[axis].track.el.classList.remove(_this.classNames.hover);
            }
        };
        this.onMouseLeave = function () {
            // @ts-ignore
            _this.onMouseMove.cancel();
            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {
                _this.onMouseLeaveForAxis('x');
            }
            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {
                _this.onMouseLeaveForAxis('y');
            }
            _this.mouseX = -1;
            _this.mouseY = -1;
        };
        this.onWindowResize = function () {
            // Recalculate scrollbarWidth in case it's a zoom
            _this.scrollbarWidth = scrollbarWidth();
            _this.hideNativeScrollbar();
        };
        /**
         * Hide Scrollbar
         */
        this.hideScrollbars = function () {
            _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();
            _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();
            if (!_this.isWithinBounds(_this.axis.y.track.rect)) {
                _this.axis.y.scrollbar.el.classList.remove(_this.classNames.visible);
                _this.axis.y.isVisible = false;
            }
            if (!_this.isWithinBounds(_this.axis.x.track.rect)) {
                _this.axis.x.scrollbar.el.classList.remove(_this.classNames.visible);
                _this.axis.x.isVisible = false;
            }
        };
        this.onPointerEvent = function (e) {
            var isWithinBoundsY;
            var isWithinBoundsX;
            _this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect();
            _this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect();
            if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) {
                isWithinBoundsX = _this.isWithinBounds(_this.axis.x.scrollbar.rect);
            }
            if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) {
                isWithinBoundsY = _this.isWithinBounds(_this.axis.y.scrollbar.rect);
            }
            // If any pointer event is called on the scrollbar
            if (isWithinBoundsY || isWithinBoundsX) {
                // Preventing the event's default action stops text being
                // selectable during the drag.
                e.preventDefault();
                // Prevent event leaking
                e.stopPropagation();
                if (e.type === 'mousedown') {
                    if (isWithinBoundsY) {
                        _this.onDragStart(e, 'y');
                    }
                    if (isWithinBoundsX) {
                        _this.onDragStart(e, 'x');
                    }
                }
            }
        };
        /**
         * Drag scrollbar handle
         */
        this.drag = function (e) {
            var eventOffset;
            var _a = _this.axis[_this.draggedAxis], track = _a.track, scrollbar = _a.scrollbar;
            var trackSize = track.rect[_this.axis[_this.draggedAxis].sizeAttr];
            e.preventDefault();
            e.stopPropagation();
            eventOffset = _this.draggedAxis === 'y' ? e.pageY : e.pageX;
            // Calculate how far the user's mouse is from the top/left of the scrollbar (minus the dragOffset).
            var dragPos = eventOffset -
                track.rect[_this.axis[_this.draggedAxis].offsetAttr] -
                _this.axis[_this.draggedAxis].dragOffset;
            // Convert the mouse position into a percentage of the scrollbar height/width.
            var dragPerc = dragPos / track.rect[_this.axis[_this.draggedAxis].sizeAttr];
            // Scroll the content by the same percentage.
            var scrollPos = dragPerc *
                _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollSizeAttr];
            // Fix browsers inconsistency on RTL
            if (_this.draggedAxis === 'x') {
                scrollPos =
                    _this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollbarInverted
                        ? scrollPos - (trackSize + scrollbar.size)
                        : scrollPos;
                scrollPos =
                    _this.isRtl && SimpleBar.getRtlHelpers().isRtlScrollingInverted
                        ? -scrollPos
                        : scrollPos;
            }
            _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] = scrollPos;
        };
        /**
         * End scroll handle drag
         */
        this.onEndDrag = function (e) {
            e.preventDefault();
            e.stopPropagation();
            _this.el.classList.remove(_this.classNames.dragging);
            document.removeEventListener('mousemove', _this.drag, true);
            document.removeEventListener('mouseup', _this.onEndDrag, true);
            _this.removePreventClickId = window.setTimeout(function () {
                // Remove these asynchronously so we still suppress click events
                // generated simultaneously with mouseup.
                document.removeEventListener('click', _this.preventClick, true);
                document.removeEventListener('dblclick', _this.preventClick, true);
                _this.removePreventClickId = null;
            });
        };
        /**
         * Handler to ignore click events during drag
         */
        this.preventClick = function (e) {
            e.preventDefault();
            e.stopPropagation();
        };
        this.el = element;
        this.options = __assign({}, SimpleBar.defaultOptions, options);
        this.classNames = __assign({}, SimpleBar.defaultOptions.classNames, this.options.classNames);
        this.axis = {
            x: {
                scrollOffsetAttr: 'scrollLeft',
                sizeAttr: 'width',
                scrollSizeAttr: 'scrollWidth',
                offsetAttr: 'left',
                overflowAttr: 'overflowX',
                dragOffset: 0,
                isOverflowing: true,
                isVisible: false,
                forceVisible: false,
                track: {},
                scrollbar: {},
            },
            y: {
                scrollOffsetAttr: 'scrollTop',
                sizeAttr: 'height',
                scrollSizeAttr: 'scrollHeight',
                offsetAttr: 'top',
                overflowAttr: 'overflowY',
                dragOffset: 0,
                isOverflowing: true,
                isVisible: false,
                forceVisible: false,
                track: {},
                scrollbar: {},
            },
        };
        this.removePreventClickId = null;
        // Don't re-instantiate over an existing one
        if (this.el.SimpleBar) {
            return;
        }
        // @ts-ignore
        this.recalculate = lodash_throttle(this.recalculate, 64);
        // @ts-ignore
        this.onMouseMove = lodash_throttle(this.onMouseMove, 64);
        // @ts-ignore
        this.hideScrollbars = lodash_debounce(this.hideScrollbars, this.options.timeout);
        // @ts-ignore
        this.onWindowResize = lodash_debounce(this.onWindowResize, 64, {
            leading: true,
        });
        // @ts-ignore
        SimpleBar.getRtlHelpers = lodash_memoize(SimpleBar.getRtlHelpers);
        this.init();
    }
    /**
     * Static properties
     */
    /**
     * Helper to fix browsers inconsistency on RTL:
     *  - Firefox inverts the scrollbar initial position
     *  - IE11 inverts both scrollbar position and scrolling offset
     * Directly inspired by @KingSora's OverlayScrollbars
     * https://github.com/KingSora/OverlayScrollbars/blob/master/js/OverlayScrollbars.js#L1634
     */
    SimpleBar.getRtlHelpers = function () {
        var dummyDiv = document.createElement('div');
        dummyDiv.innerHTML =
            '<div class="hs-dummy-scrollbar-size"><div style="height: 200% width: 200% margin: 10px 0"></div></div>';
        var scrollbarDummyEl = dummyDiv.firstElementChild;
        document.body.appendChild(scrollbarDummyEl);
        var dummyContainerChild = scrollbarDummyEl.firstElementChild;
        scrollbarDummyEl.scrollLeft = 0;
        var dummyContainerOffset = SimpleBar.getOffset(scrollbarDummyEl);
        var dummyContainerChildOffset = SimpleBar.getOffset(dummyContainerChild);
        scrollbarDummyEl.scrollLeft = 999;
        var dummyContainerScrollOffsetAfterScroll = SimpleBar.getOffset(dummyContainerChild);
        return {
            // determines if the scrolling is responding with negative values
            isRtlScrollingInverted: dummyContainerOffset.left !== dummyContainerChildOffset.left &&
                dummyContainerChildOffset.left -
                    dummyContainerScrollOffsetAfterScroll.left !==
                    0,
            // determines if the origin scrollbar position is inverted or not (positioned on left or right)
            isRtlScrollbarInverted: dummyContainerOffset.left !== dummyContainerChildOffset.left,
        };
    };
    SimpleBar.initHtmlApi = function () {
        this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);
        // MutationObserver is IE11+
        if (typeof MutationObserver !== 'undefined') {
            // Mutation observer to observe dynamically added elements
            this.globalObserver = new MutationObserver(function (mutations) {
                mutations.forEach(function (mutation) {
                    Array.prototype.forEach.call(mutation.addedNodes, function (addedNode) {
                        if (addedNode.nodeType === 1) {
                            if (addedNode.hasAttribute('data-simplebar') && !addedNode.SimpleBar) {
                                new SimpleBar(addedNode, SimpleBar.getElOptions(addedNode));
                            }
                            else {
                                Array.prototype.forEach.call(addedNode.querySelectorAll('[data-simplebar]'), function (el) {
                                    if (!el.SimpleBar) {
                                        new SimpleBar(el, SimpleBar.getElOptions(el));
                                    }
                                });
                            }
                        }
                    });
                    Array.prototype.forEach.call(mutation.removedNodes, function (removedNode) {
                        if (removedNode.nodeType === 1) {
                            if (removedNode.hasAttribute('data-simplebar') && removedNode.SimpleBar) {
                                removedNode.SimpleBar.unMount();
                            }
                            else {
                                Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar]'), function (el) {
                                    if (el.SimpleBar) {
                                        el.SimpleBar.unMount();
                                    }
                                });
                            }
                        }
                    });
                });
            });
            this.globalObserver.observe(document, { childList: true, subtree: true });
        }
        // Taken from jQuery `ready` function
        // Instantiate elements already present on the page
        if (document.readyState === 'complete' ||
            (document.readyState !== 'loading' && !document.documentElement.scroll)) {
            // Handle it asynchronously to allow scripts the opportunity to delay init
            window.setTimeout(this.initDOMLoadedElements);
        }
        else {
            document.addEventListener('DOMContentLoaded', this.initDOMLoadedElements);
            window.addEventListener('load', this.initDOMLoadedElements);
        }
    };
    // Helper function to retrieve options from element attributes
    SimpleBar.getElOptions = function (el) {
        var options = Array.prototype.reduce.call(el.attributes, function (acc, attribute) {
            var option = attribute.name.match(/data-simplebar-(.+)/);
            if (option) {
                var key = option[1].replace(/\W+(.)/g, function (x, chr) {
                    return chr.toUpperCase();
                });
                switch (attribute.value) {
                    case 'true':
                        acc[key] = true;
                        break;
                    case 'false':
                        acc[key] = false;
                        break;
                    case undefined:
                        acc[key] = true;
                        break;
                    default:
                        acc[key] = attribute.value;
                }
            }
            return acc;
        }, {});
        return options;
    };
    SimpleBar.removeObserver = function () {
        this.globalObserver.disconnect();
    };
    SimpleBar.initDOMLoadedElements = function () {
        document.removeEventListener('DOMContentLoaded', this.initDOMLoadedElements);
        window.removeEventListener('load', this.initDOMLoadedElements);
        Array.prototype.forEach.call(document.querySelectorAll('[data-simplebar]'), function (el) {
            if (!el.SimpleBar) {
                new SimpleBar(el, SimpleBar.getElOptions(el));
            }
        });
    };
    SimpleBar.getOffset = function (el) {
        var rect = el.getBoundingClientRect();
        return {
            top: rect.top + (window.pageYOffset || document.documentElement.scrollTop),
            left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft),
        };
    };
    SimpleBar.prototype.init = function () {
        // Save a reference to the instance, so we know this DOM node has already been instancied
        this.el.SimpleBar = this;
        // We stop here on server-side
        if (canUseDom) {
            this.initDOM();
            this.scrollbarWidth = scrollbarWidth();
            this.recalculate();
            this.initListeners();
        }
    };
    SimpleBar.prototype.hideNativeScrollbar = function () {
        this.offsetEl.style[this.isRtl ? 'left' : 'right'] =
            this.axis.y.isOverflowing || this.axis.y.forceVisible
                ? "-" + (this.scrollbarWidth || this.minScrollbarWidth) + "px"
                : 0;
        this.offsetEl.style.bottom =
            this.axis.x.isOverflowing || this.axis.x.forceVisible
                ? "-" + (this.scrollbarWidth || this.minScrollbarWidth) + "px"
                : 0;
        // If floating scrollbar
        if (!this.scrollbarWidth) {
            var paddingDirection = this.isRtl ? 'paddingLeft' : 'paddingRight';
            this.contentWrapperEl.style[paddingDirection] =
                this.axis.y.isOverflowing || this.axis.y.forceVisible
                    ? this.minScrollbarWidth + "px"
                    : 0;
            this.contentWrapperEl.style.paddingBottom =
                this.axis.x.isOverflowing || this.axis.x.forceVisible
                    ? this.minScrollbarWidth + "px"
                    : 0;
        }
    };
    SimpleBar.prototype.onMouseLeaveForAxis = function (axis) {
        if (axis === void 0) { axis = 'y'; }
        this.axis[axis].track.el.classList.remove(this.classNames.hover);
        this.axis[axis].scrollbar.el.classList.remove(this.classNames.hover);
    };
    /**
     * Show scrollbar
     */
    SimpleBar.prototype.showScrollbar = function (axis) {
        if (axis === void 0) { axis = 'y'; }
        var scrollbar = this.axis[axis].scrollbar.el;
        if (!this.axis[axis].isVisible) {
            scrollbar.classList.add(this.classNames.visible);
            this.axis[axis].isVisible = true;
        }
        if (this.options.autoHide) {
            this.hideScrollbars();
        }
    };
    /**
     * on scrollbar handle drag movement starts
     */
    SimpleBar.prototype.onDragStart = function (e, axis) {
        if (axis === void 0) { axis = 'y'; }
        var scrollbar = this.axis[axis].scrollbar.el;
        // Measure how far the user's mouse is from the top of the scrollbar drag handle.
        var eventOffset = axis === 'y' ? e.pageY : e.pageX;
        this.axis[axis].dragOffset =
            eventOffset -
                scrollbar.getBoundingClientRect()[this.axis[axis].offsetAttr];
        this.draggedAxis = axis;
        this.el.classList.add(this.classNames.dragging);
        document.addEventListener('mousemove', this.drag, true);
        document.addEventListener('mouseup', this.onEndDrag, true);
        if (this.removePreventClickId === null) {
            document.addEventListener('click', this.preventClick, true);
            document.addEventListener('dblclick', this.preventClick, true);
        }
        else {
            window.clearTimeout(this.removePreventClickId);
            this.removePreventClickId = null;
        }
    };
    /**
     * Getter for content element
     */
    SimpleBar.prototype.getContentElement = function () {
        return this.contentEl;
    };
    /**
     * Getter for original scrolling element
     */
    SimpleBar.prototype.getScrollElement = function () {
        return this.contentWrapperEl;
    };
    SimpleBar.prototype.removeListeners = function () {
        var _this = this;
        // Event listeners
        if (this.options.autoHide) {
            this.el.removeEventListener('mouseenter', this.onMouseEnter);
        }
        [
            'mousedown',
            'click',
            'dblclick',
            'touchstart',
            'touchend',
            'touchmove',
        ].forEach(function (e) {
            _this.el.removeEventListener(e, _this.onPointerEvent, {
                capture: true,
                passive: true,
            });
        });
        this.el.removeEventListener('mousemove', this.onMouseMove);
        this.el.removeEventListener('mouseleave', this.onMouseLeave);
        this.contentWrapperEl.removeEventListener('scroll', this.onScroll);
        window.removeEventListener('resize', this.onWindowResize);
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
        }
        this.resizeObserver.disconnect();
        // Cancel all debounced functions
        // @ts-ignore
        this.recalculate.cancel();
        // @ts-ignore
        this.onMouseMove.cancel();
        // @ts-ignore
        this.hideScrollbars.cancel();
        // @ts-ignore
        this.onWindowResize.cancel();
    };
    /**
     * UnMount mutation observer and delete SimpleBar instance from DOM element
     */
    SimpleBar.prototype.unMount = function () {
        this.removeListeners();
        this.el.SimpleBar = null;
    };
    /**
     * Recursively walks up the parent nodes looking for this.el
     */
    SimpleBar.prototype.isChildNode = function (el) {
        if (el === null) {
            return false;
        }
        if (el === this.el) {
            return true;
        }
        return this.isChildNode(el.parentNode);
    };
    /**
     * Check if mouse is within bounds
     */
    SimpleBar.prototype.isWithinBounds = function (bbox) {
        return (this.mouseX >= bbox.left &&
            this.mouseX <= bbox.left + bbox.width &&
            this.mouseY >= bbox.top &&
            this.mouseY <= bbox.top + bbox.height);
    };
    SimpleBar.defaultOptions = {
        autoHide: true,
        forceVisible: false,
        classNames: {
            contentEl: 'simplebar-content',
            contentWrapper: 'simplebar-content-wrapper',
            offset: 'simplebar-offset',
            mask: 'simplebar-mask',
            wrapper: 'simplebar-wrapper',
            placeholder: 'simplebar-placeholder',
            scrollbar: 'simplebar-scrollbar',
            track: 'simplebar-track',
            heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',
            heightAutoObserverEl: 'simplebar-height-auto-observer',
            visible: 'simplebar-visible',
            horizontal: 'simplebar-horizontal',
            vertical: 'simplebar-vertical',
            hover: 'simplebar-hover',
            dragging: 'simplebar-dragging',
        },
        scrollbarMinSize: 25,
        scrollbarMaxSize: 0,
        timeout: 1000,
    };
    return SimpleBar;
}());
/**
 * HTML API
 * Called only in a browser env.
 */
if (canUseDom) {
    SimpleBar.initHtmlApi();
}

/**
 * Editor is center point for state management in the app
 * communication between different tools and editor core
 * Editor core is responsible for configuration, engine instance(container transforms),
 * zoom/scale, canvas, modals, active, history
 *
 * Sprite contains instances of Sticker, Text, TextDesign, Brush toolStores
 *
 * Transform contains instance of transformstore
 *
 * Rest contains instances of all the rest of the tools (filter, focus, frame, adjustment, overlay)
 */
var Editor = /** @class */ (function () {
    function Editor(config) {
        var _this = this;
        this.checkImageResize = function () {
            _this.engine.on(EngineEvent.BEGAN_IMAGE_DOWNSCALING, function () {
                _this.modalStore.showInfoModal('resizing');
            });
            _this.engine.on(EngineEvent.IMAGE_DOWNSCALED, function () {
                // The resize events are not firing properly, so themodal will be hidden after render
                // this.modalStore.hideModal()
            });
        };
        this.onToolChange = function (prevTool, nextTool, render) {
            if (nextTool === void 0) { nextTool = null; }
            if (render === void 0) { render = true; }
            if (prevTool === nextTool) {
                return;
            }
            if (_this.engineMediator.preview.container) {
                if ([prevTool, nextTool].indexOf(Tool.TRANSFORM) !== -1) {
                    var canvasSize = _this.canvasStore.canvasSize;
                    var toolControlHeight = _this.configStore.measurements.basicToolControlBar.controlsBarHeight;
                    if (prevTool === Tool.TRANSFORM) {
                        if (!_this.configStore.isLayoutAdvanced) {
                            _this.canvasStore.state.canvasSize.height = canvasSize.height + toolControlHeight;
                            _this.resize();
                        }
                        _this.transformToolStore.onLeave();
                        _this.historyStore.removeTransformLocalSnapshots();
                        var outputScale = _this.engineMediator.preview.container.getScale().x;
                        var outputRes = _this.engineMediator.output.container.getResolution();
                        var defaultImageSize = _this.transformToolStore.defaultImageSize;
                        var isCropped = outputScale !== 1 ||
                            defaultImageSize.width !== outputRes.width ||
                            defaultImageSize.height !== outputRes.height;
                        if (isCropped) {
                            _this.addSnapshot({
                                transform: {
                                    outputSize: _this.engineMediator.output.container.getResolution(),
                                    previewTransform: _this.engineMediator.preview.container.getTransform(),
                                    outputTransform: _this.engineMediator.output.container.getTransform(),
                                },
                            }, "edit" /* EDIT */, '');
                        }
                        /** Everytime crop changes the topLeft position of preview has to be updated */
                        _this.snappingStore.calculatePreviewTopLeftPosition();
                    }
                    else if (nextTool === Tool.TRANSFORM) {
                        if (!_this.configStore.isLayoutAdvanced) {
                            _this.canvasStore.state.canvasSize.height = canvasSize.height - toolControlHeight;
                            _this.resize();
                        }
                        _this.transformToolStore.onEnter();
                        _this.transformToolStore.addSnapshot();
                    }
                }
                else {
                    _this.scale.resetOffset();
                    _this.scale.resetPosition();
                    _this.scale.setScaleToDefault();
                    _this.scale.scaleRender(true);
                }
                if (render) {
                    _this.render();
                }
            }
        };
        this.resize = function () {
            try {
                _this.transformToolStore.applyDefaultCrop(false);
                _this.canvasStore.updateCanvasDimensions();
                var oldDefaultSize = toJS(_this.transformToolStore.defaultCropMaskSize);
                var isToolTransform = _this.activeStore.tool === Tool.TRANSFORM;
                if (!isToolTransform) {
                    _this.transformToolStore.onEnter();
                }
                var rotation = _this.engineMediator.preview.container.getRotation();
                var updated = _this.engineMediator.preview.updateTransform(rotation);
                if (updated) {
                    _this.scale.setInitialTransform();
                    _this.transformToolStore.setCropDefaults();
                    /** Updating ui control positions */
                    _this.transformToolStore.updateCanvasControls(oldDefaultSize);
                    _this.focusToolStore.updateCanvasControls();
                    _this.spriteStore.updateCanvasControls();
                    var scale = _this.transformToolStore.getScaleWithFlip(rotation);
                    _this.engineMediator.preview.container.setScale(scale);
                    if (!isToolTransform) {
                        _this.transformToolStore.onLeave();
                    }
                    /** Initial calculation of preview Top-Left */
                    _this.snappingStore.calculatePreviewTopLeftPosition();
                    // Brush cursor size doesn't change on resize, so no need of updating canvas controls
                    _this.render();
                }
            }
            catch (err) {
                _this.modalStore.showActionModal({
                    identifier: 'rendering',
                    handlers: {
                        buttonYes: function () {
                            window.location.reload();
                        },
                    },
                });
            }
        };
        this.export = function (options) {
            return new Promise(function (resolve, reject) {
                _this.modalStore.showInfoModal('exporting');
                var isToolTransform = _this.activeStore.tool === Tool.TRANSFORM;
                if (isToolTransform) {
                    _this.transformToolStore.onLeave();
                }
                var config = _this.configStore.config;
                var exportConf = options === undefined ? config.export.image : __assign({}, config.export.image, options);
                var enableDownload = exportConf.enableDownload;
                _this.engineMediator.engine
                    .export(exportConf.exportType, exportConf.format, exportConf.quality)
                    .then(function (imageData) {
                    if (enableDownload) {
                        var ext = exportConf.format.indexOf('jpeg') !== -1 ? '.jpeg' : '.png';
                        var fileName = config.export.filename + ext;
                        if (imageData.src) {
                            // provide a fallback for edge browser
                            if (isEdge() && navigator.msSaveBlob) {
                                var blob = getBlobFromDataURL(imageData.src);
                                navigator.msSaveBlob(blob, fileName);
                            }
                            else {
                                var a = document.createElement('a');
                                var url = URL.createObjectURL(getBlobFromDataURL(imageData.src));
                                document.body.appendChild(a);
                                a.href = url;
                                a.download = fileName;
                                a.click();
                                document.body.removeChild(a);
                                window.URL.revokeObjectURL(url);
                            }
                        }
                    }
                    _this.configStore.events.onExport(imageData.src);
                    resolve(imageData.src);
                    if (isToolTransform) {
                        _this.transformToolStore.onEnter();
                    }
                    _this.modalStore.hideModal();
                })
                    .catch(function (err) {
                    reject(err);
                    if (isToolTransform) {
                        _this.transformToolStore.onEnter();
                    }
                    _this.modalStore.hideModal();
                });
            });
        };
        this.wait = function (amount) {
            if (amount === void 0) { amount = 0; }
            return new Promise(function (resolve) { return setTimeout(resolve, amount); });
        };
        this.getAssetPath = function (category) { return _this.assetProvider.getAbsolutePathForCategory(category); };
        this.getPreviewSize = function () {
            var _a = _this.engine.getOutputDimensions(), width = _a.width, height = _a.height;
            if (width && height) {
                return {
                    width: Math.floor(_this.worldToPreview(_this.outputToWorld(width))),
                    height: Math.floor(_this.worldToPreview(_this.outputToWorld(height))),
                };
            }
            return { height: height, width: width };
        };
        this.configStore = new ConfigStore();
        var provider = this.configStore.saveConfig(config);
        this.engineMediator = new EngineMediator(this);
        this.serializationMediator = new SerializationMediator(this);
        this.spriteStore = new SpriteStore(this);
        this.scale = new ScaleStore(this);
        this.filterToolStore = new FilterToolStore(this);
        this.adjustmentsToolStore = new AdjustmentsToolStore(this);
        this.focusToolStore = new FocusToolStore(this);
        this.overlayToolStore = new OverlayToolStore(this);
        this.frameToolStore = new FrameToolStore(this);
        this.brushToolStore = new BrushToolStore(this);
        this.transformToolStore = new TransformToolStore(this);
        this.libraryStore = new LibraryStore(this);
        this.modalStore = new ModalStore(this);
        this.snappingStore = new SnappingStore(this);
        this.activeStore = new ActiveStore(this);
        this.canvasStore = new CanvasStore(this);
        this.historyStore = new HistoryStore(this);
        this.modalStore.showInfoModal('loading');
        this.libraryStore.initProvider(provider);
        if (this.configStore.config.displayResizeWarning) {
            this.checkImageResize();
        }
        if (this.configStore.config.filter.enablePreviewThumbnails) {
            var engineConfig = this.configStore.config.engine;
            this.previewThumbnails = new PreviewThumbnails(__assign({}, engineConfig, { license: this.configStore.config.license, assetProvider: this.configStore.assetProvider }));
        }
    }
    Object.defineProperty(Editor, "defaultColors", {
        get: function () {
            return Object.keys(ColorObject).map(function (key) {
                var color = ColorObject[key];
                return {
                    identifier: key,
                    color: color,
                    colorString: convertToColorString(color),
                };
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Editor, "defaultBackgroundColors", {
        get: function () {
            return Object.keys(BackgroundColorObject).map(function (key) {
                var color = BackgroundColorObject[key];
                return {
                    identifier: key,
                    color: color,
                    colorString: convertToColorString(color),
                };
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Editor, "devicePixelRatio", {
        get: function () {
            return window.devicePixelRatio || 1;
        },
        enumerable: true,
        configurable: true
    });
    Editor.prototype.init = function (image) {
        var _this = this;
        var isDirty = this.historyStore.isDirty();
        if (isDirty) {
            this.modalStore.showActionModal({
                identifier: 'discardChanges',
                handlers: {
                    buttonYes: function () {
                        _this.setImage(image);
                        _this.resetToolStates();
                    },
                    buttonNo: function () {
                        _this.setImage(image, true);
                    },
                },
            });
        }
        else {
            this.setImage(image);
            this.historyStore.reset();
        }
        this.libraryStore.fetchImages();
    };
    Editor.prototype.setImage = function (image, updateControls) {
        if (updateControls === void 0) { updateControls = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, flipHorizontally, flipVertically, activeTool, error_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 4, , 5]);
                        this.modalStore.showInfoModal(this.configStore.config.displayResizeWarning ? 'resizing' : 'loading');
                        this.scale.defaultScale = 1;
                        this.scale.resetOffset();
                        this.activeStore.setImage(image);
                        return [4 /*yield*/, this.engineMediator.image.addImageToContainer()
                            /**
                             * The order in which the transforms are set is imp
                             * as the values are interdependant
                             */
                        ];
                    case 1:
                        _b.sent();
                        /**
                         * The order in which the transforms are set is imp
                         * as the values are interdependant
                         */
                        this.engineMediator.output.applyNewImageTransform();
                        this.engineMediator.preview.updateTransform();
                        return [4 /*yield*/, this.filterToolStore.setImageAndGetPreviews()];
                    case 2:
                        _b.sent();
                        this.scale.setInitialTransform();
                        this.transformToolStore.setCropDefaults();
                        this.historyStore.addInitialSnapshot();
                        _a = this.transformToolStore.rotateFlipState, flipHorizontally = _a.flipHorizontally, flipVertically = _a.flipVertically;
                        this.outputContainer.setData({ flipVertically: flipVertically, flipHorizontally: flipHorizontally });
                        if (updateControls) {
                            /** Updating ui control positions */
                            this.focusToolStore.updateCanvasControls();
                            this.spriteStore.updateCanvasControls();
                            this.transformToolStore.resetCrop();
                            this.transformToolStore.applyDefaultCrop();
                            this.transformToolStore.saveTransformsBasedOnFlip();
                            this.transformToolStore.onEnter();
                            this.transformToolStore.setRotation(this.transformToolStore.rotationInDegrees);
                            this.transformToolStore.onLeave();
                        }
                        else {
                            this.transformToolStore.saveTransforms();
                        }
                        /** Initial calculation of preview Top-Left */
                        this.snappingStore.calculatePreviewTopLeftPosition();
                        return [4 /*yield*/, this.renderPromise()];
                    case 3:
                        _b.sent();
                        activeTool = this.activeStore.tool;
                        if (!activeTool) {
                            this.onReady();
                        }
                        if (!this.configStore.config.filter.enablePreviewThumbnails) {
                            this.modalStore.hideModal();
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        error_1 = _b.sent();
                        this.modalStore.hideModal();
                        this.modalStore.showActionModal({
                            identifier: error_1.identifier ? error_1.identifier : 'rendering',
                            error: error_1,
                            handlers: {
                                buttonYes: function () {
                                    window.location.reload();
                                },
                            },
                        });
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    Editor.prototype.serialize = function (_a) {
        var image = (_a === void 0 ? { image: true } : _a).image;
        return this.serializationMediator.serialize({ image: image });
    };
    Editor.prototype.deserialize = function (data) {
        return this.serializationMediator.deserialize(data);
    };
    Editor.prototype.close = function () {
        var _this = this;
        var isDirty = this.historyStore.isDirty();
        if (isDirty && this.configStore.config.displayCloseWarning) {
            this.modalStore.showActionModal({
                identifier: 'unsavedChanges',
                handlers: {
                    buttonYes: function () {
                        _this.configStore.events.onClose();
                    },
                },
            });
        }
        else {
            this.configStore.events.onClose();
        }
    };
    Editor.prototype.clickableCanvas = function (isClickable) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!isClickable) return [3 /*break*/, 2];
                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 0); })];
                    case 1:
                        _a.sent();
                        this.canvasStore.enableCanvasClick();
                        return [3 /*break*/, 3];
                    case 2:
                        this.canvasStore.disableCanvasClick();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Object.defineProperty(Editor.prototype, "shortestOutputSide", {
        get: function () {
            var outputBounds = this.outputContainer.getBounds();
            return Math.min(outputBounds.width, outputBounds.height);
        },
        enumerable: true,
        configurable: true
    });
    Editor.prototype.onReady = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, layout, forceCrop, outputSize, outputRatio, ratios;
            return __generator(this, function (_b) {
                _a = this.configStore.config, layout = _a.layout, forceCrop = _a.forceCrop;
                if (layout === 'advanced') {
                    this.activeStore.selectTool(this.configStore.defaultTool);
                }
                if (forceCrop) {
                    outputSize = this.transformToolStore.localOutputImageSize;
                    outputRatio = outputSize.width / outputSize.height;
                    ratios = this.transformToolStore.entityManager.items.map(function (transform) {
                        if (transform.ratio === '*') {
                            return transform.ratio;
                        }
                        if (transform.ratio) {
                            return transform.ratio.toFixed(2);
                        }
                        return (transform.dimensions.x / transform.dimensions.y).toFixed(2);
                    });
                    if (ratios.indexOf('*') !== -1) {
                        // eslint-disable-next-line no-console
                        console.error('ForceCrop will not work if "*" is one of the ratios');
                    }
                    else if (ratios.indexOf(outputRatio.toFixed(2)) === -1) {
                        this.activeStore.selectTool(Tool.TRANSFORM);
                    }
                }
                this.configStore.events.onEditorReady();
                return [2 /*return*/];
            });
        });
    };
    Editor.prototype.addSnapshot = function (state, type, description) {
        this.historyStore.addSnapshot(state, type, description);
    };
    Editor.prototype.addLocalTransformSnapshot = function (state, description, type) {
        if (type === void 0) { type = "edit" /* EDIT */; }
        this.historyStore.addSnapshot({ localTransform: state }, type, description);
    };
    /**
     * This is run when image has been changed
     */
    Editor.prototype.resetToolStates = function () {
        this.filterToolStore.pureReset();
        this.focusToolStore.pureReset();
        this.adjustmentsToolStore.pureReset();
        this.overlayToolStore.pureReset();
        this.frameToolStore.pureReset();
        this.brushToolStore.pureReset();
        this.spriteStore.pureReset();
        this.transformToolStore.pureReset();
        this.historyStore.reset();
        this.render();
    };
    Object.defineProperty(Editor.prototype, "assetProvider", {
        get: function () {
            return this.configStore.assetProvider;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "engine", {
        get: function () {
            return this.engineMediator.engine;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "imageContainer", {
        get: function () {
            return this.engineMediator.image.container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "orderHelper", {
        get: function () {
            return this.engineMediator.orderHelper;
        },
        enumerable: true,
        configurable: true
    });
    Editor.prototype.render = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.renderPromise()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Editor.prototype.renderPromise = function () {
        return this.engineMediator.render(this.engineMediator.preview.container);
    };
    Editor.prototype.previewToWorld = function (point, useOutputWithoutFlip) {
        if (isNumber(point)) {
            return this.engineMediator.previewSpaceToWorldSpace(point, useOutputWithoutFlip);
        }
        return this.engineMediator.previewSpaceToWorldSpace(point, useOutputWithoutFlip);
    };
    Editor.prototype.worldToPreview = function (point) {
        if (isNumber(point)) {
            return this.engineMediator.worldSpaceToPreviewSpace(point);
        }
        return this.engineMediator.worldSpaceToPreviewSpace(point);
    };
    Editor.prototype.outputToWorld = function (point) {
        if (isNumber(point)) {
            return this.engineMediator.outputSpaceToWorldSpace(point);
        }
        return this.engineMediator.outputSpaceToWorldSpace(point);
    };
    Editor.prototype.previewToOutput = function (point) {
        if (isNumber(point)) {
            return this.engineMediator.previewSpaceToOutputSpace(point);
        }
        return this.engineMediator.previewSpaceToOutputSpace(point);
    };
    Editor.prototype.applyFlipToPreview = function (point) {
        return this.engineMediator.previewSpaceToFlippedPreviewSpace(point);
    };
    Object.defineProperty(Editor.prototype, "outputContainer", {
        get: function () {
            return this.engineMediator.output.container;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        action
    ], Editor.prototype, "resize", void 0);
    __decorate([
        action
    ], Editor.prototype, "export", void 0);
    __decorate([
        action
    ], Editor.prototype, "clickableCanvas", null);
    return Editor;
}());

var initialFolderState$2 = 'identity';
var customStickerCategoryIdentifier = 'imgly_sticker_custom';
var StickerToolStore = /** @class */ (function () {
    function StickerToolStore(editor) {
        var _this = this;
        this.state = observable.map(stickerInitialState);
        this.customStickerIds = [];
        this.activeTintColorId = observable.box(defaultTintColorId);
        this.changeOpacity = function (opacity) {
            if (_this.id) {
                var sticker = _this.state.get(_this.id);
                if (sticker) {
                    _this.editor.spriteStore.setContainerProperties(_this.id, { opacity: opacity });
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    sticker.opacity = properties.opacity;
                    _this.state.set(_this.id, sticker);
                }
            }
        };
        this.changeTintColor = function (tintColor, identifier) {
            if (_this.id) {
                var sticker = _this.state.get(_this.id);
                if (sticker) {
                    var tintMode = _this.entityManager.items.find(function (option) { return option.identifier === _this.identifier; }).tintMode;
                    _this.editor.spriteStore.setContainerProperties(_this.id, {
                        tintColor: tintColor,
                        tintMode: tintMode,
                    });
                    var properties = _this.editor.spriteStore.getContainerProperties(_this.id);
                    sticker.tintColor = properties.tintColor;
                    _this.activeTintColorId.set(identifier);
                    sticker.tintMode = properties.tintMode || stickerDefaultState.tintMode;
                    _this.state.set(_this.id, sticker);
                }
            }
        };
        this.tintColorSnapshot = function () {
            _this.addSnapshot("edit" /* EDIT */, _this.locale.history.color);
        };
        this.editor = editor;
        this.selectedCategory = initialFolderState$2;
        var config = this.config;
        var assets = this.editor.assetProvider.getAssets('sticker');
        this.entityManager = new EntityMapper(assets, __assign({}, config, { categoryKey: 'thumbnailURI', categoryDynamicKey: 'thumbnail', itemKey: 'stickerURI', itemDynamicKey: 'sticker', locale: __assign({}, this.locale.items, this.locale.categories), getAssetPath: this.editor.getAssetPath('sticker') }));
    }
    Object.defineProperty(StickerToolStore, "defaultColors", {
        get: function () {
            return Editor.defaultColors;
        },
        enumerable: true,
        configurable: true
    });
    StickerToolStore.prototype.selectLast = function () {
        this.editor.spriteStore.selectHighestOrderSprite(Array.from(this.state.keys()));
    };
    StickerToolStore.prototype.doesStickerAssetExist = function (identifier) {
        return this.entityManager.items.findIndex(function (t) { return t.identifier === identifier; }) !== -1;
    };
    StickerToolStore.prototype.add = function (identifier) {
        var sticker = this.entities.find(function (s) { return s.identifier === identifier; });
        var tintMode = (sticker ? sticker.tintMode : stickerDefaultState.tintMode);
        var resizeMode = (sticker ? sticker.resizeMode : stickerDefaultState.resizeMode);
        this.editor.spriteStore.addSticker({
            state: {
                identifier: identifier,
                tintMode: tintMode,
                tintColor: stickerDefaultState.tintColor,
                opacity: stickerDefaultState.opacity,
                tintColorId: defaultTintColorId,
                resizeMode: resizeMode,
            },
        });
    };
    StickerToolStore.prototype.duplicate = function () {
        if (this.id) {
            var transform = this.editor.spriteStore.getDuplicateContainerTransform(this.id);
            var flipHorizontally = this.editor.spriteStore.getDuplicateContainerFlip(this.id);
            this.editor.spriteStore.addSticker({
                state: {
                    identifier: this.identifier,
                    tintColor: toJS(this.tintColor),
                    tintMode: this.tintMode,
                    resizeMode: this.resizeMode,
                    opacity: this.opacity,
                    tintColorId: this.activeTintColor,
                    flipHorizontally: flipHorizontally,
                },
                transform: transform,
            });
        }
    };
    StickerToolStore.prototype.bringToFront = function () {
        if (this.id) {
            this.editor.spriteStore.bringToFront(this.id);
        }
    };
    StickerToolStore.prototype.flipHorizontally = function () {
        if (this.id) {
            this.editor.spriteStore.flipHorizontally(this.id);
        }
    };
    StickerToolStore.prototype.delete = function () {
        if (this.id) {
            var identifier = this.id;
            this.editor.spriteStore.removeSprite(identifier);
            this.state.delete(identifier);
            this.selectLast();
        }
    };
    StickerToolStore.prototype.updateStateFromHistory = function (id, sticker) {
        this.setState(id, sticker);
        this.editor.spriteStore.setContainerProperties(id, sticker);
    };
    StickerToolStore.prototype.setState = function (id, state) {
        var sticker = this.state.get(id);
        if (sticker) {
            if ('opacity' in state) {
                sticker.opacity = state.opacity;
            }
            if (state.tintColor) {
                sticker.tintColor = state.tintColor;
                if (state.tintColorId) {
                    this.activeTintColorId.set(state.tintColorId);
                }
            }
            if (state.tintMode) {
                sticker.tintMode = state.tintMode;
            }
            if (state.resizeMode) {
                sticker.resizeMode = state.resizeMode;
            }
            this.state.set(id, sticker);
        }
        else {
            this.state.set(id, {
                identifier: state.identifier,
                opacity: state.opacity,
                tintMode: state.tintMode,
                resizeMode: state.resizeMode,
                tintColor: state.tintColor ? state.tintColor : stickerDefaultState.tintColor,
            });
            if (state.tintColorId) {
                this.activeTintColorId.set(state.tintColorId);
            }
        }
    };
    StickerToolStore.prototype.addFiles = function (files) {
        return __awaiter(this, void 0, void 0, function () {
            var i, fileData, data, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.editor.modalStore.showInfoModal('loading');
                        if (!files.length) return [3 /*break*/, 4];
                        i = 0;
                        fileData = [];
                        for (i = 0; i < files.length; i += 1) {
                            /**
                             * loadFile resolves with 2 images
                             * Check loadImage docs for more info
                             */
                            fileData.push(loadFile(files[i], true));
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, Promise.all(fileData)];
                    case 2:
                        data = _a.sent();
                        this.addCustomStickerAsset(data);
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        this.editor.modalStore.hideModal();
                        this.editor.modalStore.showActionModal({ identifier: 'stickerLoading' });
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    StickerToolStore.prototype.addCustomStickerAsset = function (stickers) {
        return __awaiter(this, void 0, void 0, function () {
            var customStickers, customStickerLable, assets, config;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        customStickers = stickers.map(function (s) { return ({
                            sticker: s.image,
                            thumbnailURI: s.smallImage,
                            name: s.name,
                            tintMode: _this.customStickerTintMode,
                            resizeMode: 'keepAspect',
                            identifier: s.id,
                            type: s.type,
                        }); });
                        this.customStickerIds = this.customStickerIds.concat(customStickers.map(function (s) { return ({ identifier: s.identifier, type: s.type }); }));
                        customStickerLable = this.locale.categories[customStickerCategoryIdentifier];
                        this.editor.assetProvider.addCustomStickerAsset(customStickers, customStickerCategoryIdentifier, customStickerLable);
                        assets = this.editor.assetProvider.getAssets('sticker');
                        config = this.config;
                        this.entityManager = new EntityMapper(assets, __assign({}, config, { categoryKey: 'thumbnailURI', categoryDynamicKey: 'thumbnail', itemDynamicKey: 'thumbnailURI', itemKey: 'stickerURI', locale: this.locale.items, getAssetPath: this.editor.getAssetPath('sticker') }));
                        this.selectedCategory = stickerDefaultState.identifier;
                        return [4 /*yield*/, this.editor.wait()];
                    case 1:
                        _a.sent();
                        this.selectedCategory = customStickerCategoryIdentifier;
                        this.editor.modalStore.hideModal();
                        return [2 /*return*/];
                }
            });
        });
    };
    StickerToolStore.prototype.toolSnapshot = function () {
        this.addSnapshot("edit" /* EDIT */, this.locale.history.opacity);
    };
    StickerToolStore.prototype.addSnapshot = function (type, desc) {
        if (this.currentSticker) {
            this.editor.spriteStore.addSnapshot(type, desc);
        }
    };
    StickerToolStore.prototype.toggleCategorySelection = function (identifier) {
        this.selectedCategory = this.selectedCategory === identifier ? initialFolderState$2 : identifier;
    };
    StickerToolStore.prototype.pureReset = function () {
        this.state = observable.map(stickerInitialState);
    };
    Object.defineProperty(StickerToolStore.prototype, "isStickerSelected", {
        get: function () {
            return this.editor.spriteStore.isSpriteSticker;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "activeTintColor", {
        get: function () {
            return this.activeTintColorId.get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "isCustomStickerEnabled", {
        get: function () {
            return this.config.enableCustomUpload;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "customStickerTintMode", {
        get: function () {
            return this.config.customStickerTintMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "currentSticker", {
        get: function () {
            if (this.isStickerSelected) {
                var sticker = this.state.get(this.id);
                if (sticker) {
                    return sticker;
                }
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "identifier", {
        get: function () {
            if (this.isStickerSelected) {
                var sticker = this.state.get(this.id);
                if (sticker) {
                    return sticker.identifier;
                }
            }
            return 'none';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "id", {
        get: function () {
            if (this.isStickerSelected) {
                return this.editor.spriteStore.id;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "opacity", {
        get: function () {
            if (this.currentSticker) {
                return this.currentSticker.opacity;
            }
            return stickerDefaultState.opacity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "tintMode", {
        get: function () {
            if (this.currentSticker) {
                return this.currentSticker.tintMode;
            }
            return stickerDefaultState.tintMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "resizeMode", {
        get: function () {
            if (this.currentSticker) {
                return this.currentSticker.resizeMode;
            }
            return stickerDefaultState.resizeMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "tintable", {
        get: function () {
            if (this.currentSticker) {
                return this.currentSticker.tintMode === 'solid';
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "tintColor", {
        get: function () {
            if (this.currentSticker) {
                return this.currentSticker.tintColor;
            }
            return stickerDefaultState.tintColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "config", {
        get: function () {
            return this.editor.configStore.config[Tool.STICKER];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "locale", {
        get: function () {
            return this.editor.configStore.locale[Tool.STICKER];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "localeColor", {
        get: function () {
            return this.editor.configStore.locale.common.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "selectedCategoryIdentifier", {
        get: function () {
            return this.selectedCategory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "entities", {
        get: function () {
            return this.entityManager.getEntities(this.selectedCategoryIdentifier);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "categories", {
        get: function () {
            return this.entityManager.getCategories(this.selectedCategoryIdentifier);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StickerToolStore.prototype, "flattenCategories", {
        get: function () {
            return this.config.flattenCategories;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        observable
    ], StickerToolStore.prototype, "selectedCategory", void 0);
    __decorate([
        action
    ], StickerToolStore.prototype, "selectLast", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "add", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "duplicate", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "bringToFront", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "flipHorizontally", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "delete", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "updateStateFromHistory", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "setState", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "changeOpacity", void 0);
    __decorate([
        action
    ], StickerToolStore.prototype, "changeTintColor", void 0);
    __decorate([
        action
    ], StickerToolStore.prototype, "addFiles", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "addCustomStickerAsset", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "toggleCategorySelection", null);
    __decorate([
        action
    ], StickerToolStore.prototype, "pureReset", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "isStickerSelected", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "activeTintColor", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "isCustomStickerEnabled", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "customStickerTintMode", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "currentSticker", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "identifier", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "id", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "opacity", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "tintMode", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "resizeMode", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "tintable", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "tintColor", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "config", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "locale", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "localeColor", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "selectedCategoryIdentifier", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "entities", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "categories", null);
    __decorate([
        computed
    ], StickerToolStore.prototype, "flattenCategories", null);
    return StickerToolStore;
}());

document.onkeydown = function (e) {
    if (e.keyCode === 13 && document.activeElement) {
        document.activeElement.click();
    }
};

var EditorApi = /** @class */ (function (_super) {
    __extends(EditorApi, _super);
    function EditorApi(config, container) {
        var _this = _super.call(this) || this;
        _this.dispose = function () {
            if (_this.container) {
                ReactDOM.unmountComponentAtNode(_this.container);
                _this.removeAllListeners(UIEvent.EXPORT);
                // this.removeAllListeners(UIEvent.CLOSE)
                _this.removeAllListeners(UIEvent.HISTORY_CHANGE);
                _this.removeAllListeners(UIEvent.EDITOR_READY);
            }
        };
        _this.serialize = function (options) {
            return _this.editor.serialize(options);
        };
        _this.deserialize = function (data) {
            return _this.editor.deserialize(data);
        };
        _this.export = function (options) {
            return _this.editor.export(options);
        };
        _this.close = function () {
            return _this.editor.close();
        };
        _this.setImage = function (image) {
            return _this.editor.setImage(image);
        };
        _this.container = container;
        _this.editor = new Editor(__assign({}, config));
        _this.editor.configStore.events.on(UIEvent.EXPORT, function (imageData) {
            _this.emit(UIEvent.EXPORT, imageData);
        });
        _this.editor.configStore.events.on(UIEvent.CLOSE, function () {
            _this.dispose();
            _this.emit(UIEvent.CLOSE);
        });
        _this.editor.configStore.events.on(UIEvent.HISTORY_CHANGE, function () {
            _this.emit(UIEvent.HISTORY_CHANGE);
        });
        return _this;
    }
    return EditorApi;
}(EventEmitter));
var PhotoEditorSDKUIClass = /** @class */ (function () {
    function PhotoEditorSDKUIClass() {
        this.container = null;
    }
    PhotoEditorSDKUIClass.prototype.init = function (config) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.container =
                typeof config.container === 'string' ? document.querySelector(config.container) : config.container;
            if (_this.container) {
                _this.editorApi = new EditorApi(config, _this.container);
                ReactDOM.render(React.createElement(UI, { editor: _this.editorApi.editor }), _this.container);
                _this.editorApi.editor.configStore.events.on(UIEvent.EDITOR_READY, function () {
                    setTimeout(function () {
                        _this.editorApi.emit(UIEvent.EDITOR_READY);
                    }, 0);
                    resolve(_this.editorApi);
                });
            }
            else {
                reject(new Error('Provide a container'));
            }
        });
    };
    return PhotoEditorSDKUIClass;
}());
var UI = /** @class */ (function (_super) {
    __extends(UI, _super);
    function UI() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.UIComponent = null;
        return _this;
    }
    UI.prototype.componentDidMount = function () {
        var _this = this;
        this.editor = this.props.editor;
        this.storeProps = {
            filterTool: this.editor.filterToolStore,
            focusTool: this.editor.focusToolStore,
            adjustmentsTool: this.editor.adjustmentsToolStore,
            overlayTool: this.editor.overlayToolStore,
            frameTool: this.editor.frameToolStore,
            brushTool: this.editor.brushToolStore,
            transformTool: this.editor.transformToolStore,
            scale: this.editor.scale,
            sprite: this.editor.spriteStore,
            stickerTool: this.editor.spriteStore.stickerToolStore,
            textTool: this.editor.spriteStore.textToolStore,
            textDesignTool: this.editor.spriteStore.textDesignToolStore,
            library: this.editor.libraryStore,
            modal: this.editor.modalStore,
            snapping: this.editor.snappingStore,
            config: this.editor.configStore,
            active: this.editor.activeStore,
            canvas: this.editor.canvasStore,
            history: this.editor.historyStore,
            editor: this.editor,
        };
        if (this.editor.configStore.config.layout === 'basic') {
            import('./index-1427f247.js').then(function (_a) {
                var BasicUI = _a.BasicUI;
                _this.UIComponent = BasicUI;
                _this.forceUpdate();
            });
        }
        else {
            Promise.resolve().then(function () { return index$1; }).then(function (_a) {
                var AdvancedUI = _a.AdvancedUI;
                _this.UIComponent = AdvancedUI;
                _this.forceUpdate();
            });
        }
    };
    UI.prototype.componentWillUnmount = function () {
        this.editor.engine.dispose();
        this.editor.configStore.events.removeAllListeners(UIEvent.EXPORT);
        this.editor.configStore.events.removeAllListeners(UIEvent.CLOSE);
        this.editor.configStore.events.removeAllListeners(UIEvent.HISTORY_CHANGE);
        this.editor.configStore.events.removeAllListeners(UIEvent.EDITOR_READY);
    };
    UI.prototype.render = function () {
        if (this.editor) {
            var UiComponent = this.UIComponent;
            return this.storeProps && UiComponent ? React.createElement(UiComponent, { editor: this.editor, storeProps: this.storeProps }) : null;
        }
        return null;
    };
    return UI;
}(React.Component));
var PhotoEditorSDKUI = {
    init: function (config) {
        var ui = new PhotoEditorSDKUIClass();
        return ui.init(config);
    },
};

var PhotoEditorSDKUIComponent = /** @class */ (function (_super) {
    __extends(PhotoEditorSDKUIComponent, _super);
    function PhotoEditorSDKUIComponent(props) {
        var _this = _super.call(this, props) || this;
        _this.ui = new EventEmitter();
        _this.serialize = function (options) {
            return _this.editor.serialize(options);
        };
        _this.deserialize = function (data) {
            return _this.editor.deserialize(data);
        };
        _this.export = function (options) {
            return _this.editor.export(options);
        };
        _this.close = function () {
            return _this.editor.close();
        };
        _this.setImage = function (image) {
            return _this.editor.setImage(image);
        };
        _this.editor = new Editor(__assign({}, props));
        _this.editor.configStore.events.on(UIEvent.EXPORT, function (imageData) {
            _this.ui.emit(UIEvent.EXPORT, imageData);
        });
        _this.editor.configStore.events.on(UIEvent.CLOSE, function () {
            _this.componentWillUnmount();
            _this.ui.emit(UIEvent.CLOSE);
        });
        _this.editor.configStore.events.on(UIEvent.HISTORY_CHANGE, function () {
            _this.ui.emit(UIEvent.HISTORY_CHANGE);
        });
        _this.editor.configStore.events.on(UIEvent.EDITOR_READY, function () {
            _this.ui.emit(UIEvent.EDITOR_READY);
        });
        _this.storeProps = {
            filterTool: _this.editor.filterToolStore,
            focusTool: _this.editor.focusToolStore,
            adjustmentsTool: _this.editor.adjustmentsToolStore,
            overlayTool: _this.editor.overlayToolStore,
            frameTool: _this.editor.frameToolStore,
            brushTool: _this.editor.brushToolStore,
            transformTool: _this.editor.transformToolStore,
            scale: _this.editor.scale,
            sprite: _this.editor.spriteStore,
            stickerTool: _this.editor.spriteStore.stickerToolStore,
            textTool: _this.editor.spriteStore.textToolStore,
            textDesignTool: _this.editor.spriteStore.textDesignToolStore,
            library: _this.editor.libraryStore,
            modal: _this.editor.modalStore,
            snapping: _this.editor.snappingStore,
            config: _this.editor.configStore,
            active: _this.editor.activeStore,
            canvas: _this.editor.canvasStore,
            history: _this.editor.historyStore,
            editor: _this.editor,
        };
        if (_this.editor.configStore.config.layout === 'basic') {
            import('./index-1427f247.js').then(function (_a) {
                var BasicUI = _a.BasicUI;
                _this.UIComponent = BasicUI;
                _this.forceUpdate();
            });
        }
        else {
            Promise.resolve().then(function () { return index$1; }).then(function (_a) {
                var AdvancedUI = _a.AdvancedUI;
                _this.UIComponent = AdvancedUI;
                _this.forceUpdate();
            });
        }
        return _this;
    }
    PhotoEditorSDKUIComponent.prototype.componentWillUnmount = function () {
        this.ui.removeAllListeners(UIEvent.EXPORT);
        // this.ui.removeAllListeners(UIEvent.CLOSE)
        this.ui.removeAllListeners(UIEvent.HISTORY_CHANGE);
        this.ui.removeAllListeners(UIEvent.EDITOR_READY);
    };
    PhotoEditorSDKUIComponent.prototype.render = function () {
        if (this.editor) {
            var UiComponent = this.UIComponent;
            // @ts-ignore
            return this.storeProps && UiComponent ? React.createElement(UiComponent, { editor: this.editor, storeProps: this.storeProps }) : null;
        }
        return null;
    };
    return PhotoEditorSDKUIComponent;
}(React.Component));

/** @license mobx-react v5.4.4
 * index.module.js
 *
 * Copyright (c) 2015 Michel Weststrate.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

// These functions can be stubbed out in specific environments

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var reactIs_production_min = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports,"__esModule",{value:!0});
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,r=b?Symbol.for("react.memo"):
60115,t=b?Symbol.for("react.lazy"):60116;function u(a){if("object"===typeof a&&null!==a){var q=a.$$typeof;switch(q){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case h:return a;default:return q}}case d:return q}}}function v(a){return u(a)===m}exports.typeOf=u;exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;
exports.Profiler=g;exports.Portal=d;exports.StrictMode=f;exports.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n)};exports.isAsyncMode=function(a){return v(a)||u(a)===l};exports.isConcurrentMode=v;exports.isContextConsumer=function(a){return u(a)===k};exports.isContextProvider=function(a){return u(a)===h};
exports.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return u(a)===n};exports.isFragment=function(a){return u(a)===e};exports.isProfiler=function(a){return u(a)===g};exports.isPortal=function(a){return u(a)===d};exports.isStrictMode=function(a){return u(a)===f};
});

unwrapExports(reactIs_production_min);
var reactIs_production_min_1 = reactIs_production_min.typeOf;
var reactIs_production_min_2 = reactIs_production_min.AsyncMode;
var reactIs_production_min_3 = reactIs_production_min.ConcurrentMode;
var reactIs_production_min_4 = reactIs_production_min.ContextConsumer;
var reactIs_production_min_5 = reactIs_production_min.ContextProvider;
var reactIs_production_min_6 = reactIs_production_min.Element;
var reactIs_production_min_7 = reactIs_production_min.ForwardRef;
var reactIs_production_min_8 = reactIs_production_min.Fragment;
var reactIs_production_min_9 = reactIs_production_min.Profiler;
var reactIs_production_min_10 = reactIs_production_min.Portal;
var reactIs_production_min_11 = reactIs_production_min.StrictMode;
var reactIs_production_min_12 = reactIs_production_min.isValidElementType;
var reactIs_production_min_13 = reactIs_production_min.isAsyncMode;
var reactIs_production_min_14 = reactIs_production_min.isConcurrentMode;
var reactIs_production_min_15 = reactIs_production_min.isContextConsumer;
var reactIs_production_min_16 = reactIs_production_min.isContextProvider;
var reactIs_production_min_17 = reactIs_production_min.isElement;
var reactIs_production_min_18 = reactIs_production_min.isForwardRef;
var reactIs_production_min_19 = reactIs_production_min.isFragment;
var reactIs_production_min_20 = reactIs_production_min.isProfiler;
var reactIs_production_min_21 = reactIs_production_min.isPortal;
var reactIs_production_min_22 = reactIs_production_min.isStrictMode;

var reactIs = createCommonjsModule(function (module) {

{
  module.exports = reactIs_production_min;
}
});

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};

var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        var targetStatics = TYPE_STATICS[targetComponent['$$typeof']] || REACT_STATICS;
        var sourceStatics = TYPE_STATICS[sourceComponent['$$typeof']] || REACT_STATICS;

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

var hoistNonReactStatics_cjs = hoistNonReactStatics;

var EventEmitter$1 =
/*#__PURE__*/
function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    this.listeners = [];
  }

  _createClass(EventEmitter, [{
    key: "on",
    value: function on(cb) {
      var _this = this;

      this.listeners.push(cb);
      return function () {
        var index = _this.listeners.indexOf(cb);

        if (index !== -1) _this.listeners.splice(index, 1);
      };
    }
  }, {
    key: "emit",
    value: function emit(data) {
      this.listeners.forEach(function (fn) {
        return fn(data);
      });
    }
  }]);

  return EventEmitter;
}();

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    for (var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
      rest[_key - 6] = arguments[_key];
    }

    return untracked(function () {
      componentName = componentName || "<<anonymous>>";
      propFullName = propFullName || propName;

      if (props[propName] == null) {
        if (isRequired) {
          var actual = props[propName] === null ? "null" : "undefined";
          return new Error("The " + location + " `" + propFullName + "` is marked as required " + "in `" + componentName + "`, but its value is `" + actual + "`.");
        }

        return null;
      } else {
        return validate.apply(void 0, [props, propName, componentName, location, propFullName].concat(rest));
      }
    });
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);
  return chainedCheckType;
} // Copied from React.PropTypes


function isSymbol$2(propType, propValue) {
  // Native Symbol.
  if (propType === "symbol") {
    return true;
  } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'


  if (propValue["@@toStringTag"] === "Symbol") {
    return true;
  } // Fallback for non-spec compliant Symbols which are polyfilled.


  if (typeof Symbol === "function" && propValue instanceof Symbol) {
    return true;
  }

  return false;
} // Copied from React.PropTypes


function getPropType(propValue) {
  var propType = _typeof(propValue);

  if (Array.isArray(propValue)) {
    return "array";
  }

  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return "object";
  }

  if (isSymbol$2(propType, propValue)) {
    return "symbol";
  }

  return propType;
} // This handles more types than `getPropType`. Only used for error messages.
// Copied from React.PropTypes


function getPreciseType(propValue) {
  var propType = getPropType(propValue);

  if (propType === "object") {
    if (propValue instanceof Date) {
      return "date";
    } else if (propValue instanceof RegExp) {
      return "regexp";
    }
  }

  return propType;
}

function createObservableTypeCheckerCreator(allowNativeType, mobxType) {
  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {
    return untracked(function () {
      if (allowNativeType) {
        if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;
      }

      var mobxChecker;

      switch (mobxType) {
        case "Array":
          mobxChecker = isObservableArray;
          break;

        case "Object":
          mobxChecker = isObservableObject;
          break;

        case "Map":
          mobxChecker = isObservableMap;
          break;

        default:
          throw new Error("Unexpected mobxType: ".concat(mobxType));
      }

      var propValue = props[propName];

      if (!mobxChecker(propValue)) {
        var preciseType = getPreciseType(propValue);
        var nativeTypeExpectationMessage = allowNativeType ? " or javascript `" + mobxType.toLowerCase() + "`" : "";
        return new Error("Invalid prop `" + propFullName + "` of type `" + preciseType + "` supplied to" + " `" + componentName + "`, expected `mobx.Observable" + mobxType + "`" + nativeTypeExpectationMessage + ".");
      }

      return null;
    });
  });
}

function createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {
  return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
      rest[_key2 - 5] = arguments[_key2];
    }

    return untracked(function () {
      if (typeof typeChecker !== "function") {
        return new Error("Property `" + propFullName + "` of component `" + componentName + "` has " + "invalid PropType notation.");
      }

      var error = createObservableTypeCheckerCreator(allowNativeType, "Array")(props, propName, componentName);
      if (error instanceof Error) return error;
      var propValue = props[propName];

      for (var i = 0; i < propValue.length; i++) {
        error = typeChecker.apply(void 0, [propValue, i, componentName, location, propFullName + "[" + i + "]"].concat(rest));
        if (error instanceof Error) return error;
      }

      return null;
    });
  });
}

var observableArray = createObservableTypeCheckerCreator(false, "Array");
var observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false);
var observableMap = createObservableTypeCheckerCreator(false, "Map");
var observableObject = createObservableTypeCheckerCreator(false, "Object");
var arrayOrObservableArray = createObservableTypeCheckerCreator(true, "Array");
var arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true);
var objectOrObservableObject = createObservableTypeCheckerCreator(true, "Object");

function isStateless(component) {
  // `function() {}` has prototype, but `() => {}` doesn't
  // `() => {}` via Babel has prototype too.
  return !(component.prototype && component.prototype.render);
}
var symbolId = 0;

function createSymbol(name) {
  if (typeof Symbol === "function") {
    return Symbol(name);
  }

  var symbol = "__$mobx-react ".concat(name, " (").concat(symbolId, ")");
  symbolId++;
  return symbol;
}

var createdSymbols = {};
function newSymbol(name) {
  if (!createdSymbols[name]) {
    createdSymbols[name] = createSymbol(name);
  }

  return createdSymbols[name];
}
var mobxMixins = newSymbol("patchMixins");
var mobxPatchedDefinition = newSymbol("patchedDefinition");

function getMixins(target, methodName) {
  var mixins = target[mobxMixins] = target[mobxMixins] || {};
  var methodMixins = mixins[methodName] = mixins[methodName] || {};
  methodMixins.locks = methodMixins.locks || 0;
  methodMixins.methods = methodMixins.methods || [];
  return methodMixins;
}

function wrapper(realMethod, mixins) {
  var _this = this;

  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls
  mixins.locks++;

  try {
    var retVal;

    if (realMethod !== undefined && realMethod !== null) {
      retVal = realMethod.apply(this, args);
    }

    return retVal;
  } finally {
    mixins.locks--;

    if (mixins.locks === 0) {
      mixins.methods.forEach(function (mx) {
        mx.apply(_this, args);
      });
    }
  }
}

function wrapFunction(realMethod, mixins) {
  var fn = function fn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));
  };

  return fn;
}

function patch(target, methodName) {
  var mixins = getMixins(target, methodName);

  for (var _len3 = arguments.length, mixinMethods = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
    mixinMethods[_key3 - 2] = arguments[_key3];
  }

  for (var _i = 0; _i < mixinMethods.length; _i++) {
    var mixinMethod = mixinMethods[_i];

    if (mixins.methods.indexOf(mixinMethod) < 0) {
      mixins.methods.push(mixinMethod);
    }
  }

  var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);

  if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {
    // already patched definition, do not repatch
    return;
  }

  var originalMethod = target[methodName];
  var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : undefined, mixins, originalMethod);
  Object.defineProperty(target, methodName, newDefinition);
}

function createDefinition(target, methodName, enumerable, mixins, originalMethod) {
  var _ref;

  var wrappedFunc = wrapFunction(originalMethod, mixins);
  return _ref = {}, _defineProperty(_ref, mobxPatchedDefinition, true), _defineProperty(_ref, "get", function get() {
    return wrappedFunc;
  }), _defineProperty(_ref, "set", function set(value) {
    if (this === target) {
      wrappedFunc = wrapFunction(value, mixins);
    } else {
      // when it is an instance of the prototype/a child prototype patch that particular case again separately
      // since we need to store separate values depending on wether it is the actual instance, the prototype, etc
      // e.g. the method for super might not be the same as the method for the prototype which might be not the same
      // as the method for the instance
      var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);
      Object.defineProperty(this, methodName, newDefinition);
    }
  }), _defineProperty(_ref, "configurable", true), _defineProperty(_ref, "enumerable", enumerable), _ref;
}

var injectorContextTypes = {
  mobxStores: objectOrObservableObject
};
Object.seal(injectorContextTypes);
var proxiedInjectorProps = {
  contextTypes: {
    get: function get() {
      return injectorContextTypes;
    },
    set: function set(_) {
      console.warn("Mobx Injector: you are trying to attach `contextTypes` on an component decorated with `inject` (or `observer`) HOC. Please specify the contextTypes on the wrapped component instead. It is accessible through the `wrappedComponent`");
    },
    configurable: true,
    enumerable: false
  },
  isMobxInjector: {
    value: true,
    writable: true,
    configurable: true,
    enumerable: true
  }
  /**
   * Store Injection
   */

};

function createStoreInjector(grabStoresFn, component, injectNames) {
  var displayName = "inject-" + (component.displayName || component.name || component.constructor && component.constructor.name || "Unknown");
  if (injectNames) displayName += "-with-" + injectNames;

  var Injector =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Injector, _Component);

    function Injector() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Injector);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Injector)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _this.storeRef = function (instance) {
        _this.wrappedInstance = instance;
      };

      return _this;
    }

    _createClass(Injector, [{
      key: "render",
      value: function render() {
        // Optimization: it might be more efficient to apply the mapper function *outside* the render method
        // (if the mapper is a function), that could avoid expensive(?) re-rendering of the injector component
        // See this test: 'using a custom injector is not too reactive' in inject.js
        var newProps = {};

        for (var key in this.props) {
          if (this.props.hasOwnProperty(key)) {
            newProps[key] = this.props[key];
          }
        }

        var additionalProps = grabStoresFn(this.context.mobxStores || {}, newProps, this.context) || {};

        for (var _key2 in additionalProps) {
          newProps[_key2] = additionalProps[_key2];
        }

        if (!isStateless(component)) {
          newProps.ref = this.storeRef;
        }

        return createElement(component, newProps);
      }
    }]);

    return Injector;
  }(Component); // Static fields from component should be visible on the generated Injector


  Injector.displayName = displayName;
  hoistNonReactStatics_cjs(Injector, component);
  Injector.wrappedComponent = component;
  Object.defineProperties(Injector, proxiedInjectorProps);
  return Injector;
}

function grabStoresByName(storeNames) {
  return function (baseStores, nextProps) {
    storeNames.forEach(function (storeName) {
      if (storeName in nextProps // prefer props over stores
      ) return;
      if (!(storeName in baseStores)) throw new Error("MobX injector: Store '" + storeName + "' is not available! Make sure it is provided by some Provider");
      nextProps[storeName] = baseStores[storeName];
    });
    return nextProps;
  };
}
/**
 * higher order component that injects stores to a child.
 * takes either a varargs list of strings, which are stores read from the context,
 * or a function that manually maps the available stores from the context to props:
 * storesToProps(mobxStores, props, context) => newProps
 */


function inject()
/* fn(stores, nextProps) or ...storeNames */
{
  var grabStoresFn;

  if (typeof arguments[0] === "function") {
    grabStoresFn = arguments[0];
    return function (componentClass) {
      var injected = createStoreInjector(grabStoresFn, componentClass);
      injected.isMobxInjector = false; // supress warning
      // mark the Injector as observer, to make it react to expressions in `grabStoresFn`,
      // see #111

      injected = observer(injected);
      injected.isMobxInjector = true; // restore warning

      return injected;
    };
  } else {
    var storeNames = [];

    for (var i = 0; i < arguments.length; i++) {
      storeNames[i] = arguments[i];
    }

    grabStoresFn = grabStoresByName(storeNames);
    return function (componentClass) {
      return createStoreInjector(grabStoresFn, componentClass, storeNames.join("-"));
    };
  }
}

var mobxAdminProperty = $mobx ;
var mobxIsUnmounted = newSymbol("isUnmounted");
/**
 * dev tool support
 */

var isDevtoolsEnabled = false;
var warnedAboutObserverInjectDeprecation = false; // WeakMap<Node, Object>;

var componentByNodeRegistry = typeof WeakMap !== "undefined" ? new WeakMap() : undefined;
var renderReporter = new EventEmitter$1();
var skipRenderKey = newSymbol("skipRender");
var isForcingUpdateKey = newSymbol("isForcingUpdate"); // Using react-is had some issues (and operates on elements, not on types), see #608 / #609

var ReactForwardRefSymbol = typeof forwardRef === "function" && forwardRef(function (_props, _ref) {})["$$typeof"];
/**
 * Helper to set `prop` to `this` as non-enumerable (hidden prop)
 * @param target
 * @param prop
 * @param value
 */

function setHiddenProp(target, prop, value) {
  if (!Object.hasOwnProperty.call(target, prop)) {
    Object.defineProperty(target, prop, {
      enumerable: false,
      configurable: true,
      writable: true,
      value: value
    });
  } else {
    target[prop] = value;
  }
}

function findDOMNode$2(component) {
  if (findDOMNode$1) {
    try {
      return findDOMNode$1(component);
    } catch (e) {
      // findDOMNode will throw in react-test-renderer, see:
      // See https://github.com/mobxjs/mobx-react/issues/216
      // Is there a better heuristic?
      return null;
    }
  }

  return null;
}

function reportRendering(component) {
  var node = findDOMNode$2(component);
  if (node && componentByNodeRegistry) componentByNodeRegistry.set(node, component);
  renderReporter.emit({
    event: "render",
    renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,
    totalTime: Date.now() - component.__$mobRenderStart,
    component: component,
    node: node
  });
}

function trackComponents() {
  if (typeof WeakMap === "undefined") throw new Error("[mobx-react] tracking components is not supported in this browser.");
  if (!isDevtoolsEnabled) isDevtoolsEnabled = true;
}
/**
 * Errors reporter
 */

var errorsReporter = new EventEmitter$1();
/**
 * Utilities
 */

function patch$1(target, funcName) {
  patch(target, funcName, reactiveMixin[funcName]);
}

function shallowEqual(objA, objB) {
  //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
  if (is(objA, objB)) return true;

  if (_typeof(objA) !== "object" || objA === null || _typeof(objB) !== "object" || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

function is(x, y) {
  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function makeComponentReactive(render) {
  var _this2 = this;

  function reactiveRender() {
    var _this = this;

    isRenderingPending = false;
    var exception = undefined;
    var rendering = undefined;
    reaction.track(function () {
      if (isDevtoolsEnabled) {
        _this.__$mobRenderStart = Date.now();
      }

      try {
        rendering = allowStateChanges(false, baseRender);
      } catch (e) {
        exception = e;
      }

      if (isDevtoolsEnabled) {
        _this.__$mobRenderEnd = Date.now();
      }
    });

    if (exception) {
      errorsReporter.emit(exception);
      throw exception;
    }

    return rendering;
  } // Generate friendly name for debugging


  var initialName = this.displayName || this.name || this.constructor && (this.constructor.displayName || this.constructor.name) || "<component>";
  var rootNodeID = this._reactInternalInstance && this._reactInternalInstance._rootNodeID || this._reactInternalInstance && this._reactInternalInstance._debugID || this._reactInternalFiber && this._reactInternalFiber._debugID;
  /**
   * If props are shallowly modified, react will render anyway,
   * so atom.reportChanged() should not result in yet another re-render
   */

  setHiddenProp(this, skipRenderKey, false);
  /**
   * forceUpdate will re-assign this.props. We don't want that to cause a loop,
   * so detect these changes
   */

  setHiddenProp(this, isForcingUpdateKey, false); // wire up reactive render

  var baseRender = render.bind(this);
  var isRenderingPending = false;
  var reaction = new Reaction("".concat(initialName, "#").concat(rootNodeID, ".render()"), function () {
    if (!isRenderingPending) {
      // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)
      // This unidiomatic React usage but React will correctly warn about this so we continue as usual
      // See #85 / Pull #44
      isRenderingPending = true;
      if (typeof _this2.componentWillReact === "function") _this2.componentWillReact(); // TODO: wrap in action?

      if (_this2[mobxIsUnmounted] !== true) {
        // If we are unmounted at this point, componentWillReact() had a side effect causing the component to unmounted
        // TODO: remove this check? Then react will properly warn about the fact that this should not happen? See #73
        // However, people also claim this might happen during unit tests..
        var hasError = true;

        try {
          setHiddenProp(_this2, isForcingUpdateKey, true);
          if (!_this2[skipRenderKey]) Component.prototype.forceUpdate.call(_this2);
          hasError = false;
        } finally {
          setHiddenProp(_this2, isForcingUpdateKey, false);
          if (hasError) reaction.dispose();
        }
      }
    }
  });
  reaction.reactComponent = this;
  reactiveRender[mobxAdminProperty] = reaction;
  this.render = reactiveRender;
  return reactiveRender.call(this);
}
/**
 * ReactiveMixin
 */


var reactiveMixin = {
  componentWillUnmount: function componentWillUnmount() {
    this.render[mobxAdminProperty] && this.render[mobxAdminProperty].dispose();
    this[mobxIsUnmounted] = true;

    if (isDevtoolsEnabled) {
      var node = findDOMNode$2(this);

      if (node && componentByNodeRegistry) {
        componentByNodeRegistry.delete(node);
      }

      renderReporter.emit({
        event: "destroy",
        component: this,
        node: node
      });
    }
  },
  componentDidMount: function componentDidMount() {
    if (isDevtoolsEnabled) {
      reportRendering(this);
    }
  },
  componentDidUpdate: function componentDidUpdate() {
    if (isDevtoolsEnabled) {
      reportRendering(this);
    }
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {


    if (this.state !== nextState) {
      return true;
    } // update if props are shallowly not equal, inspired by PureRenderMixin
    // we could return just 'false' here, and avoid the `skipRender` checks etc
    // however, it is nicer if lifecycle events are triggered like usually,
    // so we return true here if props are shallowly modified.


    return !shallowEqual(this.props, nextProps);
  }
};

function makeObservableProp(target, propName) {
  var valueHolderKey = newSymbol("reactProp_".concat(propName, "_valueHolder"));
  var atomHolderKey = newSymbol("reactProp_".concat(propName, "_atomHolder"));

  function getAtom() {
    if (!this[atomHolderKey]) {
      setHiddenProp(this, atomHolderKey, createAtom("reactive " + propName));
    }

    return this[atomHolderKey];
  }

  Object.defineProperty(target, propName, {
    configurable: true,
    enumerable: true,
    get: function get() {
      getAtom.call(this).reportObserved();
      return this[valueHolderKey];
    },
    set: function set(v) {
      if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {
        setHiddenProp(this, valueHolderKey, v);
        setHiddenProp(this, skipRenderKey, true);
        getAtom.call(this).reportChanged();
        setHiddenProp(this, skipRenderKey, false);
      } else {
        setHiddenProp(this, valueHolderKey, v);
      }
    }
  });
}
/**
 * Observer function / decorator
 */


function observer(arg1, arg2) {
  if (typeof arg1 === "string") {
    throw new Error("Store names should be provided as array");
  }

  if (Array.isArray(arg1)) {
    // TODO: remove in next major
    // component needs stores
    if (!warnedAboutObserverInjectDeprecation) {
      warnedAboutObserverInjectDeprecation = true;
      console.warn('Mobx observer: Using observer to inject stores is deprecated since 4.0. Use `@inject("store1", "store2") @observer ComponentClass` or `inject("store1", "store2")(observer(componentClass))` instead of `@observer(["store1", "store2"]) ComponentClass`');
    }

    if (!arg2) {
      // invoked as decorator
      return function (componentClass) {
        return observer(arg1, componentClass);
      };
    } else {
      return inject.apply(null, arg1)(observer(arg2));
    }
  }

  var componentClass = arg1;

  if (componentClass.isMobxInjector === true) {
    console.warn("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'");
  }

  if (componentClass.__proto__ === PureComponent) {
    console.warn("Mobx observer: You are using 'observer' on React.PureComponent. These two achieve two opposite goals and should not be used together");
  } // Unwrap forward refs into `<Observer>` component
  // we need to unwrap the render, because it is the inner render that needs to be tracked,
  // not the ForwardRef HoC


  if (ReactForwardRefSymbol && componentClass["$$typeof"] === ReactForwardRefSymbol) {
    var _baseRender = componentClass.render;
    if (typeof _baseRender !== "function") throw new Error("render property of ForwardRef was not a function"); // TODO: do we need to hoist statics from baseRender to the forward ref?

    return forwardRef(function ObserverForwardRef() {
      var _arguments = arguments;
      return React.createElement(Observer, null, function () {
        return _baseRender.apply(undefined, _arguments);
      });
    });
  } // Stateless function component:
  // If it is function but doesn't seem to be a react class constructor,
  // wrap it to a react class automatically


  if (typeof componentClass === "function" && (!componentClass.prototype || !componentClass.prototype.render) && !componentClass.isReactClass && !Component.isPrototypeOf(componentClass)) {
    var _class, _temp;

    var observerComponent = observer((_temp = _class =
    /*#__PURE__*/
    function (_Component) {
      _inherits(_class, _Component);

      function _class() {
        _classCallCheck(this, _class);

        return _possibleConstructorReturn(this, _getPrototypeOf(_class).apply(this, arguments));
      }

      _createClass(_class, [{
        key: "render",
        value: function render() {
          return componentClass.call(this, this.props, this.context);
        }
      }]);

      return _class;
    }(Component), _class.displayName = componentClass.displayName || componentClass.name, _class.contextTypes = componentClass.contextTypes, _class.propTypes = componentClass.propTypes, _class.defaultProps = componentClass.defaultProps, _temp));
    hoistNonReactStatics_cjs(observerComponent, componentClass);
    return observerComponent;
  }

  if (!componentClass) {
    throw new Error("Please pass a valid component to 'observer'");
  }

  var target = componentClass.prototype || componentClass;
  mixinLifecycleEvents(target);
  componentClass.isMobXReactObserver = true;
  makeObservableProp(target, "props");
  makeObservableProp(target, "state");
  var baseRender = target.render;

  target.render = function () {
    return makeComponentReactive.call(this, baseRender);
  };

  return componentClass;
}

function mixinLifecycleEvents(target) {
  ["componentDidMount", "componentWillUnmount", "componentDidUpdate"].forEach(function (funcName) {
    patch$1(target, funcName);
  });

  if (!target.shouldComponentUpdate) {
    target.shouldComponentUpdate = reactiveMixin.shouldComponentUpdate;
  } else {
    if (target.shouldComponentUpdate !== reactiveMixin.shouldComponentUpdate) {
      // TODO: make throw in next major
      console.warn("Use `shouldComponentUpdate` in an `observer` based component breaks the behavior of `observer` and might lead to unexpected results. Manually implementing `sCU` should not be needed when using mobx-react.");
    }
  }
}

var Observer = observer(function (_ref2) {
  var children = _ref2.children,
      observerInject = _ref2.inject,
      render = _ref2.render;
  var component = children || render;

  if (typeof component === "undefined") {
    return null;
  }

  if (!observerInject) {
    return component();
  } // TODO: remove in next major


  console.warn("<Observer inject=.../> is no longer supported. Please use inject on the enclosing component instead");
  var InjectComponent = inject(observerInject)(component);
  return React.createElement(InjectComponent, null);
});
Observer.displayName = "Observer";

var ObserverPropsCheck = function ObserverPropsCheck(props, key, componentName, location, propFullName) {
  var extraKey = key === "children" ? "render" : "children";

  if (typeof props[key] === "function" && typeof props[extraKey] === "function") {
    return new Error("Invalid prop,do not use children and render in the same time in`" + componentName);
  }

  if (typeof props[key] === "function" || typeof props[extraKey] === "function") {
    return;
  }

  return new Error("Invalid prop `" + propFullName + "` of type `" + _typeof(props[key]) + "` supplied to" + " `" + componentName + "`, expected `function`.");
};

Observer.propTypes = {
  render: ObserverPropsCheck,
  children: ObserverPropsCheck
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function componentWillMount() {
  // Call this.constructor.gDSFP to support sub-classes.
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== undefined) {
    this.setState(state);
  }
}

function componentWillReceiveProps(nextProps) {
  // Call this.constructor.gDSFP to support sub-classes.
  // Use the setState() updater to ensure state isn't stale in certain edge cases.
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== undefined ? state : null;
  }
  // Binding "this" is important for shallow renderer support.
  this.setState(updater.bind(this));
}

function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      prevProps,
      prevState
    );
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}

// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;

function polyfill(Component$$1) {
  var prototype = Component$$1.prototype;

  if (!prototype || !prototype.isReactComponent) {
    throw new Error('Can only polyfill class components');
  }

  if (
    typeof Component$$1.getDerivedStateFromProps !== 'function' &&
    typeof prototype.getSnapshotBeforeUpdate !== 'function'
  ) {
    return Component$$1;
  }

  // If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Error if any of these lifecycles are present,
  // Because they would work differently between older and newer (16.3+) versions of React.
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === 'function') {
    foundWillMountName = 'componentWillMount';
  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
    foundWillMountName = 'UNSAFE_componentWillMount';
  }
  if (typeof prototype.componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'componentWillReceiveProps';
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
  }
  if (typeof prototype.componentWillUpdate === 'function') {
    foundWillUpdateName = 'componentWillUpdate';
  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
    foundWillUpdateName = 'UNSAFE_componentWillUpdate';
  }
  if (
    foundWillMountName !== null ||
    foundWillReceivePropsName !== null ||
    foundWillUpdateName !== null
  ) {
    var componentName = Component$$1.displayName || Component$$1.name;
    var newApiName =
      typeof Component$$1.getDerivedStateFromProps === 'function'
        ? 'getDerivedStateFromProps()'
        : 'getSnapshotBeforeUpdate()';

    throw Error(
      'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' +
        componentName +
        ' uses ' +
        newApiName +
        ' but also contains the following legacy lifecycles:' +
        (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') +
        (foundWillReceivePropsName !== null
          ? '\n  ' + foundWillReceivePropsName
          : '') +
        (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') +
        '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' +
        'https://fb.me/react-async-component-lifecycle-hooks'
    );
  }

  // React <= 16.2 does not support static getDerivedStateFromProps.
  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
  // Newer versions of React will ignore these lifecycles if gDSFP exists.
  if (typeof Component$$1.getDerivedStateFromProps === 'function') {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }

  // React <= 16.2 does not support getSnapshotBeforeUpdate.
  // As a workaround, use cWU to invoke the new lifecycle.
  // Newer versions of React will ignore that lifecycle if gSBU exists.
  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
    if (typeof prototype.componentDidUpdate !== 'function') {
      throw new Error(
        'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'
      );
    }

    prototype.componentWillUpdate = componentWillUpdate;

    var componentDidUpdate = prototype.componentDidUpdate;

    prototype.componentDidUpdate = function componentDidUpdatePolyfill(
      prevProps,
      prevState,
      maybeSnapshot
    ) {
      // 16.3+ will not execute our will-update method;
      // It will pass a snapshot value to did-update though.
      // Older versions will require our polyfilled will-update value.
      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
      // Because for <= 15.x versions this might be a "prevContext" object.
      // We also can't just check "__reactInternalSnapshot",
      // Because get-snapshot might return a falsy value.
      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
      var snapshot = this.__reactInternalSnapshotFlag
        ? this.__reactInternalSnapshot
        : maybeSnapshot;

      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }

  return Component$$1;
}

var specialReactKeys = {
  children: true,
  key: true,
  ref: true
};

var Provider =
/*#__PURE__*/
function (_Component) {
  _inherits(Provider, _Component);

  function Provider(props, context) {
    var _this;

    _classCallCheck(this, Provider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Provider).call(this, props, context));
    _this.state = {};
    copyStores(props, _this.state);
    return _this;
  }

  _createClass(Provider, [{
    key: "render",
    value: function render() {
      return Children.only(this.props.children);
    }
  }, {
    key: "getChildContext",
    value: function getChildContext() {
      var stores = {}; // inherit stores

      copyStores(this.context.mobxStores, stores); // add own stores

      copyStores(this.props, stores);
      return {
        mobxStores: stores
      };
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (!nextProps) return null;
      if (!prevState) return nextProps; // Maybe this warning is too aggressive?

      if (Object.keys(nextProps).filter(validStoreName).length !== Object.keys(prevState).filter(validStoreName).length) console.warn("MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children");
      if (!nextProps.suppressChangedStoreWarning) for (var key in nextProps) {
        if (validStoreName(key) && prevState[key] !== nextProps[key]) console.warn("MobX Provider: Provided store '" + key + "' has changed. Please avoid replacing stores as the change might not propagate to all children");
      }
      return nextProps;
    }
  }]);

  return Provider;
}(Component);

Provider.contextTypes = {
  mobxStores: objectOrObservableObject
};
Provider.childContextTypes = {
  mobxStores: objectOrObservableObject.isRequired
};

function copyStores(from, to) {
  if (!from) return;

  for (var key in from) {
    if (validStoreName(key)) to[key] = from[key];
  }
}

function validStoreName(key) {
  return !specialReactKeys[key] && key !== "suppressChangedStoreWarning";
} // TODO: kill in next major


polyfill(Provider);

var storeKey = newSymbol("disposeOnUnmount");

if (!Component) throw new Error("mobx-react requires React to be available");
if (!spy) throw new Error("mobx-react requires mobx to be available");
if (typeof unstable_batchedUpdates === "function") configure({
  reactionScheduler: unstable_batchedUpdates
});

if ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "undefined" ? "undefined" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === "object") {
  var mobx = {
    spy: spy,
    extras: {
      getDebugName: getDebugName
    }
  };
  var mobxReact = {
    renderReporter: renderReporter,
    componentByNodeRegistry: componentByNodeRegistry,
    componentByNodeRegistery: componentByNodeRegistry,
    trackComponents: trackComponents
  };

  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobxReact(mobxReact, mobx);
}

var Focused = css(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  &:focus {\n    outline: none;\n    box-shadow: 0 0 2px ", ";\n  }\n  &:-moz-focusring {\n    outline: none;\n    box-shadow: 0 0 2px ", ";\n  }\n"], ["\n  &:focus {\n    outline: none;\n    box-shadow: 0 0 2px ", ";\n  }\n  &:-moz-focusring {\n    outline: none;\n    box-shadow: 0 0 2px ", ";\n  }\n"])), function (props) { return props.theme.focusOutlineColor; }, function (props) { return props.theme.focusOutlineColor; });
var templateObject_1;

/** For accessibility purposes, used for visually hidden elements */
var VisuallyHidden = css(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["\n  position: absolute !important;\n  height: 1px;\n  width: 1px;\n  overflow: hidden;\n  clip: rect(1px 1px 1px 1px); /* IE6, IE7 */\n  clip: rect(1px, 1px, 1px, 1px);\n"], ["\n  position: absolute !important;\n  height: 1px;\n  width: 1px;\n  overflow: hidden;\n  clip: rect(1px 1px 1px 1px); /* IE6, IE7 */\n  clip: rect(1px, 1px, 1px, 1px);\n"
    /** The actual scrollbar is hidden, insted there is a scrollbar shown consistant across browsers */
])));
/** The actual scrollbar is hidden, insted there is a scrollbar shown consistant across browsers */
var HiddenScrollbar = css(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  -webkit-overflow-scrolling: touch;\n  &::-webkit-scrollbar {\n    display: none;\n    /* Safari */\n    -webkit-appearance: none; /* stylelint-disable-line */\n    width: 0;\n    height: 0;\n  }\n  -ms-overflow-style: none; /* IE 11 */\n  scrollbar-width: none; /* Firefox 64 */\n"], ["\n  -webkit-overflow-scrolling: touch;\n  &::-webkit-scrollbar {\n    display: none;\n    /* Safari */\n    -webkit-appearance: none; /* stylelint-disable-line */\n    width: 0;\n    height: 0;\n  }\n  -ms-overflow-style: none; /* IE 11 */\n  scrollbar-width: none; /* Firefox 64 */\n"])));
var templateObject_1$1, templateObject_2;

var ripple = keyframes(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject(["\nfrom {\n  opacity: 1;\n  transform: scale(0);\n}\nto {\n  opacity: 0;\n  transform: scale(10);\n}\n"], ["\nfrom {\n  opacity: 1;\n  transform: scale(0);\n}\nto {\n  opacity: 0;\n  transform: scale(10);\n}\n"])));
var templateObject_1$2;

var scale = keyframes(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject(["\n  0% {\n    opacity: 0;\n    transform: scale(0.9);\n  }\n  100% {\n    opacity: 1;\n    transform: scale(1);\n  }\n"], ["\n  0% {\n    opacity: 0;\n    transform: scale(0.9);\n  }\n  100% {\n    opacity: 1;\n    transform: scale(1);\n  }\n"])));
var templateObject_1$3;

var slide = keyframes(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject(["\n  0% {\n    opacity: 0;\n    transform: scale(0.9) translateY(-20px);\n  }\n  100% {\n    opacity: 1;\n    transform: scale(1) translateY(0);\n  }\n"], ["\n  0% {\n    opacity: 0;\n    transform: scale(0.9) translateY(-20px);\n  }\n  100% {\n    opacity: 1;\n    transform: scale(1) translateY(0);\n  }\n"])));
var templateObject_1$4;

var rippleAnimation = css(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject(["\n  animation: ", " 1.2s;\n"], ["\n  animation: ", " 1.2s;\n"])), ripple);
var BaseButtonStyles = styled.button(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject(["\n  text-align: center;\n  /** the childeren spans are used for pressed and active state are absolutely positioned  */\n  position: relative;\n  padding: 4px 8px;\n  min-height: 32px;\n  border-radius: ", "px;\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  font-family: ", ", sans-serif;\n  cursor: pointer;\n  border: none;\n  background-color: transparent;\n  ", "\n\n  /** Presssed state styles */\n  overflow: hidden;\n  span.ripple {\n    position: absolute;\n    pointer-events: none;\n    border-radius: 50%;\n    background-color: rgba(255, 255, 255, 0.12);\n    ", ";\n    width: 100px;\n    height: 100px;\n    margin-top: -50px;\n    margin-left: -50px;\n    opacity: 0;\n  }\n\n  span.disabled,\n  span.hover {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n\n  /** Active **/\n  &.active,\n  &:active {\n    color: ", ";\n  }\n\n  /** Disabled **/\n  &:disabled {\n    cursor: default;\n    pointer-events: none;\n    span.disabled {\n      background-color: ", ";\n    }\n  }\n  /** Hover **/\n  &:hover,\n  &.hover {\n    span.hover {\n      background-color: ", ";\n    }\n  }\n"], ["\n  text-align: center;\n  /** the childeren spans are used for pressed and active state are absolutely positioned  */\n  position: relative;\n  padding: 4px 8px;\n  min-height: 32px;\n  border-radius: ", "px;\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  font-family: ", ", sans-serif;\n  cursor: pointer;\n  border: none;\n  background-color: transparent;\n  ", "\n\n  /** Presssed state styles */\n  overflow: hidden;\n  span.ripple {\n    position: absolute;\n    pointer-events: none;\n    border-radius: 50%;\n    background-color: rgba(255, 255, 255, 0.12);\n    ", ";\n    width: 100px;\n    height: 100px;\n    margin-top: -50px;\n    margin-left: -50px;\n    opacity: 0;\n  }\n\n  span.disabled,\n  span.hover {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n\n  /** Active **/\n  &.active,\n  &:active {\n    color: ", ";\n  }\n\n  /** Disabled **/\n  &:disabled {\n    cursor: default;\n    pointer-events: none;\n    span.disabled {\n      background-color: ", ";\n    }\n  }\n  /** Hover **/\n  &:hover,\n  &.hover {\n    span.hover {\n      background-color: ", ";\n    }\n  }\n"])), function (props) { return props.theme.shape.radiusMedium; }, function (props) { return props.theme.measurements.fontSystem.button1.size; }, function (props) { return props.theme.measurements.fontSystem.button1.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.button1.case; }, function (props) { return props.theme.typography.fontFamily; }, Focused, rippleAnimation, function (props) { return props.theme.button.activeForeground; }, function (props) { return props.theme.button.outlinedInactiveOverlayColor; }, function (props) { return props.theme.button.hoverOverlayColor; });
var BaseButton = /** @class */ (function (_super) {
    __extends(BaseButton, _super);
    function BaseButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { display: 'none', left: 0, top: 0 };
        _this.timeout = null;
        _this.onClick = function (e) {
            var btn = e.currentTarget.getBoundingClientRect();
            var left = e.pageX - btn.left;
            var top = e.pageY - btn.top;
            if (_this.state.display === 'block') {
                _this.setState({ display: 'none' }, function () {
                    _this.setRippleState(left, top);
                });
            }
            else {
                _this.setRippleState(left, top);
            }
            _this.props.onClick(e);
        };
        _this.setRippleState = function (left, top) {
            _this.setState({ left: left, top: top, display: 'block' });
            _this.timeout = setTimeout(function () {
                _this.setState({ display: 'none' });
            }, 1200);
        };
        return _this;
    }
    BaseButton.prototype.componentWillUnmount = function () {
        clearTimeout(this.timeout);
    };
    BaseButton.prototype.render = function () {
        var _a = this.props, isActive = _a.isActive, isDisabled = _a.isDisabled, ariaLabel = _a.ariaLabel, children = _a.children, className = _a.className, rest = __rest(_a, ["isActive", "isDisabled", "ariaLabel", "children", "className"]);
        var _b = this.state, left = _b.left, top = _b.top, display = _b.display;
        return (React.createElement(BaseButtonStyles, __assign({ "data-test-id": ariaLabel, className: [className, isActive ? 'active' : ''].join(' '), disabled: isDisabled, "aria-label": ariaLabel }, rest, { onClick: this.onClick }),
            children,
            React.createElement("span", { className: "ripple", style: { left: left, top: top, display: display } }),
            React.createElement("span", { className: "disabled" }),
            React.createElement("span", { className: "hover" })));
    };
    BaseButton.defaultProps = {
        type: 'button',
        isDisabled: false,
        isActive: false,
    };
    return BaseButton;
}(React.Component));
var templateObject_1$5, templateObject_2$1;

var IconContainer = styled.div(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject(["\n  &:focus: {\n    outline: none;\n  }\n  > img {\n    height: 18px;\n    width: 18px;\n  }\n  > svg {\n    height: 18px;\n    width: 18px;\n  }\n  display: none;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    display: flex;\n  }\n  ", "\n"], ["\n  &:focus: {\n    outline: none;\n  }\n  > img {\n    height: 18px;\n    width: 18px;\n  }\n  > svg {\n    height: 18px;\n    width: 18px;\n  }\n  display: none;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    display: flex;\n  }\n  ",
    "\n"])), function (_a) {
    var hasIcon = _a.hasIcon;
    return hasIcon
        ? css(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject(["\n          display: none;\n          @media all and (min-width: 0) and (max-width: 599px) {\n            display: flex;\n          }\n        "], ["\n          display: none;\n          @media all and (min-width: 0) and (max-width: 599px) {\n            display: flex;\n          }\n        "]))) : 'display: flex;';
});
var ResponsiveContainer = styled.div(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n  &:focus: {\n    outline: none;\n  }\n  ", "\n"], ["\n  &:focus: {\n    outline: none;\n  }\n  ",
    "\n"])), function (_a) {
    var hasIcon = _a.hasIcon;
    return hasIcon
        ? css(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n          display: flex;\n          @media all and (min-width: 0) and (max-width: 599px) {\n            display: none;\n          }\n        "], ["\n          display: flex;\n          @media all and (min-width: 0) and (max-width: 599px) {\n            display: none;\n          }\n        "]))) : 'display: flex;';
});
var ResponsiveButton = function (_a) {
    var children = _a.children, icon = _a.icon, rest = __rest(_a, ["children", "icon"]);
    var node = React.createElement(ResponsiveContainer, { hasIcon: !!icon }, children);
    return (React.createElement(BaseButton, __assign({}, rest),
        icon && React.createElement(IconContainer, { hasIcon: !!icon }, icon),
        children && node));
};
var templateObject_1$6, templateObject_2$2, templateObject_3, templateObject_4;

var CardType$1;
(function (CardType) {
    CardType["LARGE"] = "large";
    CardType["MEDIUM"] = "medium";
    CardType["SMALL"] = "small";
})(CardType$1 || (CardType$1 = {}));
var rippleAnimation$1 = css(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject(["\n  animation: ", " 1.2s;\n"], ["\n  animation: ", " 1.2s;\n"])), ripple);
var slideAnimation = function () {
    return css(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject(["\n    animation: ", " 0.2s linear;\n  "], ["\n    animation: ", " 0.2s linear;\n  "])), slide);
};
var CardStyles = styled.button(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject(["\n  padding: 0;\n  cursor: pointer;\n  border: none;\n  box-sizing: border-box;\n  background-size: cover;\n  background-position: center center;\n  background-repeat: no-repeat;\n  background-color: ", ";\n  color: ", ";\n  border-radius: ", "px;\n\n  /** Pressed state styles **/\n  overflow: hidden;\n  span.ripple {\n    position: absolute;\n    pointer-events: none;\n    border-radius: 50%;\n    background-color: rgba(255, 255, 255, 0.12);\n\n    width: 100px;\n    height: 100px;\n    margin-top: -50px;\n    margin-left: -50px;\n\n    ", ";\n    opacity: 0;\n  }\n\n  /** Active, Hover and Disabled state base styles **/\n  span.active,\n  span.disabled,\n  span.hover {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n  /** Active **/\n  &.active {\n    border: 1px solid ", ";\n    span.active {\n      background-color: ", ";\n    }\n  }\n  /** Disabled **/\n  &:disabled {\n    cursor: default;\n    pointer-events: none;\n    span.disabled {\n      background-color: ", ";\n    }\n  }\n  /** Hover **/\n  &:hover,\n  &.hover {\n    span.hover {\n      background-color: ", ";\n    }\n  }\n  ", "\n  ", ";\n  animation-fill-mode: both;\n"], ["\n  padding: 0;\n  cursor: pointer;\n  border: none;\n  box-sizing: border-box;\n  background-size: cover;\n  background-position: center center;\n  background-repeat: no-repeat;\n  background-color: ", ";\n  color: ", ";\n  border-radius: ", "px;\n\n  /** Pressed state styles **/\n  overflow: hidden;\n  span.ripple {\n    position: absolute;\n    pointer-events: none;\n    border-radius: 50%;\n    background-color: rgba(255, 255, 255, 0.12);\n\n    width: 100px;\n    height: 100px;\n    margin-top: -50px;\n    margin-left: -50px;\n\n    ", ";\n    opacity: 0;\n  }\n\n  /** Active, Hover and Disabled state base styles **/\n  span.active,\n  span.disabled,\n  span.hover {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n  /** Active **/\n  &.active {\n    border: 1px solid ", ";\n    span.active {\n      background-color: ", ";\n    }\n  }\n  /** Disabled **/\n  &:disabled {\n    cursor: default;\n    pointer-events: none;\n    span.disabled {\n      background-color: ", ";\n    }\n  }\n  /** Hover **/\n  &:hover,\n  &.hover {\n    span.hover {\n      background-color: ", ";\n    }\n  }\n  ", "\n  ", ";\n  animation-fill-mode: both;\n"])), function (props) { return props.theme.card.background; }, function (props) { return props.theme.card.foreground; }, function (props) { return props.theme.shape.radiusMedium; }, rippleAnimation$1, function (props) { return props.theme.card.activeBorderColor; }, function (props) { return props.theme.card.activeOverlayColor; }, function (props) { return props.theme.card.inactiveOverlayColor; }, function (props) { return props.theme.card.hoverOverlayColor; }, Focused, slideAnimation);
var BaseCard = /** @class */ (function (_super) {
    __extends(BaseCard, _super);
    function BaseCard() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.timeout = null;
        _this.state = { display: 'none', left: 0, top: 0 };
        _this.onKeyDown = function (e) {
            if (e.key === 'Space' || e.key === 'Enter') {
                if (_this.props.onClick) {
                    _this.props.onClick();
                }
            }
        };
        _this.onClick = function (e) {
            var btn = e.currentTarget.getBoundingClientRect();
            var left = e.pageX - btn.left;
            var top = e.pageY - btn.top;
            if (_this.state.display === 'block') {
                _this.setState({ display: 'none' }, function () {
                    _this.setRippleState(left, top);
                });
            }
            else {
                _this.setRippleState(left, top);
            }
            _this.props.onClick(e);
        };
        _this.setRippleState = function (left, top) {
            _this.setState({ left: left, top: top, display: 'block' });
            _this.timeout = setTimeout(function () {
                _this.setState({ display: 'none' });
            }, 1200);
        };
        return _this;
    }
    BaseCard.prototype.componentWillUnmount = function () {
        clearTimeout(this.timeout);
    };
    BaseCard.prototype.render = function () {
        var _a = this.props, children = _a.children, label = _a.label, isActive = _a.isActive, isDisabled = _a.isDisabled, image = _a.image, style = _a.style, className = _a.className;
        var _b = this.state, left = _b.left, top = _b.top, display = _b.display;
        var activeStyles = image ? { backgroundImage: "url(" + image + ")" } : undefined;
        var baseCardProps = {
            onClick: this.onClick,
            onKeyDown: this.onKeyDown,
            style: __assign({}, activeStyles, style),
            className: [className, isActive ? 'active' : ''].join(' '),
        };
        return (React.createElement(CardStyles, __assign({ "data-test-id": label, "aria-label": label, disabled: isDisabled }, baseCardProps),
            children,
            React.createElement("span", { className: "ripple", style: { left: left, top: top, display: display } }),
            React.createElement("span", { className: "active" }),
            React.createElement("span", { className: "disabled" }),
            React.createElement("span", { className: "hover" })));
    };
    return BaseCard;
}(React.Component));
var templateObject_1$7, templateObject_2$3, templateObject_3$1;

var LabelWrapper = styled.div(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject(["\n &&& {\n  position: absolute;\n  bottom: 0px;\n  border-radius: ", "px;\n  left: 0;\n  ", "\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  width: 100%;\n  text-align: center;\n  cursor: pointer;\n  .label {\n    font-size: ", "px;\n    left: 50%;\n    position: absolute;\n    transform: translateX(-50%);\n    top: 13px;\n    width: 100%;\n  }\n }\n"], ["\n &&& {\n  position: absolute;\n  bottom: 0px;\n  border-radius: ", "px;\n  left: 0;\n  ",
    "\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  width: 100%;\n  text-align: center;\n  cursor: pointer;\n  .label {\n    font-size: ", "px;\n    left: 50%;\n    position: absolute;\n    transform: translateX(-50%);\n    top: 13px;\n    width: 100%;\n  }\n }\n"])), function (props) { return props.theme.shape.radiusMedium; }, function (props) {
    return props.withBackground
        ? css(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject(["\n          color: ", ";\n          height: 40px;\n          background: ", ";\n        "], ["\n          color: ", ";\n          height: 40px;\n          background: ", ";\n        "])), props.theme.card.labelForeground, props.theme.card.labelBackground) : css(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject(["\n          color: ", ";\n          height: 32px;\n        "], ["\n          color: ", ";\n          height: 32px;\n        "])), props.theme.card.foreground);
}, function (props) { return props.theme.measurements.fontSystem.label.size; }, function (props) { return props.theme.measurements.fontSystem.label.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.label.case; }, function (props) { return props.theme.measurements.fontSystem.label.size; });
var Caret = styled.div(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject(["\n  position: absolute;\n  top: 6px;\n  width: 0;\n  height: 0;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n  border-top: 5px solid ", ";\n  transform: rotate(", "deg);\n  display: inline-block;\n  transition-duration: 0.3s;\n  transition-timing-function: ease-in;\n"], ["\n  position: absolute;\n  top: 6px;\n  width: 0;\n  height: 0;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n  border-top: 5px solid ", ";\n  transform: rotate(", "deg);\n  display: inline-block;\n  transition-duration: 0.3s;\n  transition-timing-function: ease-in;\n"])), function (props) { return props.theme.card.labelForeground; }, function (props) { return props.rotation || 0; });
var CaretPositionWrapper = styled.span(templateObject_5 || (templateObject_5 = __makeTemplateObject(["\n  position: relative;\n  padding-left: 10px;\n"], ["\n  position: relative;\n  padding-left: 10px;\n"])));
var HiddenLabel = styled.div(templateObject_6 || (templateObject_6 = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), VisuallyHidden);
var BaseCardLabel = function (_a) {
    var children = _a.children, className = _a.className, caret = _a.caret, isActive = _a.isActive, style = _a.style, withBackground = _a.withBackground, hidden = _a.hidden;
    if (hidden) {
        return React.createElement(HiddenLabel, null, children);
    }
    var getCaret = function () { return (React.createElement(CaretPositionWrapper, null,
        React.createElement(Caret, { "aria-hidden": true, rotation: isActive ? 180 : 0 }))); };
    return (React.createElement(LabelWrapper, { className: className, withBackground: withBackground, style: style },
        React.createElement("span", { className: "label" },
            children,
            caret && getCaret())));
};
var templateObject_1$8, templateObject_2$4, templateObject_3$2, templateObject_4$1, templateObject_5, templateObject_6;

var States = {
    Focused: Focused,
    HiddenScrollbar: HiddenScrollbar,
    VisuallyHidden: VisuallyHidden,
};
var Animations = { ripple: ripple, scale: scale, slide: slide };

var ContainedPrimaryButton = styled(ResponsiveButton)(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject(["\n  &&& {\n    background: ", ";\n    color: ", ";\n    border: 1px solid ", ";\n    font-size: ", "px;\n    margin-top: 3px;\n    margin-right: 10px;\n    &.active,\n    &:active {\n      color: ", ";\n    }\n  }\n"], ["\n  &&& {\n    background: ", ";\n    color: ", ";\n    border: 1px solid ", ";\n    font-size: ", "px;\n    margin-top: 3px;\n    margin-right: 10px;\n    &.active,\n    &:active {\n      color: ", ";\n    }\n  }\n"])), function (props) { return props.theme.button.containedPrimaryBackground; }, function (props) { return props.theme.button.containedPrimaryForeground; }, function (props) { return props.theme.button.containedPrimaryBackground; }, function (props) { return props.theme.measurements.fontSystem.button1.size; }, function (props) { return props.theme.button.containedPrimaryForeground; });
var templateObject_1$9;

var OutlinedSecondaryButton = styled(ResponsiveButton)(templateObject_1$a || (templateObject_1$a = __makeTemplateObject(["\n  &&& {\n    margin-top: 3px;\n    background: ", ";\n    color: ", ";\n    border: 1px solid ", ";\n    font-size: ", "px;\n    height: 32px;\n  }\n"], ["\n  &&& {\n    margin-top: 3px;\n    background: ", ";\n    color: ", ";\n    border: 1px solid ", ";\n    font-size: ", "px;\n    height: 32px;\n  }\n"])), function (props) { return props.theme.button.outlinedSecondaryBackground; }, function (props) { return props.theme.button.outlinedSecondaryForeground; }, function (props) { return props.theme.button.outlinedBorderColor; }, function (props) { return props.theme.measurements.fontSystem.button1.size; });
var templateObject_1$a;

var TextSecondaryButton = styled(ResponsiveButton)(templateObject_1$b || (templateObject_1$b = __makeTemplateObject(["\n  &&& {\n    font-size: ", "px;\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    color: ", ";\n    margin: 0 5px;\n    span.disabled {\n      display: none;\n    }\n    &:disabled,\n    &.disabled {\n      opacity: ", ";\n    }\n  }\n"], ["\n  &&& {\n    font-size: ", "px;\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    color: ", ";\n    margin: 0 5px;\n    span.disabled {\n      display: none;\n    }\n    &:disabled,\n    &.disabled {\n      opacity: ", ";\n    }\n  }\n"])), function (props) { return props.theme.measurements.fontSystem.button2.size; }, function (props) { return props.theme.measurements.fontSystem.button2.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.button2.case; }, function (props) { return props.theme.button.textSecondaryForeground; }, function (props) { return props.theme.button.textInactiveOpacity; });
var templateObject_1$b;

var Float = styled(BaseButton)(templateObject_1$c || (templateObject_1$c = __makeTemplateObject(["\n  width: 60px;\n  height: 60px;\n  background-color: gray;\n  border-radius: 50%;\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n  z-index: ", ";\n  font-size: ", "px;\n  padding: 2px;\n"], ["\n  width: 60px;\n  height: 60px;\n  background-color: gray;\n  border-radius: 50%;\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n  z-index: ", ";\n  font-size: ", "px;\n  padding: 2px;\n"])), function (props) { return props.theme.measurements.zIndex.button.float; }, function (props) { return props.theme.measurements.fontSystem.button1.size; });
var Inner = styled.div(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject(["\n  height: 56px;\n  width: 56px;\n  border-radius: 50%;\n  background-color: ", ";\n"], ["\n  height: 56px;\n  width: 56px;\n  border-radius: 50%;\n  background-color: ", ";\n"])), function (props) { return props.theme.webcam.floatButton; });
var FloatButton = function (props) {
    return (React.createElement(Float, __assign({}, props),
        React.createElement(Inner, null)));
};
var templateObject_1$c, templateObject_2$5;

var ButtonGroup = styled.div(templateObject_1$d || (templateObject_1$d = __makeTemplateObject(["\n  display: inline-flex;\n"], ["\n  display: inline-flex;\n"])));
var ButtonGroupItem = styled(ResponsiveButton)(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject(["\n  &&& {\n    font-size: ", "px;\n    background: ", ";\n    color: ", ";\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    padding: 4px 10px;\n    position: relative;\n    height: 32px;\n    /* for safari */\n    margin: 0;\n    &:last-child:after {\n      opacity: 0;\n    }\n  }\n"], ["\n  &&& {\n    font-size: ", "px;\n    background: ", ";\n    color: ", ";\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    padding: 4px 10px;\n    position: relative;\n    height: 32px;\n    /* for safari */\n    margin: 0;\n    &:last-child:after {\n      opacity: 0;\n    }\n  }\n"
    /**
     * Edit, Delele Duplicate buttons on canvas
     */
])), function (props) { return props.theme.measurements.fontSystem.button1.size; }, function (props) { return props.theme.canvasActionBar.background; }, function (props) { return props.theme.canvasActionBar.foreground; }, function (props) { return props.theme.measurements.fontSystem.button2.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.button2.case; });
/**
 * Edit, Delele Duplicate buttons on canvas
 */
var ButtonGroupWrapper = styled.div(templateObject_5$1 || (templateObject_5$1 = __makeTemplateObject(["\n  ", ";\n  display: inline-flex;\n  position: absolute;\n  transform: translate(-50%, -100%);\n  background: ", ";\n  color: ", ";\n  border-radius: ", "px;\n  white-space: nowrap;\n  transition: opacity 0.3s ease-in-out;\n  z-index: ", ";\n  ", " {\n    &:after {\n      content: '';\n      position: absolute;\n      right: 0px;\n      top: 6px;\n      height: calc(100% - 12px);\n      border-right: 1px solid ", ";\n      &:last-child {\n        border-right: unset;\n      }\n    }\n  }\n"], ["\n  ",
    ";\n  display: inline-flex;\n  position: absolute;\n  transform: translate(-50%, -100%);\n  background: ", ";\n  color: ", ";\n  border-radius: ", "px;\n  white-space: nowrap;\n  transition: opacity 0.3s ease-in-out;\n  z-index: ", ";\n  ", " {\n    &:after {\n      content: '';\n      position: absolute;\n      right: 0px;\n      top: 6px;\n      height: calc(100% - 12px);\n      border-right: 1px solid ", ";\n      &:last-child {\n        border-right: unset;\n      }\n    }\n  }\n"])), function (props) {
    return props.show
        ? css(templateObject_3$3 || (templateObject_3$3 = __makeTemplateObject(["\n          opacity: 1;\n        "], ["\n          opacity: 1;\n        "]))) : css(templateObject_4$2 || (templateObject_4$2 = __makeTemplateObject(["\n          opacity: 0;\n        "], ["\n          opacity: 0;\n        "])));
}, function (props) { return props.theme.canvasActionBar.background; }, function (props) { return props.theme.canvasActionBar.foreground; }, function (props) { return props.theme.shape.radiusMedium; }, function (props) { return props.theme.measurements.zIndex.buttonGroup; }, ButtonGroupItem, function (props) { return props.theme.canvasActionBar.separatorColor; });
var templateObject_1$d, templateObject_2$6, templateObject_3$3, templateObject_4$2, templateObject_5$1;

var CanvasArea = styled.div(templateObject_1$e || (templateObject_1$e = __makeTemplateObject(["\n  display: flex;\n  position: relative;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n"], ["\n  display: flex;\n  position: relative;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n"])));
var templateObject_1$e;

var Canvas = styled.canvas(templateObject_1$f || (templateObject_1$f = __makeTemplateObject(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n"], ["\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n"])));
var templateObject_1$f;

var CanvasBar = styled.div(templateObject_3$4 || (templateObject_3$4 = __makeTemplateObject(["\n  display: ", ";\n  flex-direction: row;\n  align-items: center;\n  height: ", "px;\n  color: ", ";\n  border-bottom: 1px solid ", ";\n  padding: 8px 24px;\n  box-sizing: border-box;\n  position: absolute;\n  width: 100%;\n  z-index: ", ";\n  background: ", ";\n  ", "\n"], ["\n  display: ", ";\n  flex-direction: row;\n  align-items: center;\n  height: ", "px;\n  color: ", ";\n  border-bottom: 1px solid ", ";\n  padding: 8px 24px;\n  box-sizing: border-box;\n  position: absolute;\n  width: 100%;\n  z-index: ", ";\n  background: ", ";\n  ",
    "\n"])), function (props) { return (props.hide ? 'none' : 'flex'); }, function (props) { return props.theme.measurements.mainCanvasActionBar.height; }, function (props) { return props.theme.mainCanvasActionBar.foreground; }, function (props) { return props.theme.mainCanvasActionBar.borderColor; }, function (props) { return props.theme.measurements.zIndex.canvas.bar; }, function (props) { return (props.transparentBackgound ? 'transparent' : props.theme.mainCanvasActionBar.background); }, function (props) {
    return props.bottom
        ? css(templateObject_1$g || (templateObject_1$g = __makeTemplateObject(["\n          justify-content: space-around;\n          bottom: 0;\n          transform: rotate(180deg);\n        "], ["\n          justify-content: space-around;\n          bottom: 0;\n          transform: rotate(180deg);\n        "]))) : css(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject(["\n          justify-content: space-between;\n        "], ["\n          justify-content: space-between;\n        "])));
});
CanvasBar.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$g, templateObject_2$7, templateObject_3$4;

var CanvasContainer = styled.div.attrs({
    role: 'main',
})(templateObject_1$h || (templateObject_1$h = __makeTemplateObject(["\n  background-color: ", ";\n  flex-grow: 1;\n  flex-shrink: 1;\n  flex-basis: auto;\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  /* added this for safari, else the webcam overlay did not know the height */\n  height: 100%;\n  width: 100%;\n  margin-top: ", "px;\n"], ["\n  background-color: ", ";\n  flex-grow: 1;\n  flex-shrink: 1;\n  flex-basis: auto;\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  /* added this for safari, else the webcam overlay did not know the height */\n  height: 100%;\n  width: 100%;\n  margin-top: ", "px;\n"])), function (props) { return props.theme.canvas.background; }, function (props) { return props.theme.measurements.canvas.marginTop; });
var templateObject_1$h;

var Element$1 = styled.canvas(templateObject_1$i || (templateObject_1$i = __makeTemplateObject(["\n  position: absolute;\n  top: 0;\n  left: 0;\n"], ["\n  position: absolute;\n  top: 0;\n  left: 0;\n"])));
var templateObject_1$i;

var Wrapper = styled.div(templateObject_1$j || (templateObject_1$j = __makeTemplateObject(["\n  position: relative;\n  transition: all 0.4s cubic-bezier(0.17, 0.04, 0.03, 0.94);\n  height: 100%;\n  width: 100%;\n  z-index: ", ";\n  background-color: ", ";\n"], ["\n  position: relative;\n  transition: all 0.4s cubic-bezier(0.17, 0.04, 0.03, 0.94);\n  height: 100%;\n  width: 100%;\n  z-index: ", ";\n  background-color: ", ";\n"])), function (props) { return props.theme.measurements.zIndex.canvas.webcam.backdrop; }, function (props) { return props.theme.webcam.background; });
Wrapper.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$j;

var Webcam = styled.video(templateObject_1$k || (templateObject_1$k = __makeTemplateObject(["\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n"], ["\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n"])));
var templateObject_1$k;

var Circle = styled.div.attrs(function (_a) {
    var radius = _a.radius;
    return ({
        style: { height: radius * 2 + "px", width: radius * 2 + "px" },
    });
})(templateObject_1$l || (templateObject_1$l = __makeTemplateObject(["\n  border-radius: 50%;\n  border: 2px solid ", ";\n  box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2), inset 0 2px 6px 0 rgba(0, 0, 0, 0.2);\n  cursor: move;\n"], ["\n  border-radius: 50%;\n  border: 2px solid ", ";\n  box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2), inset 0 2px 6px 0 rgba(0, 0, 0, 0.2);\n  cursor: move;\n"])), function (props) { return props.theme.canvas.controlsOutline; });
Circle.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$l;

var Line = styled.div(templateObject_1$m || (templateObject_1$m = __makeTemplateObject(["\n  position: absolute;\n  color: ", ";\n"], ["\n  position: absolute;\n  color: ", ";\n"])), function (props) { return props.theme.canvas.controlsOutline; });
Line.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$m;

var Knob = styled.div(templateObject_1$n || (templateObject_1$n = __makeTemplateObject(["\n  position: absolute;\n  height: ", "px;\n  width: ", "px;\n  margin-left: -10px;\n  margin-top: -10px;\n  z-index: ", ";\n  will-change: transform;\n  cursor: ew-resize;\n  &:before {\n    display: block;\n    position: absolute;\n    content: '';\n    background: ", ";\n    border-radius: 50%;\n    width: ", "px;\n    height: ", "px;\n    top: ", "px;\n    left: ", "px;\n    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.24);\n  }\n"], ["\n  position: absolute;\n  height: ", "px;\n  width: ", "px;\n  margin-left: -10px;\n  margin-top: -10px;\n  z-index: ", ";\n  will-change: transform;\n  cursor: ew-resize;\n  &:before {\n    display: block;\n    position: absolute;\n    content: '';\n    background: ", ";\n    border-radius: 50%;\n    width: ", "px;\n    height: ", "px;\n    top: ", "px;\n    left: ", "px;\n    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.24);\n  }\n"])), function (props) { return props.theme.measurements.canvasControls.knob.touchable.desktop; }, function (props) { return props.theme.measurements.canvasControls.knob.touchable.desktop; }, function (props) { return props.theme.measurements.zIndex.canvas.knob; }, function (props) { return props.theme.canvas.controlsColor; }, function (props) { return props.theme.measurements.canvasControls.knob.size; }, function (props) { return props.theme.measurements.canvasControls.knob.size; }, function (props) { return props.theme.measurements.canvasControls.knob.size / 4; }, function (props) { return props.theme.measurements.canvasControls.knob.size / 4; });
Knob.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$n;

var Touchable = styled.div(function (props) {
    var _a = props.theme.measurements.canvasControls.corner.touchable, desktop = _a.desktop, mobile = _a.mobile;
    var offsetDesktop = desktop / 4;
    var offsetMobile = mobile / 2;
    return css(templateObject_13 || (templateObject_13 = __makeTemplateObject(["\n  position: absolute;\n  width: ", "px;\n  height: ", "px;\n  ", "\n  ", "\n  ", "\n  ", "\n  @media all and (min-width: 0) and (max-width: 599px) {\n    width: ", "px;\n    height: ", "px;\n    ", "\n    ", "\n  }\n"], ["\n  position: absolute;\n  width: ", "px;\n  height: ", "px;\n  ",
        "\n  ",
        "\n  ",
        "\n  ",
        "\n  @media all and (min-width: 0) and (max-width: 599px) {\n    width: ", "px;\n    height: ", "px;\n    ",
        "\n    ",
        "\n  }\n"])), desktop, desktop, function (p) {
        return p.vertical === 'top'
            ? css(templateObject_1$o || (templateObject_1$o = __makeTemplateObject(["\n          top: 0px;\n        "], ["\n          top: 0px;\n        "]))) : css(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject(["\n          bottom: 0px;\n        "], ["\n          bottom: 0px;\n        "])));
    }, function (p) {
        return p.horizontal === 'left'
            ? css(templateObject_3$5 || (templateObject_3$5 = __makeTemplateObject(["\n          left: 0px;\n        "], ["\n          left: 0px;\n        "]))) : css(templateObject_4$3 || (templateObject_4$3 = __makeTemplateObject(["\n          right: 0px;\n        "], ["\n          right: 0px;\n        "])));
    }, function (p) {
        return p.vertical === 'top'
            ? css(templateObject_5$2 || (templateObject_5$2 = __makeTemplateObject(["\n          margin-top: -", "px;\n        "], ["\n          margin-top: -", "px;\n        "])), offsetDesktop) : css(templateObject_6$1 || (templateObject_6$1 = __makeTemplateObject(["\n          margin-bottom: -", "px;\n        "], ["\n          margin-bottom: -", "px;\n        "])), offsetDesktop);
    }, function (p) {
        return p.horizontal === 'left'
            ? css(templateObject_7 || (templateObject_7 = __makeTemplateObject(["\n          margin-left: -", "px;\n        "], ["\n          margin-left: -", "px;\n        "])), offsetDesktop) : css(templateObject_8 || (templateObject_8 = __makeTemplateObject(["\n          margin-right: -", "px;\n        "], ["\n          margin-right: -", "px;\n        "])), offsetDesktop);
    }, mobile, mobile, function (p) {
        return p.vertical === 'top'
            ? css(templateObject_9 || (templateObject_9 = __makeTemplateObject(["\n            margin-top: -", "px;\n          "], ["\n            margin-top: -", "px;\n          "])), offsetMobile) : css(templateObject_10 || (templateObject_10 = __makeTemplateObject(["\n            margin-bottom: -", "px;\n          "], ["\n            margin-bottom: -", "px;\n          "])), offsetMobile);
    }, function (p) {
        return p.horizontal === 'left'
            ? css(templateObject_11 || (templateObject_11 = __makeTemplateObject(["\n            margin-left: -", "px;\n          "], ["\n            margin-left: -", "px;\n          "])), offsetMobile) : css(templateObject_12 || (templateObject_12 = __makeTemplateObject(["\n            margin-right: -", "px;\n          "], ["\n            margin-right: -", "px;\n          "])), offsetMobile);
    });
});
var Corner = styled(Touchable)(function (props) {
    var right = props.horizontal === 'right' ? props.borderWidth : 0;
    var bottom = props.vertical === 'bottom' ? props.borderWidth : 0;
    var left = props.horizontal === 'left' ? props.borderWidth : 0;
    var top = props.vertical === 'top' ? props.borderWidth : 0;
    var borderWidth = top + "px " + right + "px " + bottom + "px " + left + "px";
    var cursor = (props.horizontal === 'left' && props.vertical === 'bottom') ||
        (props.horizontal === 'right' && props.vertical === 'top')
        ? 'nesw-resize'
        : 'nwse-resize';
    var offset = props.theme.measurements.canvasControls.corner.touchable.desktop / 4 - props.borderWidth;
    var offsetMobile = props.theme.measurements.canvasControls.corner.touchable.mobile / 4 + props.borderWidth;
    return css(templateObject_22 || (templateObject_22 = __makeTemplateObject(["\n  &:before {\n    display: block;\n    position: absolute;\n    content: \"\";\n    width: ", "px;\n    height: ", "px;\n    z-index: ", ";\n    border-color: ", ";\n    border-style: solid;\n    border-width: ", ";\n    ", "\n    ", "\n    cursor: ", ";\n    @media all and (min-width: 0) and (max-width: 599px) {\n      ", "\n      ", "\n    }\n  }"], ["\n  &:before {\n    display: block;\n    position: absolute;\n    content: \"\";\n    width: ", "px;\n    height: ", "px;\n    z-index: ", ";\n    border-color: ", ";\n    border-style: solid;\n    border-width: ", ";\n    ",
        "\n    ",
        "\n    cursor: ", ";\n    @media all and (min-width: 0) and (max-width: 599px) {\n      ",
        "\n      ",
        "\n    }\n  }"])), function (p) { return p.theme.measurements.canvasControls.corner.size; }, function (p) { return p.theme.measurements.canvasControls.corner.size; }, function (p) { return p.theme.measurements.zIndex.canvas.controls; }, function (p) { return p.theme.canvas.controlsColor; }, borderWidth, props.vertical === 'top'
        ? css(templateObject_14 || (templateObject_14 = __makeTemplateObject(["\n            top: ", "px;\n          "], ["\n            top: ", "px;\n          "])), offset) : css(templateObject_15 || (templateObject_15 = __makeTemplateObject(["\n            bottom: ", "px;\n          "], ["\n            bottom: ", "px;\n          "])), offset), props.horizontal === 'left'
        ? css(templateObject_16 || (templateObject_16 = __makeTemplateObject(["\n            left: ", "px;\n          "], ["\n            left: ", "px;\n          "])), offset) : css(templateObject_17 || (templateObject_17 = __makeTemplateObject(["\n            right: ", "px;\n          "], ["\n            right: ", "px;\n          "])), offset), cursor, props.vertical === 'top'
        ? css(templateObject_18 || (templateObject_18 = __makeTemplateObject(["\n              margin-top: ", "px;\n            "], ["\n              margin-top: ", "px;\n            "])), offsetMobile) : css(templateObject_19 || (templateObject_19 = __makeTemplateObject(["\n              margin-bottom: ", "px;\n            "], ["\n              margin-bottom: ", "px;\n            "])), offsetMobile), props.horizontal === 'left'
        ? css(templateObject_20 || (templateObject_20 = __makeTemplateObject(["\n              margin-left: ", "px;\n            "], ["\n              margin-left: ", "px;\n            "])), offsetMobile) : css(templateObject_21 || (templateObject_21 = __makeTemplateObject(["\n              margin-right: ", "px;\n            "], ["\n              margin-right: ", "px;\n            "])), offsetMobile));
});
Corner.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$o, templateObject_2$8, templateObject_3$5, templateObject_4$3, templateObject_5$2, templateObject_6$1, templateObject_7, templateObject_8, templateObject_9, templateObject_10, templateObject_11, templateObject_12, templateObject_13, templateObject_14, templateObject_15, templateObject_16, templateObject_17, templateObject_18, templateObject_19, templateObject_20, templateObject_21, templateObject_22;

var Width = styled.div(templateObject_1$p || (templateObject_1$p = __makeTemplateObject(["\n  position: absolute;\n  height: ", "px;\n  width: 4px;\n  z-index: ", ";\n  background: ", ";\n  cursor: pointer;\n"], ["\n  position: absolute;\n  height: ", "px;\n  width: 4px;\n  z-index: ", ";\n  background: ", ";\n  cursor: pointer;\n"])), function (props) { return props.theme.measurements.canvasControls.width.size; }, function (props) { return props.theme.measurements.zIndex.canvas.controls; }, function (props) { return props.theme.canvas.controlsColor; });
Width.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$p;

var Area = styled.div.attrs(function (_a) {
    var height = _a.height, width = _a.width;
    return ({
        style: { height: height + "px", width: width + "px" },
    });
})(templateObject_1$q || (templateObject_1$q = __makeTemplateObject(["\n  border-style: solid;\n  border-width: 2px 0 2px 0;\n  border-color: ", ";\n  box-shadow: 0 -6px 6px -6px rgba(0, 0, 0, 0.2), inset 0 6px 6px -6px rgba(0, 0, 0, 0.2);\n  cursor: move;\n  position: absolute;\n"], ["\n  border-style: solid;\n  border-width: 2px 0 2px 0;\n  border-color: ", ";\n  box-shadow: 0 -6px 6px -6px rgba(0, 0, 0, 0.2), inset 0 6px 6px -6px rgba(0, 0, 0, 0.2);\n  cursor: move;\n  position: absolute;\n"])), function (props) { return props.theme.canvas.controlsOutline; });
Area.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$q;

var Sprite = styled.div.attrs(function (_a) {
    var height = _a.height, width = _a.width, theme = _a.theme;
    return ({
        style: {
            height: height + theme.measurements.canvasControls.sprite.controlPadding + "px",
            width: width + theme.measurements.canvasControls.sprite.controlPadding + "px",
        },
    });
})(templateObject_1$r || (templateObject_1$r = __makeTemplateObject(["\n  left: -", "px;\n  top: -", "px;\n  transform-origin: center center;\n  border-style: solid;\n  border-width: 2px;\n  border-color: ", ";\n  box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2), inset 0 2px 6px 0 rgba(0, 0, 0, 0.2);\n  cursor: move;\n  will-change: transform;\n  position: absolute;\n"], ["\n  left: -", "px;\n  top: -", "px;\n  transform-origin: center center;\n  border-style: solid;\n  border-width: 2px;\n  border-color: ", ";\n  box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2), inset 0 2px 6px 0 rgba(0, 0, 0, 0.2);\n  cursor: move;\n  will-change: transform;\n  position: absolute;\n"])), function (props) { return props.theme.measurements.canvasControls.sprite.controlPadding / 2; }, function (props) { return props.theme.measurements.canvasControls.sprite.controlPadding / 2; }, function (props) { return props.theme.canvas.controlsColor; });
Sprite.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$r;

var RotateHandle = styled.div.attrs(function (props) { return ({
    style: { left: props.x + "px" },
}); })(templateObject_1$s || (templateObject_1$s = __makeTemplateObject(["\n  position: absolute;\n  bottom: -", "px;\n  height: ", "px;\n  width: 2px;\n  background-color: ", ";\n"], ["\n  position: absolute;\n  bottom: -", "px;\n  height: ", "px;\n  width: 2px;\n  background-color: ", ";\n"])), function (props) { return props.theme.measurements.canvasControls.sprite.rotateHandle.height; }, function (props) { return props.theme.measurements.canvasControls.sprite.rotateHandle.height; }, function (props) { return props.theme.canvas.controlsOutline; });
var templateObject_1$s;

var Container = styled.div(templateObject_1$t || (templateObject_1$t = __makeTemplateObject(["\n  position: relative;\n  height: inherit;\n  width: inherit;\n"], ["\n  position: relative;\n  height: inherit;\n  width: inherit;\n"])));
var templateObject_1$t;

var Wrapper$1 = styled.div.attrs({
    tabIndex: 0,
})(templateObject_1$u || (templateObject_1$u = __makeTemplateObject(["\n  position: absolute;\n  height: ", "px;\n  width: ", "px;\n  top: 0;\n  left: 0;\n  &:focus {\n    outline: 0;\n  }\n"], ["\n  position: absolute;\n  height: ", "px;\n  width: ", "px;\n  top: 0;\n  left: 0;\n  &:focus {\n    outline: 0;\n  }\n"])), function (props) { return props.height; }, function (props) { return props.width; });
var templateObject_1$u;

var Transition = isSafari()
    ? css(templateObject_1$v || (templateObject_1$v = __makeTemplateObject(["\n      transition: unset;\n    "], ["\n      transition: unset;\n    "]))) : css(templateObject_2$9 || (templateObject_2$9 = __makeTemplateObject(["\n      transition: all 0.4s ease-in-out;\n    "], ["\n      transition: all 0.4s ease-in-out;\n    "])));
var CropBackdrop = styled.div(templateObject_3$6 || (templateObject_3$6 = __makeTemplateObject(["\n  position: absolute;\n  background: ", ";\n  z-index: ", ";\n  ", "\n"], ["\n  position: absolute;\n  background: ", ";\n  z-index: ", ";\n  ", "\n"])), function (props) { return props.theme.canvas.cropBackdrop; }, function (props) { return props.theme.measurements.zIndex.canvas.crop.backdrop; }, Transition);
var CropMask = styled.div.attrs({
    'data-test-id': 'CropMask',
})(templateObject_4$4 || (templateObject_4$4 = __makeTemplateObject(["\n  position: absolute;\n  box-shadow: inset 0 0 0 2px ", ";\n  cursor: move;\n  ", "\n"], ["\n  position: absolute;\n  box-shadow: inset 0 0 0 2px ", ";\n  cursor: move;\n  ", "\n"])), function (props) { return props.theme.canvas.controlsOutline; }, Transition);
var GridLine = styled.div(templateObject_5$3 || (templateObject_5$3 = __makeTemplateObject(["\n  position: absolute;\n  background: ", ";\n  z-index: ", ";\n  ", "\n"], ["\n  position: absolute;\n  background: ", ";\n  z-index: ", ";\n  ", "\n"])), function (props) { return props.theme.canvas.controlsOutline; }, function (props) { return props.theme.measurements.zIndex.canvas.crop.grid; }, Transition);
var Control = styled(Corner)(templateObject_6$2 || (templateObject_6$2 = __makeTemplateObject(["\n  z-index: ", ";\n  ", ";\n"], ["\n  z-index: ", ";\n  ", ";\n"])), function (props) { return props.theme.measurements.zIndex.canvas.controls; }, Transition);
var templateObject_1$v, templateObject_2$9, templateObject_3$6, templateObject_4$4, templateObject_5$3, templateObject_6$2;

var CanvasUIComponents = {
    Index: Canvas,
    Area: CanvasArea,
    Bar: {
        Index: CanvasBar,
        ButtonGroup: ButtonGroup,
    },
    Button: {
        ContainedPrimary: ContainedPrimaryButton,
        OutlinedSecondary: OutlinedSecondaryButton,
        TextSecondary: TextSecondaryButton,
        Float: FloatButton,
    },
    Container: CanvasContainer,
    Element: Element$1,
    Wrapper: Wrapper,
    Webcam: Webcam,
    Controls: {
        Knob: Knob,
        Circle: Circle,
        Corner: Corner,
        Line: Line,
        Area: Area,
        Sprite: Sprite,
        RotateHandle: RotateHandle,
        Container: Container,
        Wrapper: Wrapper$1,
        SpriteActionsWrapper: ButtonGroupWrapper,
        SpriteActionButton: ButtonGroupItem,
        Width: Width,
    },
    Crop: {
        Mask: CropMask,
        GridLine: GridLine,
        Backdrop: CropBackdrop,
        Control: Control,
    },
};

var floatPadding = 24;
var WebcamVideoComponent = /** @class */ (function (_super) {
    __extends(WebcamVideoComponent, _super);
    function WebcamVideoComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.init = function () {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices
                    .getUserMedia({ video: true })
                    .then(function (stream) {
                    _this.video.srcObject = stream;
                })
                    .catch(function (error) {
                    _this.props.modal.showActionModal({
                        identifier: 'webcamUnavailable',
                        error: error,
                        handlers: _this.modalHandler,
                    });
                });
            }
            else {
                _this.props.modal.showActionModal({
                    identifier: 'webcamUnavailable',
                    error: 'Webcam not supported',
                    handlers: _this.modalHandler,
                });
            }
        };
        _this.stop = function () {
            var stream = _this.video.srcObject;
            var tracks = stream.getTracks();
            tracks.forEach(function (track) {
                track.stop();
            });
            _this.video.srcObject = null;
            _this.props.active.selectWebcam(false);
        };
        _this.capture = function () {
            _this.canvas.width = _this.video.videoWidth;
            _this.canvas.height = _this.video.videoHeight;
            _this.canvas.getContext('2d').drawImage(_this.video, 0, 0);
            // Other browsers will fall back to image/png
            _this.props.active.newImage(_this.canvas.toDataURL('image/webp'));
        };
        return _this;
    }
    WebcamVideoComponent.prototype.componentDidMount = function () {
        var _this = this;
        this.canvas = document.createElement('canvas');
        this.video = document.getElementById('video');
        this.modalHandler = {
            buttonYes: function () {
                _this.props.active.selectWebcam(false);
            },
        };
        this.init();
    };
    WebcamVideoComponent.prototype.render = function () {
        var editor = this.props.editor;
        var _a = editor.getPreviewSize(), height = _a.height, width = _a.width;
        var measurements = editor.configStore.measurements;
        var canvasHeight = this.props.canvas.canvasSize.height;
        var topOffset = (canvasHeight - height) / 2;
        // try to keep the button 24px below the webcam or 24px above the bottom of the screen
        var top = topOffset < floatPadding + measurements.buttons.float.size
            ? canvasHeight - floatPadding * 2 - measurements.buttons.float.size / 2
            : canvasHeight - topOffset + floatPadding;
        var closeLabel = this.props.active.webcamLabel;
        return (React.createElement(CanvasUIComponents.Wrapper, null,
            React.createElement(CanvasUIComponents.Bar.Index, { transparentBackgound: true, style: { justifyContent: 'flex-end' } },
                React.createElement(CanvasUIComponents.Bar.ButtonGroup, null,
                    React.createElement(CanvasUIComponents.Button.OutlinedSecondary, { ariaLabel: closeLabel, onClick: this.stop }, closeLabel))),
            React.createElement(CanvasUIComponents.Webcam, { style: { height: height, width: width }, autoPlay: true, id: "video" }),
            React.createElement(CanvasUIComponents.Button.Float, { ariaLabel: 'Click and Save', style: { top: top }, onClick: this.capture })));
    };
    return WebcamVideoComponent;
}(React.Component));
var Webcam$1 = inject('active', 'canvas', 'modal', 'editor')(observer(WebcamVideoComponent));

var WindowResizeComponent = /** @class */ (function (_super) {
    __extends(WindowResizeComponent, _super);
    function WindowResizeComponent(props) {
        var _this = _super.call(this, props) || this;
        _this.wrapperElementRef = null;
        _this.timeout = null;
        _this.updateDimensions = function (render) {
            if (render === void 0) { render = true; }
            if (render) {
                clearTimeout(_this.timeout);
                _this.timeout = setTimeout(function () {
                    _this.update(render);
                }, 100);
            }
            else {
                _this.update(render);
            }
        };
        _this.update = function (render) {
            if (render === void 0) { render = true; }
            var element = _this.wrapperElementRef.current;
            _this.props.canvas.saveDimensions({
                width: (element && element.clientWidth) || 0,
                height: (element && element.clientHeight) || 0,
                render: render,
            });
        };
        _this.wrapperElementRef = React.createRef();
        return _this;
    }
    WindowResizeComponent.prototype.componentDidMount = function () {
        var _this = this;
        this.updateDimensions(false);
        window.addEventListener('resize', function () { return _this.updateDimensions(true); });
    };
    WindowResizeComponent.prototype.componentWillUnmount = function () {
        var _this = this;
        window.removeEventListener('resize', function () { return _this.updateDimensions(true); });
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
    };
    WindowResizeComponent.prototype.render = function () {
        return (React.createElement(CanvasUIComponents.Container, { id: "CanvasContainer", ref: this.wrapperElementRef }, this.props.children));
    };
    return WindowResizeComponent;
}(Component));
var Window = inject('canvas')(observer(WindowResizeComponent));

var AppContainer = styled.div(templateObject_1$w || (templateObject_1$w = __makeTemplateObject(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  background: ", ";\n  color: ", ";\n  display: flex;\n  flex-direction: row;\n  overflow-y: hidden;\n  overflow-x: hidden;\n  -webkit-touch-callout: none;\n  user-select: none;\n  * {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    font-family: '", "', sans-serif;\n    font-size: inherit;\n    line-height: normal;\n    color: inherit;\n  }\n"], ["\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  background: ", ";\n  color: ", ";\n  display: flex;\n  flex-direction: row;\n  overflow-y: hidden;\n  overflow-x: hidden;\n  -webkit-touch-callout: none;\n  user-select: none;\n  * {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    font-family: '", "', sans-serif;\n    font-size: inherit;\n    line-height: normal;\n    color: inherit;\n  }\n"])), function (props) { return props.theme.background; }, function (props) { return props.theme.foreground; }, function (props) { return props.theme.typography.fontFamily; });
AppContainer.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$w;

var inn = keyframes(templateObject_1$x || (templateObject_1$x = __makeTemplateObject(["\n  from { transform: translate(-50%, 0%); }\n  to { transform: translate(-50%, 50%); }\n"], ["\n  from { transform: translate(-50%, 0%); }\n  to { transform: translate(-50%, 50%); }\n"])));
var innAnimation = css(templateObject_2$a || (templateObject_2$a = __makeTemplateObject(["\n  animation: ", " 0.5s, fadeout 0.5s 2.5s;\n"], ["\n  animation: ", " 0.5s, fadeout 0.5s 2.5s;\n"])), inn); /* stylelint-disable-line */
var Toast = styled.div(templateObject_3$7 || (templateObject_3$7 = __makeTemplateObject(["\n  position: absolute;\n  top: ", "px;\n  left: ", "px;\n  transform: translate(-50%, 50%);\n  background: black;\n  color: white;\n  border-radius: ", "px;\n  padding: 10px 16px;\n  text-align: center;\n  z-index: ", ";\n  visibility: hidden;\n  &.show {\n    visibility: visible;\n    ", ";\n  }\n"], ["\n  position: absolute;\n  top: ", "px;\n  left: ", "px;\n  transform: translate(-50%, 50%);\n  background: black;\n  color: white;\n  border-radius: ", "px;\n  padding: 10px 16px;\n  text-align: center;\n  z-index: ", ";\n  visibility: hidden;\n  &.show {\n    visibility: visible;\n    ", ";\n  }\n"])), function (props) { return props.position.y; }, function (props) { return props.position.x; }, function (props) { return props.theme.shape.radiusMedium; }, function (props) { return props.theme.measurements.zIndex.toast; }, innAnimation);
var templateObject_1$x, templateObject_2$a, templateObject_3$7;

var ColorWrapper = styled.button.attrs({
    type: 'button',
})(templateObject_1$y || (templateObject_1$y = __makeTemplateObject(["\n  position: relative;\n  background: transparent;\n  border: none;\n  height: ", "px;\n  width: ", "px;\n  margin: 1px;\n  padding: 0;\n  cursor: pointer;\n  border-radius: ", "px;\n  &:hover,\n  &.hover {\n    opacity: 0.7;\n  }\n  ", "\n  &:disabled {\n    opacity: ", ";\n    cursor: default;\n  }\n"], ["\n  position: relative;\n  background: transparent;\n  border: none;\n  height: ", "px;\n  width: ", "px;\n  margin: 1px;\n  padding: 0;\n  cursor: pointer;\n  border-radius: ", "px;\n  &:hover,\n  &.hover {\n    opacity: 0.7;\n  }\n  ", "\n  &:disabled {\n    opacity: ", ";\n    cursor: default;\n  }\n"])), function (props) { return props.theme.measurements.color.colorItem.button.size; }, function (props) { return props.theme.measurements.color.colorItem.button.size; }, function (props) { return props.theme.shape.radiusSmall; }, States.Focused, function (props) { return props.theme.selectColor.inactiveOpacity; });
var BackgroundStyle = css(templateObject_2$b || (templateObject_2$b = __makeTemplateObject(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: ", "px;\n  width: ", "px;\n  box-sizing: border-box;\n  pointer-events: none;\n"], ["\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: ", "px;\n  width: ", "px;\n  box-sizing: border-box;\n  pointer-events: none;\n"])), function (props) { return props.theme.measurements.color.colorItem.button.size; }, function (props) { return props.theme.measurements.color.colorItem.button.size; });
var Background = styled.div.attrs(function (props) { return ({
    style: { background: props.backgroundColor },
}); })(templateObject_3$8 || (templateObject_3$8 = __makeTemplateObject(["\n  ", "\n  border-radius: ", "px;\n  border: 2px solid transparent;\n  transition: border-color 300ms ease-in-out;\n  &.active {\n    border-color: ", ";\n  }\n"], ["\n  ", "\n  border-radius: ", "px;\n  border: 2px solid transparent;\n  transition: border-color 300ms ease-in-out;\n  &.active {\n    border-color: ", ";\n  }\n"])), BackgroundStyle, function (props) { return props.theme.shape.radiusSmall; }, function (props) { return props.theme.selectColor.activeBorderColor; });
var TiledBackground = styled.div(templateObject_4$5 || (templateObject_4$5 = __makeTemplateObject(["\n  ", "\n  border-radius: ", "px;\n  background-image: url(", ");\n"], ["\n  ", "\n  border-radius: ", "px;\n  background-image: url(", ");\n"])), BackgroundStyle, function (props) { return props.theme.shape.radiusSmall + 1; }, function (props) { return props.url; });
var ActiveOverlay = styled.div(templateObject_5$4 || (templateObject_5$4 = __makeTemplateObject(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  top: 0;\n  height: ", "px;\n  width: ", "px;\n  content: ' ';\n  pointer-events: none;\n"], ["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  top: 0;\n  height: ", "px;\n  width: ", "px;\n  content: ' ';\n  pointer-events: none;\n"])), function (props) { return props.theme.measurements.color.colorItem.button.size; }, function (props) { return props.theme.measurements.color.colorItem.button.size; });
var Dot = styled.span(templateObject_6$3 || (templateObject_6$3 = __makeTemplateObject(["\n  display: inline-block;\n  height: 2px;\n  width: 2px;\n  border-radius: 50%;\n  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.6);\n  background: rgba(255, 255, 255, 0.87);\n  margin: 1px;\n  pointer-events: none;\n"], ["\n  display: inline-block;\n  height: 2px;\n  width: 2px;\n  border-radius: 50%;\n  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.6);\n  background: rgba(255, 255, 255, 0.87);\n  margin: 1px;\n  pointer-events: none;\n"])));
var ColorItem = function (_a) {
    var isActive = _a.isActive, onClick = _a.onClick, color = _a.color, label = _a.label, isDisabled = _a.isDisabled, config = _a.config;
    var onKeyDown = function (e) {
        if (e.code === 'Space' || e.code === 'Enter') {
            onClick(e);
        }
    };
    var handleOnClick = function (e) {
        onClick(e);
    };
    var url = config.assetProvider.getAbsolutePath('controls/tiled-background.png');
    return (React.createElement(ColorWrapper, { className: isActive ? 'active' : '', disabled: isDisabled, onClick: handleOnClick, onKeyDown: onKeyDown, "aria-label": label },
        React.createElement(TiledBackground, { url: url }),
        React.createElement(Background, { className: isActive ? 'active' : '', backgroundColor: color }),
        isActive && (React.createElement(ActiveOverlay, null,
            React.createElement(Dot, null),
            React.createElement(Dot, null),
            React.createElement(Dot, null)))));
};
var ColorItem$1 = inject('config')(observer(ColorItem));
Background.defaultProps = { theme: defaultStyledTheme };
TiledBackground.defaultProps = { theme: defaultStyledTheme };
ColorWrapper.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$y, templateObject_2$b, templateObject_3$8, templateObject_4$5, templateObject_5$4, templateObject_6$3;

var showStyles = css(templateObject_1$z || (templateObject_1$z = __makeTemplateObject(["\n  opacity: 1;\n  visibility: visible;\n  display: block;\n"], ["\n  opacity: 1;\n  visibility: visible;\n  display: block;\n"])));
var Backdrop = styled.div(templateObject_2$c || (templateObject_2$c = __makeTemplateObject(["\n  opacity: 0;\n  visibility: hidden;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: ", ";\n  text-align: left;\n  background: ", ";\n  transition: opacity 0.25s ease;\n  display: none;\n  height: 100%;\n  width: 100%;\n  ", "\n"], ["\n  opacity: 0;\n  visibility: hidden;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: ", ";\n  text-align: left;\n  background: ", ";\n  transition: opacity 0.25s ease;\n  display: none;\n  height: 100%;\n  width: 100%;\n  ", "\n"])), function (props) { return props.theme.measurements.zIndex.modal.backdrop; }, function (props) { return props.theme.modal.backdrop; }, function (props) { return props.show && showStyles; });
Backdrop.defaultProps = {
    theme: defaultStyledTheme,
};
var templateObject_1$z, templateObject_2$c;

var Relative = styled.div(templateObject_1$A || (templateObject_1$A = __makeTemplateObject(["\n  position: relative;\n  height: inherit;\n  width: inherit;\n"], ["\n  position: relative;\n  height: inherit;\n  width: inherit;\n"])));
var ModalContainer = styled.div.attrs(function (props) { return ({
    role: 'dialog',
    'aria-hidden': false,
    'aria-labelledby': props.heading,
}); })(templateObject_2$d || (templateObject_2$d = __makeTemplateObject(["\n  display: flex;\n  flex: 0 0 auto;\n  flex-direction: column;\n  transition: top 0.25s ease;\n  position: absolute;\n  top: ", ";\n  left: ", ";\n  width: ", ";\n  height: ", ";\n  transform: translate(-50%, -50%);\n  border-radius: ", "px;\n  background: ", ";\n  color: ", ";\n"], ["\n  display: flex;\n  flex: 0 0 auto;\n  flex-direction: column;\n  transition: top 0.25s ease;\n  position: absolute;\n  top: ", ";\n  left: ", ";\n  width: ", ";\n  height: ", ";\n  transform: translate(-50%, -50%);\n  border-radius: ", "px;\n  background: ", ";\n  color: ", ";\n"])), function (props) { return props.y; }, function (props) { return props.x; }, function (props) { return props.width; }, function (props) { return props.height; }, function (props) { return props.theme.shape.radiusLarge; }, function (props) { return props.theme.modal.background; }, function (props) { return props.theme.modal.bodyForeground; });
var ModalInner = styled.div(templateObject_3$9 || (templateObject_3$9 = __makeTemplateObject(["\n  display: flex;\n  flex: 0 0 auto;\n  flex-direction: row;\n  overflow: hidden;\n  width: inherit;\n  padding: 11px 20px;\n  box-sizing: border-box;\n"], ["\n  display: flex;\n  flex: 0 0 auto;\n  flex-direction: row;\n  overflow: hidden;\n  width: inherit;\n  padding: 11px 20px;\n  box-sizing: border-box;\n"])));
var ModalWrapper = function (_a) {
    var show = _a.show, height = _a.height, width = _a.width, position = _a.position, children = _a.children, footer = _a.footer, heading = _a.heading;
    var _b = position
        ? { x: "calc(50% + " + position.x + "px)", y: "calc(50% + " + position.y + "px)" }
        : { x: '50%', y: '50%' }, x = _b.x, y = _b.y;
    return (React.createElement(Backdrop, { show: show },
        React.createElement(Relative, null,
            React.createElement(ModalContainer, { heading: heading, x: x, y: y, height: height, width: width },
                React.createElement(ModalInner, null, children),
                footer()))));
};
ModalContainer.defaultProps = {
    theme: defaultStyledTheme,
    className: '',
};
var templateObject_1$A, templateObject_2$d, templateObject_3$9;

var rotate = keyframes(templateObject_1$B || (templateObject_1$B = __makeTemplateObject(["\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n"], ["\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n"])));
var rotateAnimationBefore = css(templateObject_2$e || (templateObject_2$e = __makeTemplateObject(["\n  animation: ", " 2s infinite ease 1.5s;\n"], ["\n  animation: ", " 2s infinite ease 1.5s;\n"])), rotate);
var rotateAnimationAfter = css(templateObject_3$a || (templateObject_3$a = __makeTemplateObject(["\n  animation: ", " 2s infinite ease;\n"], ["\n  animation: ", " 2s infinite ease;\n"])), rotate);
var Message = styled.div(templateObject_4$6 || (templateObject_4$6 = __makeTemplateObject(["\n  margin-left: 30px;\n  h3 {\n    font-size: ", "px;\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    color: ", ";\n  }\n  p {\n    font-size: ", "px;\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    color: ", ";\n  }\n"], ["\n  margin-left: 30px;\n  h3 {\n    font-size: ", "px;\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    color: ", ";\n  }\n  p {\n    font-size: ", "px;\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    color: ", ";\n  }\n"])), function (props) { return props.theme.measurements.fontSystem.headline2.size; }, function (props) { return props.theme.measurements.fontSystem.headline2.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.body.case; }, function (props) { return props.theme.modal.headerForeground; }, function (props) { return props.theme.measurements.fontSystem.label.size; }, function (props) { return props.theme.measurements.fontSystem.label.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.label.case; }, function (props) { return props.theme.modal.bodyForeground; });
var Progress = styled.div(templateObject_5$5 || (templateObject_5$5 = __makeTemplateObject(["\n  height: 4px;\n  padding: 0;\n  margin: 0;\n  background: rgba(54, 90, 252, 0.5);\n  &:after {\n    position: absolute;\n    bottom: 0px;\n    content: '';\n    width: ", "%;\n    border-bottom: 4px solid ", ";\n  }\n"], ["\n  height: 4px;\n  padding: 0;\n  margin: 0;\n  background: rgba(54, 90, 252, 0.5);\n  &:after {\n    position: absolute;\n    bottom: 0px;\n    content: '';\n    width: ", "%;\n    border-bottom: 4px solid ", ";\n  }\n"])), function (props) { return props.percentage; }, function (props) { return props.theme.primary; });
var Spinner = styled.div(templateObject_6$4 || (templateObject_6$4 = __makeTemplateObject(["\n  color: ", ";\n  margin: 12px 0;\n  position: relative;\n  width: 40px;\n  height: 40px;\n  box-shadow: inset 0 0 0 2px;\n  transform: translateZ(0);\n  border-radius: 50%;\n  &:before,\n  &:after {\n    border-radius: 50%;\n    position: absolute;\n    content: '';\n  }\n  &:before {\n    width: 25px;\n    height: 45px;\n    background: ", ";\n    border-radius: 45px 0 0 45px;\n    top: -2.5px;\n    left: -2.5px;\n    transform-origin: 25px 25px;\n    ", ";\n  }\n  &:after {\n    width: 25px;\n    height: 45px;\n    background: ", ";\n    border-radius: 0 45px 45px 0;\n    top: -2.5px;\n    left: 25px;\n    transform-origin: 0px 25px;\n    ", ";\n  }\n"], ["\n  color: ", ";\n  margin: 12px 0;\n  position: relative;\n  width: 40px;\n  height: 40px;\n  box-shadow: inset 0 0 0 2px;\n  transform: translateZ(0);\n  border-radius: 50%;\n  &:before,\n  &:after {\n    border-radius: 50%;\n    position: absolute;\n    content: '';\n  }\n  &:before {\n    width: 25px;\n    height: 45px;\n    background: ", ";\n    border-radius: 45px 0 0 45px;\n    top: -2.5px;\n    left: -2.5px;\n    transform-origin: 25px 25px;\n    ", ";\n  }\n  &:after {\n    width: 25px;\n    height: 45px;\n    background: ", ";\n    border-radius: 0 45px 45px 0;\n    top: -2.5px;\n    left: 25px;\n    transform-origin: 0px 25px;\n    ", ";\n  }\n"])), function (props) { return props.theme.primary; }, function (props) { return props.theme.modal.background; }, rotateAnimationBefore, function (props) { return props.theme.modal.background; }, rotateAnimationAfter);
var Loader = /** @class */ (function (_super) {
    __extends(Loader, _super);
    function Loader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.footer = function () { return (_this.props.progress ? React.createElement(Progress, { percentage: _this.props.percentage || 0 }) : null); };
        return _this;
    }
    Loader.prototype.render = function () {
        var _a = this.props, show = _a.show, heading = _a.heading, body = _a.body, position = _a.position;
        return (React.createElement(ModalWrapper, { show: show, position: position, height: '90px', width: '350px', footer: this.footer },
            React.createElement(Spinner, null),
            React.createElement(Message, null,
                React.createElement("h3", null, heading),
                React.createElement("p", null, body))));
    };
    return Loader;
}(React.PureComponent));
var templateObject_1$B, templateObject_2$e, templateObject_3$a, templateObject_4$6, templateObject_5$5, templateObject_6$4;

var Spacer = styled.div(templateObject_1$C || (templateObject_1$C = __makeTemplateObject(["\n  padding-bottom: ", "px;\n"], ["\n  padding-bottom: ", "px;\n"])), function (props) { return (props.count || 1) * 8; });
Spacer.defaultProps = { count: 1 };
var templateObject_1$C;

var HiddenLabel$1 = styled.label(templateObject_1$D || (templateObject_1$D = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), States.VisuallyHidden);
var InputLabel = styled.label(templateObject_2$f || (templateObject_2$f = __makeTemplateObject(["\n  &&& {\n    display: block;\n    font-size: ", "px;\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    color: ", ";\n    margin: 0;\n    &.disabled {\n      opacity: ", ";\n      cursor: default;\n      pointer-events: none;\n    }\n  }\n"], ["\n  &&& {\n    display: block;\n    font-size: ", "px;\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    color: ", ";\n    margin: 0;\n    &.disabled {\n      opacity: ", ";\n      cursor: default;\n      pointer-events: none;\n    }\n  }\n"])), function (props) { return props.theme.measurements.fontSystem.body.size; }, function (props) { return props.theme.measurements.fontSystem.body.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.body.case; }, function (props) { return props.theme.toolControlBar.inputLabelForeground; }, function (props) { return props.theme.toolControlBar.inputLabelInactiveOpacity; });
var Label = function (_a) {
    var name = _a.name, show = _a.show, styles = _a.styles, isDisabled = _a.isDisabled, className = _a.className;
    var LabelComponent = show ? InputLabel : HiddenLabel$1;
    var labelClassName = isDisabled ? 'label disabled' : 'label';
    return (React.createElement(LabelComponent, { style: styles || {}, className: className + " " + labelClassName, htmlFor: name ? name.replace(' ', '-') : '' }, name));
};
Label.defaultProps = {
    show: true,
};
InputLabel.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$D, templateObject_2$f;

var CommonInputStyles = css(templateObject_1$E || (templateObject_1$E = __makeTemplateObject(["\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  width: 100%;\n  height: 26px;\n  color: ", ";\n  padding-bottom: 7px;\n  border: none;\n  appearance: none;\n  border-bottom: 1px solid ", ";\n  background: ", ";\n  font-family: '", "', sans-serif;\n  transition: border-color 0.4s ease-in-out;\n  &:focus {\n    outline: none;\n    border-color: ", ";\n  }\n  &:-moz-focusring {\n    outline: none;\n    border-color: ", ";\n  }\n  &.disabled, &:disabled {\n    opacity: ", ";\n    pointer-events: none;\n  }\n  &:hover {\n    border-color: ", ";\n  }\n"], ["\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  width: 100%;\n  height: 26px;\n  color: ", ";\n  padding-bottom: 7px;\n  border: none;\n  appearance: none;\n  border-bottom: 1px solid ", ";\n  background: ", ";\n  font-family: '", "', sans-serif;\n  transition: border-color 0.4s ease-in-out;\n  &:focus {\n    outline: none;\n    border-color: ", ";\n  }\n  &:-moz-focusring {\n    outline: none;\n    border-color: ", ";\n  }\n  &.disabled, &:disabled {\n    opacity: ", ";\n    pointer-events: none;\n  }\n  &:hover {\n    border-color: ", ";\n  }\n"])), function (props) { return props.theme.measurements.fontSystem.body.size; }, function (props) { return props.theme.measurements.fontSystem.body.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.body.case; }, function (props) { return props.theme.textInput.foreground; }, function (props) { return props.theme.textInput.borderColor; }, function (props) { return props.theme.textInput.background; }, function (props) { return props.theme.typography.fontFamily; }, function (props) { return props.theme.textInput.hoverBorderColor; }, function (props) { return props.theme.textInput.hoverBorderColor; }, function (props) { return props.theme.textInput.inactiveOpacity; }, function (props) { return props.theme.textInput.hoverBorderColor; });
var templateObject_1$E;

var InputStyles = styled.input(templateObject_1$F || (templateObject_1$F = __makeTemplateObject(["\n  ", "\n  /* override user agent style */\n  padding: 0;\n  &:disabled {\n    opacity: ", ";\n    cursor: default;\n    pointer-events: none;\n  }\n"], ["\n  ", "\n  /* override user agent style */\n  padding: 0;\n  &:disabled {\n    opacity: ", ";\n    cursor: default;\n    pointer-events: none;\n  }\n"])), CommonInputStyles, function (props) { return props.theme.textInput.inactiveOpacity; });
var InputDiv = styled.div(templateObject_2$g || (templateObject_2$g = __makeTemplateObject(["\n  position: relative;\n  &:first-child {\n    margin-right: 15px;\n  }\n"], ["\n  position: relative;\n  &:first-child {\n    margin-right: 15px;\n  }\n"])));
var Input = /** @class */ (function (_super) {
    __extends(Input, _super);
    function Input() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onChange = function (e) {
            var onChange = _this.props.onChange;
            if (onChange) {
                onChange(e.target.value);
            }
        };
        return _this;
    }
    Input.prototype.render = function () {
        var _a = this.props, id = _a.id, value = _a.value, type = _a.type, min = _a.min, max = _a.max, onBlur = _a.onBlur, onFocus = _a.onFocus, onKeyUp = _a.onKeyUp, onKeyDown = _a.onKeyDown, onMouseUp = _a.onMouseUp, onTouchEnd = _a.onTouchEnd, isDisabled = _a.isDisabled, className = _a.className, inputClassName = _a.inputClassName, children = _a.children;
        var textClassName = isDisabled ? 'disabled' : '';
        return (React.createElement(InputDiv, { className: className + " " + textClassName },
            React.createElement(InputStyles, { id: id, "aria-hidden": isDisabled, disabled: isDisabled, value: value, type: type, min: min, max: max, onChange: this.onChange, onBlur: onBlur, onFocus: onFocus, onKeyUp: onKeyUp, onKeyDown: onKeyDown, onMouseUp: onMouseUp, onTouchEnd: onTouchEnd, className: inputClassName }),
            children));
    };
    Input.defaultProps = {
        type: 'text',
    };
    return Input;
}(React.Component));
InputStyles.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$F, templateObject_2$g;

var Root = styled.div(templateObject_3$b || (templateObject_3$b = __makeTemplateObject(["\n  ", "\n"], ["\n  ",
    "\n"])), isIE()
    ? css(templateObject_1$G || (templateObject_1$G = __makeTemplateObject([""], [""]))) : css(templateObject_2$h || (templateObject_2$h = __makeTemplateObject(["\n        display: flex;\n        flex: 0 1 auto;\n        flex-direction: column;\n      "], ["\n        display: flex;\n        flex: 0 1 auto;\n        flex-direction: column;\n      "]))));
var NummericInput = /** @class */ (function (_super) {
    __extends(NummericInput, _super);
    function NummericInput(props) {
        var _this = _super.call(this, props) || this;
        _this.node = null;
        _this.handleOutsideClick = function (e) {
            var value = _this.props.value;
            if (_this.node && _this.node.current && _this.node.current.contains(e.target)) {
                return;
            }
            _this.setState({ isActive: false, value: value });
        };
        _this.onSubmit = function () {
            var onSubmit = _this.props.onSubmit;
            var value = _this.state.value;
            if (onSubmit) {
                var cleanedValue = parseFloat(NummericInput.cleanValue(value));
                if (!Number.isNaN(cleanedValue)) {
                    onSubmit("" + cleanedValue);
                }
            }
            _this.setState({ isActive: false });
        };
        _this.onFocus = function () {
            _this.setState({ isActive: true });
        };
        _this.onKeyDown = function (e) {
            var value = _this.state.value;
            if (e.key === 'Enter') {
                _this.onSubmit();
            }
            else if (e.key === 'ArrowUp') {
                var parsedValue = parseFloat(NummericInput.cleanValue(value));
                if (typeof parsedValue === 'number') {
                    _this.setState({ value: (parsedValue + 1).toString(), isActive: true });
                }
            }
            else if (e.key === 'ArrowDown') {
                var parsedValue = parseFloat(NummericInput.cleanValue(value));
                if (typeof parsedValue === 'number') {
                    _this.setState({ value: (parsedValue - 1).toString(), isActive: true });
                }
            }
        };
        _this.onChange = function (e) {
            _this.setState({
                value: e,
                isActive: true,
            });
        };
        _this.state = {
            value: _this.props.value || '',
            isActive: false,
        };
        _this.node = React.createRef();
        document.addEventListener('mousedown', _this.handleOutsideClick, false);
        document.addEventListener('touchstart', _this.handleOutsideClick, false);
        return _this;
    }
    NummericInput.getDerivedStateFromProps = function (_a, _b) {
        var nextValue = _a.value;
        var value = _b.value, isActive = _b.isActive;
        if (nextValue !== value && !isActive) {
            return { value: nextValue };
        }
        return null;
    };
    NummericInput.cleanValue = function (value) {
        return value
            ? value
                .replace(',', '.')
                .replace(/[a-zA-Z]/g, '')
                .trim()
            : '';
    };
    NummericInput.prototype.componentWillUnmount = function () {
        document.removeEventListener('mousedown', this.handleOutsideClick, false);
        document.removeEventListener('touchstart', this.handleOutsideClick, false);
    };
    NummericInput.prototype.render = function () {
        var _a = this.props, label = _a.label, isDisabled = _a.isDisabled, ariaHidden = _a.ariaHidden, onMouseUp = _a.onMouseUp, onTouchEnd = _a.onTouchEnd, className = _a.className;
        var value = this.state.value;
        return (React.createElement(Root, { ref: this.node, className: className },
            React.createElement(Label, { name: label, show: !!label, isDisabled: isDisabled }),
            !!label && React.createElement(Spacer, null),
            React.createElement(Input, { inputClassName: "nummericInput", value: value, isDisabled: isDisabled, "aria-hidden": ariaHidden, onChange: this.onChange, onKeyDown: this.onKeyDown, onBlur: this.handleOutsideClick, onFocus: this.onFocus, onMouseUp: onMouseUp, onTouchEnd: onTouchEnd })));
    };
    NummericInput.defaultProps = {
        showLabel: true,
    };
    return NummericInput;
}(React.Component));
var templateObject_1$G, templateObject_2$h, templateObject_3$b;

var ThumbStyles = css(templateObject_1$H || (templateObject_1$H = __makeTemplateObject(["\n  width: 20px;\n  height: 20px;\n  background: ", ";\n  border: 2px solid ", ";\n  border-radius: 50%;\n  cursor: pointer;\n"], ["\n  width: 20px;\n  height: 20px;\n  background: ", ";\n  border: 2px solid ", ";\n  border-radius: 50%;\n  cursor: pointer;\n"])), function (props) { return props.theme.slider.thumbBackground; }, function (props) { return props.theme.slider.thumbBorderColor; });
var getSliderGradient = function (props) {
    var percentage = ((props.value - props.min) * 100) / (props.max - props.min);
    if (props.adjust) {
        if (props.value > 0) {
            percentage = props.value * (props.max / 2) * 100;
            return props.theme.slider.trackColor + " 0%,\n      " + props.theme.slider.trackColor + " 50%,\n      " + props.theme.slider.activeTrackColor + " 50%,\n      " + props.theme.slider.activeTrackColor + " " + (50 + percentage) + "%,\n      " + props.theme.slider.trackColor + " " + (50 + percentage) + "%,\n      " + props.theme.slider.trackColor + " 100%\n      ";
        }
        if (props.value < 0) {
            percentage = props.value * (props.min / 2) * 100;
            return props.theme.slider.trackColor + " 0%,\n      " + props.theme.slider.trackColor + " " + (50 - percentage) + "%,\n      " + props.theme.slider.activeTrackColor + " " + (50 - percentage) + "%,\n      " + props.theme.slider.activeTrackColor + " 50%,\n      " + props.theme.slider.trackColor + " 50%,\n      " + props.theme.slider.trackColor + " 100%\n      ";
        }
        return props.theme.slider.trackColor + " 0%,\n    " + props.theme.slider.trackColor + " 100%";
    }
    return props.theme.slider.activeTrackColor + " 0%,\n    " + props.theme.slider.activeTrackColor + " " + percentage + "%,\n    " + props.theme.slider.trackColor + " " + percentage + "%,\n    " + props.theme.slider.trackColor + " 100%";
};
var SliderStyles = styled.input(templateObject_4$7 || (templateObject_4$7 = __makeTemplateObject(["\n  display: flex;\n  flex: 1 0 auto;\n  appearance: none;\n  max-width: calc(100% - 50px);\n  outline: none;\n  border-radius: 0; /* iOS */\n  ", "\n  &::-moz-focus-outer {\n    /** This is to remove the dotted focus lines in firefox */\n    border: 0;\n  }\n  &:disabled {\n    opacity: ", ";\n    pointer-events: none;\n  }\n  ", "\n  &:hover {\n    opacity: ", ";\n  }\n  &::-webkit-slider-runnable-track {\n    cursor: pointer;\n    appearance: none;\n  }\n  &::-moz-range-track {\n    appearance: none;\n    cursor: pointer;\n  }\n  &::-ms-track {\n    cursor: pointer;\n    height: 5px;\n    appearance: none;\n    background: transparent;\n    color: transparent;\n    border-color: transparent;\n    border-width: 6px 0;\n  }\n  &::-webkit-slider-thumb {\n    appearance: none;\n    ", "\n  }\n  &::-moz-range-thumb {\n    appearance: none;\n    ", "\n  }\n  &::-ms-thumb {\n    appearance: none;\n    ", "\n  }\n  &::-ms-fill-lower {\n    background: ", ";\n  }\n  &::-ms-fill-upper {\n    background: ", ";\n  }\n  &::-ms-tooltip {\n    display: none;\n  }\n  @media all and (min-width: 0) and (max-width: 599px) {\n    width: 200px;\n  }\n"], ["\n  display: flex;\n  flex: 1 0 auto;\n  appearance: none;\n  max-width: calc(100% - 50px);\n  outline: none;\n  border-radius: 0; /* iOS */\n  ",
    "\n  &::-moz-focus-outer {\n    /** This is to remove the dotted focus lines in firefox */\n    border: 0;\n  }\n  &:disabled {\n    opacity: ", ";\n    pointer-events: none;\n  }\n  ", "\n  &:hover {\n    opacity: ", ";\n  }\n  &::-webkit-slider-runnable-track {\n    cursor: pointer;\n    appearance: none;\n  }\n  &::-moz-range-track {\n    appearance: none;\n    cursor: pointer;\n  }\n  &::-ms-track {\n    cursor: pointer;\n    height: 5px;\n    appearance: none;\n    background: transparent;\n    color: transparent;\n    border-color: transparent;\n    border-width: 6px 0;\n  }\n  &::-webkit-slider-thumb {\n    appearance: none;\n    ", "\n  }\n  &::-moz-range-thumb {\n    appearance: none;\n    ", "\n  }\n  &::-ms-thumb {\n    appearance: none;\n    ", "\n  }\n  &::-ms-fill-lower {\n    background: ", ";\n  }\n  &::-ms-fill-upper {\n    background: ", ";\n  }\n  &::-ms-tooltip {\n    display: none;\n  }\n  @media all and (min-width: 0) and (max-width: 599px) {\n    width: 200px;\n  }\n"])), isEdge() || isIE()
    ? css(templateObject_2$i || (templateObject_2$i = __makeTemplateObject(["\n        margin-top: 10px;\n        height: 24px;\n      "], ["\n        margin-top: 10px;\n        height: 24px;\n      "]))) : css(templateObject_3$c || (templateObject_3$c = __makeTemplateObject(["\n        height: 2px;\n        background: ", ";\n      "], ["\n        height: 2px;\n        background: ", ";\n      "])), function (props) { return "linear-gradient(to right, " + getSliderGradient(props) + ")"; }), function (props) { return props.theme.slider.inactiveOpacity; }, States.Focused, function (props) { return props.theme.slider.hoverOpacity; }, ThumbStyles, ThumbStyles, ThumbStyles, function (props) { return "" + props.theme.slider.activeTrackColor; }, function (props) { return "" + props.theme.slider.trackColor; });
var Container$1 = styled.div(templateObject_5$6 || (templateObject_5$6 = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  height: 26px;\n  margin-right: ", "px;\n"], ["\n  display: flex;\n  align-items: center;\n  height: 26px;\n  margin-right: ", "px;\n"])), function (props) { return (props.centerSlider ? -56 : 0); });
var Text = styled(NummericInput)(templateObject_6$5 || (templateObject_6$5 = __makeTemplateObject(["\n  max-width: 50px;\n  padding-left: 16px;\n  > div > input {\n    text-align: center;\n  }\n"], ["\n  max-width: 50px;\n  padding-left: 16px;\n  > div > input {\n    text-align: center;\n  }\n"
    /**
     * There are differnt types of event handlers for different cases
     * on every Change UI will be rendered
     * on every MouseUp or TouchEnd a history snapshot will be added
     */
])));
var random = uuid();
// inputActive State is not being used in render but it's used in inputValue calculations
// eslint-disable:react/no-unused-state
var Slider = /** @class */ (function (_super) {
    __extends(Slider, _super);
    function Slider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onSubmit = function (value) {
            var _a = _this.props, onChange = _a.onChange, suffix = _a.suffix, divider = _a.divider, min = _a.min, max = _a.max, oldValue = _a.value;
            var cleanedValue = value.replace(suffix, '');
            var parsedValue = cleanedValue ? parseFloat(cleanedValue) / divider : oldValue;
            var clampedValue = Math.max(min, Math.min(max, parsedValue));
            if (!Number.isNaN(clampedValue)) {
                onChange(clampedValue);
                if (_this.props.onMouseUp) {
                    _this.props.onMouseUp();
                }
                else if (_this.props.onTouchEnd) {
                    _this.props.onTouchEnd();
                }
            }
        };
        _this.onSliderChange = function (e) {
            var onChange = _this.props.onChange;
            var v = parseFloat(e.target.value);
            onChange(v);
        };
        return _this;
    }
    Slider.prototype.render = function () {
        var _a = this.props, value = _a.value, snap = _a.snap, min = _a.min, max = _a.max, divider = _a.divider, suffix = _a.suffix, decimal = _a.decimal, showLabel = _a.showLabel, showInput = _a.showInput, style = _a.style, centerSlider = _a.centerSlider, adjust = _a.adjust, name = _a.name, isDisabled = _a.isDisabled, step = _a.step, ariaHidden = _a["aria-hidden"], onMouseUp = _a.onMouseUp, onTouchEnd = _a.onTouchEnd, className = _a.className;
        var id = name.replace(' ', '-') + random;
        var snapOption = typeof snap === 'number' && (React.createElement("datalist", { id: id + "-list" },
            React.createElement("option", { value: snap })));
        var inputValue = "" + (value * divider).toFixed(decimal) + suffix;
        var input = showInput && (React.createElement(Text, { value: inputValue, isDisabled: isDisabled, "aria-hidden": ariaHidden, onSubmit: this.onSubmit }));
        return (React.createElement("div", { className: className },
            React.createElement(Label, { isDisabled: isDisabled, name: name, show: showLabel }),
            React.createElement(Spacer, { count: 0.25 }),
            React.createElement(Container$1, { centerSlider: showInput && centerSlider },
                React.createElement(SliderStyles, { type: "range", role: "slider", "aria-hidden": ariaHidden, tabIndex: 0, value: value, min: min, max: max, step: step, style: style, disabled: isDisabled, id: id, list: id + "-list", onChange: this.onSliderChange, adjust: adjust, name: name, onKeyUp: this.onSliderChange, onKeyDown: this.onSliderChange, onMouseUp: onMouseUp, onTouchEnd: onTouchEnd }),
                snapOption,
                input)));
    };
    Slider.defaultProps = {
        showLabel: true,
        showInput: true,
        adjust: false,
        centerSlider: false,
        min: -1,
        max: 1,
        value: 0,
        step: 0.01,
        decimal: 0,
        divider: 100,
        suffix: '',
    };
    return Slider;
}(React.Component));
SliderStyles.defaultProps = {
    theme: defaultStyledTheme,
};
var templateObject_1$H, templateObject_2$i, templateObject_3$c, templateObject_4$7, templateObject_5$6, templateObject_6$5;

var InputStyles$1 = styled.input.attrs({
    type: 'search',
})(templateObject_1$I || (templateObject_1$I = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), CommonInputStyles);
var Search = function (props) {
    var onChange = function (e) {
        props.onChange(e.target.value);
    };
    return (React.createElement("div", null,
        React.createElement(Label, { show: false, name: 'Search' }),
        React.createElement(InputStyles$1, { id: "Search", onChange: onChange, placeholder: props.placeholder })));
};
InputStyles$1.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$I;

var PrimaryButton = styled(BaseButton)(templateObject_1$J || (templateObject_1$J = __makeTemplateObject(["\n  height: inherit;\n  background: transparent;\n  color: ", ";\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n"], ["\n  height: inherit;\n  background: transparent;\n  color: ", ";\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n"])), function (props) { return props.theme.button.textPrimaryForeground; }, function (props) { return props.theme.measurements.fontSystem.label.size; }, function (props) { return props.theme.measurements.fontSystem.label.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.label.case; });
var SecondaryButton = styled(BaseButton)(templateObject_2$j || (templateObject_2$j = __makeTemplateObject(["\n  height: inherit;\n  background: transparent;\n  font-size: ", "px;\n  color: ", ";\n  letter-spacing: ", "px;\n  text-transform: ", ";\n"], ["\n  height: inherit;\n  background: transparent;\n  font-size: ", "px;\n  color: ", ";\n  letter-spacing: ", "px;\n  text-transform: ", ";\n"])), function (props) { return props.theme.measurements.fontSystem.label.size; }, function (props) { return props.theme.button.textSecondaryForeground; }, function (props) { return props.theme.measurements.fontSystem.label.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.label.case; });
var ButtonContainer = styled.div(templateObject_3$d || (templateObject_3$d = __makeTemplateObject(["\n  display: flex;\n  justify-content: flex-end;\n  width: inherit;\n  text-align: right;\n  height: 40px;\n"], ["\n  display: flex;\n  justify-content: flex-end;\n  width: inherit;\n  text-align: right;\n  height: 40px;\n"])));
var templateObject_1$J, templateObject_2$j, templateObject_3$d;

// had to wrap the textarea in a styled div
// since innerRef are deprecated with styled components v4.x
// and ref will not access the dom node in v3.x
var InputStyles$2 = styled.div(templateObject_1$K || (templateObject_1$K = __makeTemplateObject(["\n  textarea {\n    caret-color: ", ";\n    ", "\n    height: 44px;\n    outline-offset: -8px;\n    color: ", ";\n    resize: none;\n    font-family: '", "', sans-serif;\n    &:selection, &:-moz-selection {\n      background-color: ", ";\n      color: ", ";\n    }\n  }\n"], ["\n  textarea {\n    caret-color: ", ";\n    ", "\n    height: 44px;\n    outline-offset: -8px;\n    color: ", ";\n    resize: none;\n    font-family: '", "', sans-serif;\n    &:selection, &:-moz-selection {\n      background-color: ", ";\n      color: ", ";\n    }\n  }\n"])), function (props) { return props.theme.primary; }, CommonInputStyles, function (props) { return props.theme.modal.bodyForeground; }, function (props) { return props.theme.typography.fontFamily; }, function (props) { return props.theme.primary; }, function (props) { return props.theme.foreground; });
var Label$1 = styled.label(templateObject_2$k || (templateObject_2$k = __makeTemplateObject(["\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  color: ", ";\n"], ["\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  color: ", ";\n"])), function (props) { return props.theme.measurements.fontSystem.label.size; }, function (props) { return props.theme.measurements.fontSystem.label.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.label.case; }, function (props) { return props.theme.modal.headerForeground; });
var InputEdit = /** @class */ (function (_super) {
    __extends(InputEdit, _super);
    function InputEdit(props) {
        var _this = _super.call(this, props) || this;
        _this.state = { value: '' };
        _this.handleKeydown = function (e) {
            switch (e.key) {
                case 'Escape':
                    _this.close();
                    break;
            }
        };
        _this.close = function () {
            _this.props.close(false);
        };
        _this.save = function () {
            var value = _this.input.value;
            if (_this.input.value) {
                _this.props.save(value);
                _this.close();
            }
        };
        _this.onChange = function (e) {
            _this.setState({ value: e.target.value });
        };
        _this.onSubmit = function (e) {
            e.preventDefault();
        };
        _this.inputRef = function (el) {
            _this.input = el;
        };
        return _this;
    }
    InputEdit.prototype.componentDidMount = function () {
        var _a = this.props, text = _a.text, defaultText = _a.defaultText;
        this.input.focus();
        this.input.value = text || defaultText || '';
        this.setState({ value: this.input.value });
        document.addEventListener('keydown', this.handleKeydown, false);
        if (text === defaultText) {
            this.input.select();
        }
    };
    InputEdit.prototype.componentWillUnmount = function () {
        document.removeEventListener('keydown', this.handleKeydown, false);
    };
    InputEdit.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.show !== this.props.show) {
            if (this.props.show) {
                this.input.focus();
            }
        }
    };
    InputEdit.prototype.render = function () {
        var _this = this;
        var _a = this.props, show = _a.show, position = _a.position;
        var footer = function () { return (React.createElement(ButtonContainer, null,
            React.createElement(SecondaryButton, { ariaLabel: _this.props.closeLabel, onClick: _this.close }, _this.props.closeLabel || 'Cancel'),
            React.createElement(PrimaryButton, { ariaLabel: _this.props.saveLabel, isDisabled: !_this.state.value, onClick: _this.save }, _this.props.saveLabel || 'Done'))); };
        return (React.createElement(ModalWrapper, { show: show || false, height: "fit-content", width: "350px", position: position, footer: footer, "aria-describedby": "Edit the selected text content" },
            React.createElement("form", { style: { width: 'inherit' }, onSubmit: this.onSubmit },
                React.createElement(Label$1, { htmlFor: "TextInput" }, this.props.editLabel || 'Text Input'),
                React.createElement(Spacer, null),
                React.createElement(InputStyles$2, null,
                    React.createElement("textarea", { id: "TextInput", placeholder: "Write Something", rows: 3, 
                        // this is a perfectly valis use case to usecase for autofocus https://www.brucelawson.co.uk/2009/the-accessibility-of-html-5-autofocus/
                        // eslint-disable-next-line jsx-a11y/no-autofocus
                        autoFocus: true, onChange: this.onChange, ref: this.inputRef })))));
    };
    InputEdit.defaultProps = {
        defaultText: 'Write Something',
    };
    return InputEdit;
}(React.Component));
var templateObject_1$K, templateObject_2$k;

var FileInputStyles = styled.input.attrs({
    type: 'file',
    id: 'fileUpload',
    accept: 'image/png, image/jpeg',
})(templateObject_1$L || (templateObject_1$L = __makeTemplateObject(["\n  display: none;\n"], ["\n  display: none;\n"])));
var templateObject_1$L;

var form = function (_a) {
    var children = _a.children;
    var onSubmit = function (e) {
        e.preventDefault();
    };
    return React.createElement("form", { onSubmit: onSubmit }, children);
};

var show = css(templateObject_1$M || (templateObject_1$M = __makeTemplateObject(["\n  visibility: visible;\n  opacity: 1;\n  display: block;\n"], ["\n  visibility: visible;\n  opacity: 1;\n  display: block;\n"])));
var DropdownContainer = styled.div(templateObject_2$l || (templateObject_2$l = __makeTemplateObject(["\n  color: ", ";\n  background-color: ", ";\n  display: block;\n  position: relative;\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  width: 100%;\n  white-space: nowrap;\n  transition-duration: 0.5s;\n  &:focus a,\n  &.toggle a {\n    outline: none;\n  }\n  &.toggle > ul {\n    ", "\n  }\n  &:hover {\n    color: ", ";\n  }\n  &:disabled,\n  &.disabled {\n    opacity: ", ";\n    pointer-events: none;\n  }\n"], ["\n  color: ", ";\n  background-color: ", ";\n  display: block;\n  position: relative;\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  width: 100%;\n  white-space: nowrap;\n  transition-duration: 0.5s;\n  &:focus a,\n  &.toggle a {\n    outline: none;\n  }\n  &.toggle > ul {\n    ", "\n  }\n  &:hover {\n    color: ", ";\n  }\n  &:disabled,\n  &.disabled {\n    opacity: ", ";\n    pointer-events: none;\n  }\n"])), function (props) { return props.theme.dropdown.foreground; }, function (props) { return props.theme.dropdown.background; }, function (props) { return props.theme.measurements.fontSystem.label.size; }, function (props) { return props.theme.measurements.fontSystem.label.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.label.case; }, show, function (props) { return props.theme.dropdown.hoverBorderColor; }, function (props) { return props.theme.dropdown.inactiveOpacity; });
DropdownContainer.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$M, templateObject_2$l;

var DropdownItem = styled.li(templateObject_1$N || (templateObject_1$N = __makeTemplateObject(["\n  padding: 10px 16px;\n  text-overflow: ellipsis;\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  white-space: nowrap;\n  color: ", ";\n  &:hover,\n  &.hover {\n    cursor: pointer;\n    background: ", ";\n  }\n  &.active {\n    border-left: 2px solid ", ";\n  }\n  ", "\n"], ["\n  padding: 10px 16px;\n  text-overflow: ellipsis;\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  white-space: nowrap;\n  color: ", ";\n  &:hover,\n  &.hover {\n    cursor: pointer;\n    background: ", ";\n  }\n  &.active {\n    border-left: 2px solid ", ";\n  }\n  ", "\n"])), function (props) { return props.theme.measurements.fontSystem.button2.size; }, function (props) { return props.theme.measurements.fontSystem.button2.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.button2.case; }, function (props) { return props.theme.dropdown.foreground; }, function (props) { return props.theme.dropdown.listItemHoverBackground; }, function (props) { return props.theme.primary; }, States.Focused);
DropdownItem.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$N;

var DropdownList = styled.ul.attrs(function (_a) {
    var scrollable = _a.scrollable;
    return ({
        'data-simplebar': scrollable ? 'init' : null,
        'data-simplebar-auto-hide': scrollable ? 'false' : null,
    });
})(templateObject_1$O || (templateObject_1$O = __makeTemplateObject(["\n  list-style: none;\n  background: ", ";\n  color: ", ";\n  border: 1px solid ", ";\n  box-shadow: ", ";\n  visibility: hidden;\n  opacity: 0;\n  min-width: 5rem;\n  position: absolute;\n  transition: all 0.5s ease;\n  left: -1px;\n  display: none;\n  padding: unset;\n  width: 100%;\n  z-index: ", ";\n  max-height: 160px;\n  overflow-x: hidden;\n  margin: 5px 0;\n  border-radius: 0 0 ", "px ", "px;\n  &[data-simplebar] {\n    position: absolute;\n  }\n"], ["\n  list-style: none;\n  background: ", ";\n  color: ", ";\n  border: 1px solid ", ";\n  box-shadow: ", ";\n  visibility: hidden;\n  opacity: 0;\n  min-width: 5rem;\n  position: absolute;\n  transition: all 0.5s ease;\n  left: -1px;\n  display: none;\n  padding: unset;\n  width: 100%;\n  z-index: ", ";\n  max-height: 160px;\n  overflow-x: hidden;\n  margin: 5px 0;\n  border-radius: 0 0 ", "px ", "px;\n  &[data-simplebar] {\n    position: absolute;\n  }\n"])), function (props) { return props.theme.dropdown.listBackground; }, function (props) { return props.theme.dropdown.listForeground; }, function (props) { return props.theme.dropdown.listBorderColor; }, function (props) { return props.theme.dropdown.listShadow; }, function (props) { return props.theme.measurements.zIndex.input.list; }, function (props) { return props.theme.shape.radiusMedium; }, function (props) { return props.theme.shape.radiusMedium; });
DropdownList.defaultProps = {
    theme: defaultStyledTheme,
    scrollable: true,
};
var templateObject_1$O;

var DropdownCaret = styled.div(templateObject_1$P || (templateObject_1$P = __makeTemplateObject(["\n  position: absolute;\n  width: 0;\n  height: 0;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n  border-top: 5px solid ", ";\n  transform: rotate(", "deg);\n  display: inline-block;\n  transition-duration: 0.3s;\n  transition-timing-function: ease-in;\n  right: 0;\n  top: 13px;\n"], ["\n  position: absolute;\n  width: 0;\n  height: 0;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n  border-top: 5px solid ", ";\n  transform: rotate(", "deg);\n  display: inline-block;\n  transition-duration: 0.3s;\n  transition-timing-function: ease-in;\n  right: 0;\n  top: 13px;\n"])), function (props) { return props.theme.dropdown.caretColor; }, function (props) { return props.rotation || 0; });
var Div = styled.div(templateObject_2$m || (templateObject_2$m = __makeTemplateObject(["\n  line-height: 17px;\n  color: ", ";\n  background-color: ", ";\n  border: none;\n  border-bottom: 1px solid ", ";\n  padding: 5px 0;\n  cursor: ", ";\n  &:hover {\n    border-color: ", ";\n  }\n  transition: border-color 0.4s ease-in-out;\n  ", "\n"], ["\n  line-height: 17px;\n  color: ", ";\n  background-color: ", ";\n  border: none;\n  border-bottom: 1px solid ", ";\n  padding: 5px 0;\n  cursor: ", ";\n  &:hover {\n    border-color: ", ";\n  }\n  transition: border-color 0.4s ease-in-out;\n  ", "\n"])), function (props) { return props.theme.dropdown.foreground; }, function (props) { return props.theme.dropdown.background; }, function (props) { return props.theme.dropdown.borderColor; }, function (props) { return (props.showList ? 'pointer' : 'default'); }, function (props) { return props.theme.dropdown.hoverBorderColor; }, States.Focused);
var Dropdown = /** @class */ (function (_super) {
    __extends(Dropdown, _super);
    function Dropdown(props) {
        var _this = _super.call(this, props) || this;
        _this.state = { isOpen: false };
        _this.handleOutsideClick = function (e) {
            if (_this.node && _this.node.contains(e.target)) {
                return;
            }
            _this.setState({ isOpen: false });
        };
        _this.onSelect = function (identifier) {
            _this.props.onSelect(identifier);
            _this.setState({ isOpen: false });
        };
        _this.onClick = function () {
            _this.setState(function (state) { return ({ isOpen: !state.isOpen }); });
        };
        _this.listItem = function (item) {
            var _a = _this.props, itemStyle = _a.itemStyle, selectedItem = _a.selectedItem;
            var value = item.value, label = item.label;
            var style = {};
            if (typeof itemStyle === 'function') {
                style = itemStyle(item);
            }
            else if (itemStyle !== null && typeof itemStyle === 'object') {
                style = itemStyle;
            }
            var className = selectedItem === value ? 'active' : '';
            return (React.createElement(DropdownItem, { "aria-hidden": !_this.state.isOpen, tabIndex: 0, style: style, onClick: function () { return _this.onSelect(value); }, key: value, className: className }, label));
        };
        _this.onKeyDown = function (e) {
            if (e.code === 'Space' || e.code === 'Enter') {
                _this.onClick();
            }
        };
        _this.nodeRef = function (element) {
            _this.node = element;
        };
        return _this;
    }
    Dropdown.prototype.componentDidMount = function () {
        document.addEventListener('mousedown', this.handleOutsideClick, false);
    };
    Dropdown.prototype.componentWillUnmount = function () {
        document.removeEventListener('mousedown', this.handleOutsideClick, false);
    };
    Dropdown.prototype.render = function () {
        var _a = this.props, selectedItem = _a.selectedItem, list = _a.list, label = _a.label, style = _a.style, isDisabled = _a.isDisabled;
        var isOpen = this.state.isOpen;
        var showList = list.length > 1;
        var openClassName = isOpen ? 'toggle' : '';
        var className = isDisabled ? 'disabled' : openClassName;
        var tabable = isDisabled ? {} : { tabIndex: 0 };
        return (React.createElement("div", { className: "dropdown" },
            React.createElement(Label, { isDisabled: isDisabled, styles: { paddingLeft: 0 }, name: label }),
            React.createElement(Spacer, null),
            React.createElement("div", { ref: this.nodeRef },
                React.createElement(DropdownContainer, { id: label.replace(' ', '-'), className: className },
                    React.createElement(Div, __assign({ "aria-hidden": isDisabled }, tabable, { showList: showList, style: style, onClick: showList ? this.onClick : undefined, onKeyDown: this.onKeyDown }),
                        selectedItem,
                        showList && React.createElement(DropdownCaret, { rotation: isOpen ? 180 : 0 })),
                    React.createElement(DropdownList, { scrollable: list.length > 4 }, showList && list.map(this.listItem))))));
    };
    return Dropdown;
}(React.PureComponent));
var templateObject_1$P, templateObject_2$m;

/**
 * Custom checkbox, working in-sync with browser checkbox
 */
var CheckMark = styled.div.attrs({
    tabIndex: 0,
})(templateObject_1$Q || (templateObject_1$Q = __makeTemplateObject(["\n  position: absolute;\n  top: 5px;\n  right: 0;\n  height: 16px;\n  width: 16px;\n  background-color: ", ";\n  border-radius: ", "px;\n  transition-timing-function: ease-in;\n  transition-duration: 0.3s;\n  &::after {\n    content: '';\n    position: absolute;\n    display: inline-block;\n    left: 5px;\n    top: 1px;\n    width: 5px;\n    height: 10px;\n    border-style: solid;\n    border-width: 0 2px 2px 0;\n    border-color: transparent;\n    transform: rotate(45deg) scale(0.8);\n  }\n  ", "\n"], ["\n  position: absolute;\n  top: 5px;\n  right: 0;\n  height: 16px;\n  width: 16px;\n  background-color: ", ";\n  border-radius: ", "px;\n  transition-timing-function: ease-in;\n  transition-duration: 0.3s;\n  &::after {\n    content: '';\n    position: absolute;\n    display: inline-block;\n    left: 5px;\n    top: 1px;\n    width: 5px;\n    height: 10px;\n    border-style: solid;\n    border-width: 0 2px 2px 0;\n    border-color: transparent;\n    transform: rotate(45deg) scale(0.8);\n  }\n  ", "\n"])), function (props) { return props.theme.checkbox.background; }, function (props) { return props.theme.shape.radiusSmall; }, States.Focused);
var CheckboxContainer = styled.div(templateObject_2$n || (templateObject_2$n = __makeTemplateObject(["\n  display: block;\n  position: relative;\n  margin-bottom: 12px;\n  cursor: pointer;\n  max-width: ", "px;\n  label {\n    padding-top: 5px;\n  }\n"], ["\n  display: block;\n  position: relative;\n  margin-bottom: 12px;\n  cursor: pointer;\n  max-width: ", "px;\n  label {\n    padding-top: 5px;\n  }\n"])), function (props) { return props.theme.measurements.basicToolControlBar.maxWidth; });
var Input$1 = styled.input.attrs({
    type: 'checkbox',
    tabIndex: 0,
})(templateObject_3$e || (templateObject_3$e = __makeTemplateObject(["\n  position: absolute;\n  opacity: 0;\n  cursor: pointer;\n  height: 0;\n  width: 0;\n  ", "\n\n  &:hover ~ ", " {\n    opacity: ", ";\n  }\n\n  &:checked ~ ", " {\n    background-color: ", ";\n    &::after {\n      color: ", ";\n      border-color: ", ";\n    }\n    &:hover {\n      background-color: ", ";\n      opacity: 0.80;\n    }\n  }\n\n  &:disabled ~ ", " {\n    opacity: 0.5;\n    cursor: default;\n    pointer-events: none;\n  }\n"], ["\n  position: absolute;\n  opacity: 0;\n  cursor: pointer;\n  height: 0;\n  width: 0;\n  ", "\n\n  &:hover ~ ", " {\n    opacity: ", ";\n  }\n\n  &:checked ~ ", " {\n    background-color: ", ";\n    &::after {\n      color: ", ";\n      border-color: ", ";\n    }\n    &:hover {\n      background-color: ", ";\n      opacity: 0.80;\n    }\n  }\n\n  &:disabled ~ ", " {\n    opacity: 0.5;\n    cursor: default;\n    pointer-events: none;\n  }\n"])), States.Focused, CheckMark, function (props) { return props.theme.checkbox.hoverOpacity; }, CheckMark, function (props) { return props.theme.checkbox.activeBackground; }, function (props) { return props.theme.checkbox.activeForeground; }, function (props) { return props.theme.checkbox.foreground; }, function (props) { return props.theme.checkbox.activeBackground; }, CheckMark);
var Checkbox = function (_a) {
    var label = _a.label, value = _a.value, toggle = _a.onChange, style = _a.style, isDisabled = _a.isDisabled;
    return (React.createElement(CheckboxContainer, null,
        React.createElement(Label, { isDisabled: isDisabled, name: label }),
        React.createElement(Input$1, { id: label.replace(' ', '-'), onChange: toggle, disabled: isDisabled, checked: value, onKeyUp: toggle }),
        React.createElement(CheckMark, { style: style || {}, onClick: toggle })));
};
Checkbox.defaultProps = {
    value: false,
};
var templateObject_1$Q, templateObject_2$n, templateObject_3$e;

// 0.6 of width here refers to the width of the container without padding
var CarouselButton = styled(BaseButton)(templateObject_1$R || (templateObject_1$R = __makeTemplateObject(["\n  color: ", ";\n  height: 32px;\n  padding: 1px 7px 2px;\n"], ["\n  color: ", ";\n  height: 32px;\n  padding: 1px 7px 2px;\n"])), function (props) { return props.theme.button.textSecondaryForeground; });
var CarouselContainer = styled.div(templateObject_2$o || (templateObject_2$o = __makeTemplateObject(["\n  display: flex;\n  justify-content: space-between;\n  width: ", "px;\n"], ["\n  display: flex;\n  justify-content: space-between;\n  width: ", "px;\n"])), function (props) { return props.theme.measurements.advancedToolControlBar.width - 48; });
var Slide = styled.article(templateObject_3$f || (templateObject_3$f = __makeTemplateObject(["\n  width: ", "px;\n  font-size: ", "px;\n  text-transform: ", ";\n  text-align: center;\n  margin-top: 9px;\n  display: inline-block;\n  color: ", ";\n"], ["\n  width: ", "px;\n  font-size: ", "px;\n  text-transform: ", ";\n  text-align: center;\n  margin-top: 9px;\n  display: inline-block;\n  color: ", ";\n"])), function (props) { return 0.6 * props.theme.measurements.advancedToolControlBar.width; }, function (props) { return props.theme.measurements.fontSystem.headline2.size; }, function (props) { return props.theme.measurements.fontSystem.body.case; }, function (props) { return props.theme.toolControlBar.inputLabelForeground; });
var SliderWrapper = styled.div(templateObject_4$8 || (templateObject_4$8 = __makeTemplateObject(["\n  width: ", "px;\n  transform: translateZ(0);\n  overflow: hidden;\n  transition: all 500ms ease-out;\n"], ["\n  width: ", "px;\n  transform: translateZ(0);\n  overflow: hidden;\n  transition: all 500ms ease-out;\n"])), function (props) { return 0.6 * props.theme.measurements.advancedToolControlBar.width; });
var SlideText = styled.span(templateObject_5$7 || (templateObject_5$7 = __makeTemplateObject(["\n  width: ", "px;\n  margin-left: -", "px;\n  position: relative;\n  display: inline-block;\n  transform: translateZ(0);\n  transition: all 600ms cubic-bezier(0.77, 0, 0.175, 1);\n  font-family: '", "', sans-serif;\n"], ["\n  width: ", "px;\n  margin-left: -", "px;\n  position: relative;\n  display: inline-block;\n  transform: translateZ(0);\n  transition: all 600ms cubic-bezier(0.77, 0, 0.175, 1);\n  font-family: '", "', sans-serif;\n"])), function (props) { return props.length * 0.6 * props.theme.measurements.advancedToolControlBar.width; }, function (props) { return props.activeIndex * 0.6 * props.theme.measurements.advancedToolControlBar.width; }, function (props) { return props.theme.typography.fontFamily; });
var CarouselArrow = styled.div(templateObject_6$6 || (templateObject_6$6 = __makeTemplateObject(["\n  border: solid ", ";\n  border-width: 0 2px 2px 0;\n  padding: 3px;\n  height: 0;\n  width: 0;\n  &.left {\n    margin-left: 2px;\n    transform: rotate(135deg);\n  }\n  &.right {\n    margin-right: 2px;\n    transform: rotate(-45deg);\n  }\n"], ["\n  border: solid ", ";\n  border-width: 0 2px 2px 0;\n  padding: 3px;\n  height: 0;\n  width: 0;\n  &.left {\n    margin-left: 2px;\n    transform: rotate(135deg);\n  }\n  &.right {\n    margin-right: 2px;\n    transform: rotate(-45deg);\n  }\n"])), function (props) { return props.theme.card.foreground; });
/**
 * Carousel Slider Component, user in Overlay tool Blend Mode
 */
var CarouselSlider = /** @class */ (function (_super) {
    __extends(CarouselSlider, _super);
    function CarouselSlider(props) {
        var _this = _super.call(this, props) || this;
        /**
         * Updates index of currently selected item from the list
         * It also takes care that the index is not less than 0 or greater than the highest value
         */
        _this.updateIndex = function (index, reverse) {
            if (reverse === void 0) { reverse = false; }
            var activeIndex = index + (reverse ? -1 : 1);
            var lastIndex = _this.props.list.length - 1;
            if (activeIndex > lastIndex) {
                activeIndex = 0;
            }
            if (activeIndex < 0) {
                activeIndex = lastIndex;
            }
            _this.props.onSelect(_this.props.list[activeIndex].identifier);
        };
        /**
         * Returns the currently active index, if that doesn't exists returns the default identifier index
         */
        _this.getActiveIndex = function (defaultIdentifier) {
            var list = _this.props.list;
            var index = list.findIndex(function (item) { return item.identifier === defaultIdentifier; });
            return index !== -1 ? index : 0;
        };
        _this.throttledUpdateIndex = lodash_throttle(_this.updateIndex, 600);
        return _this;
    }
    CarouselSlider.prototype.render = function () {
        var _this = this;
        var _a = this.props, list = _a.list, label = _a.label, _b = _a.showLabel, showLabel = _b === void 0 ? true : _b;
        var activeIndex = this.getActiveIndex(this.props.defaultIdentifier);
        var isDisabled = list.length <= 1;
        return (React.createElement("div", null,
            React.createElement(Label, { show: showLabel, name: label }),
            showLabel ? React.createElement(Spacer, null) : null,
            React.createElement(CarouselContainer, { id: label.replace(' ', '-') },
                React.createElement(CarouselButton, { ariaLabel: 'Select Previous', isDisabled: isDisabled, onClick: function () { return _this.throttledUpdateIndex(activeIndex, true); } },
                    React.createElement(CarouselArrow, { className: "left" })),
                React.createElement(SliderWrapper, null,
                    React.createElement(SlideText, { activeIndex: activeIndex, length: list.length }, list.map(function (item) { return (React.createElement(Slide, { key: item.identifier }, item.value)); }))),
                React.createElement(CarouselButton, { ariaLabel: 'Select Next', isDisabled: isDisabled, onClick: function () { return _this.throttledUpdateIndex(activeIndex); } },
                    React.createElement(CarouselArrow, { className: "right" })))));
    };
    CarouselSlider.defaultProps = {
        showLabel: true,
    };
    return CarouselSlider;
}(React.PureComponent));
var templateObject_1$R, templateObject_2$o, templateObject_3$f, templateObject_4$8, templateObject_5$7, templateObject_6$6;

var Selection = function (_a) {
    var label = _a.label, children = _a.children, inline = _a.inline, showLabel = _a.showLabel, isDisabled = _a.isDisabled;
    return (React.createElement("div", { className: "selection" },
        React.createElement(Label, { isDisabled: isDisabled, name: label, show: showLabel }),
        (showLabel && React.createElement(Spacer, null)) || null,
        React.createElement(ButtonGroup$1, { id: label.replace(' ', '-'), inline: !!inline }, children)));
};
var ButtonGroup$1 = styled.div(templateObject_2$p || (templateObject_2$p = __makeTemplateObject(["\n  display: inline-flex;\n  ", "\n"], ["\n  display: inline-flex;\n  ",
    "\n"])), function (props) {
    return (!props.inline && css(templateObject_1$S || (templateObject_1$S = __makeTemplateObject(["\n        flex-wrap: wrap;\n      "], ["\n        flex-wrap: wrap;\n      "])))) ||
        '';
});
Selection.defaultProps = {
    showLabel: true,
};
var templateObject_1$S, templateObject_2$p;

function findInArray(array, callback) {
    for (var i = 0, length_1 = array.length; i < length_1; i += 1) {
        if (callback.apply(callback, [array[i], i, array])) {
            return array[i];
        }
    }
    return null;
}
// https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
function isFunction$1(func) {
    return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}
function isNum(num) {
    return typeof num === 'number' && !Number.isNaN(num);
}
function int(a) {
    return parseInt(a, 10);
}

var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
function kebabToTitleCase(str) {
    var out = '';
    var shouldCapitalize = true;
    var i;
    for (i = 0; i < str.length; i += 1) {
        if (shouldCapitalize) {
            out += str[i].toUpperCase();
            shouldCapitalize = false;
        }
        else if (str[i] === '-') {
            shouldCapitalize = true;
        }
        else {
            out += str[i];
        }
    }
    return out;
}
function browserPrefixToKey(prop, prefix) {
    return prefix ? "" + prefix + kebabToTitleCase(prop) : prop;
}
function getPrefix(prop) {
    if (prop === void 0) { prop = 'transform'; }
    if (typeof window === 'undefined' || typeof window.document === 'undefined') {
        return '';
    }
    var style = window.document.documentElement.style;
    if (prop in style) {
        return '';
    }
    var i;
    for (i = 0; i < prefixes.length; i += 1) {
        if (browserPrefixToKey(prop, prefixes[i]) in style) {
            return prefixes[i];
        }
    }
    return '';
}
var browserPrefix = getPrefix();

var matchesSelectorFunc = '';
function matchesSelector(el, selector) {
    if (!matchesSelectorFunc) {
        matchesSelectorFunc = findInArray(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
            return isFunction$1(el[method]);
        });
    }
    if (!isFunction$1(el[matchesSelectorFunc])) {
        return false;
    }
    return el[matchesSelectorFunc](selector);
}
/** Works up the tree to the draggable itself attempting to match selector */
function matchesSelectorAndParentsTo(el, selector, baseNode) {
    var node = el;
    do {
        if (matchesSelector(node, selector)) {
            return true;
        }
        if (node === baseNode) {
            return false;
        }
        node = node.parentNode;
    } while (node);
    return false;
}
function addEvent(el, event, handler) {
    if (!el) {
        return;
    }
    if (el.attachEvent) {
        el.attachEvent("on" + event, handler);
    }
    else if (el.addEventListener) {
        el.addEventListener(event, handler, true);
    }
    else {
        el["on" + event] = handler;
    }
}
function removeEvent(el, event, handler) {
    if (!el) {
        return;
    }
    if (el.detachEvent) {
        el.detachEvent("on" + event, handler);
    }
    else if (el.removeEventListener) {
        el.removeEventListener(event, handler, true);
    }
    else {
        el["on" + event] = null;
    }
}
function outerHeight(node) {
    var height = node.clientHeight;
    var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height += int(computedStyle.borderTopWidth);
    height += int(computedStyle.borderBottomWidth);
    return height;
}
function outerWidth(node) {
    var width = node.clientWidth;
    var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width += int(computedStyle.borderLeftWidth);
    width += int(computedStyle.borderRightWidth);
    return width;
}
function innerHeight(node) {
    var height = node.clientHeight;
    var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height -= int(computedStyle.paddingTop);
    height -= int(computedStyle.paddingBottom);
    return height;
}
function innerWidth(node) {
    var width = node.clientWidth;
    var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width -= int(computedStyle.paddingLeft);
    width -= int(computedStyle.paddingRight);
    return width;
}
function offsetXYFromParent(evt, offsetParent) {
    var isBody = offsetParent === offsetParent.ownerDocument.body;
    var offsetParentRect = isBody ? { left: 0, top: 0 } : offsetParent.getBoundingClientRect();
    var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
    var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;
    return { x: x, y: y };
}
function createCSSTransform(_a) {
    var x = _a.x, y = _a.y, rotation = _a.rotation;
    var _b;
    var translation = "translate(" + x + "px," + y + "px) rotate(" + rotation + "rad)";
    return _b = {}, _b[browserPrefixToKey('transform', browserPrefix)] = translation, _b;
}
function getTouch(e, identifier) {
    var touch = null;
    if (e.targetTouches) {
        touch = findInArray(e.targetTouches, function (t) { return identifier === t.identifier; });
    }
    if (e.changedTouches && !touch) {
        touch = findInArray(e.changedTouches, function (t) { return identifier === t.identifier; });
    }
    return touch;
}
function getTouchIdentifier(e) {
    if (e.targetTouches && e.targetTouches[0]) {
        return e.targetTouches[0].identifier;
    }
    if (e.changedTouches && e.changedTouches[0]) {
        return e.changedTouches[0].identifier;
    }
    return null;
}

function findDOMNode(draggable) {
    var node = ReactDOM.findDOMNode(draggable);
    if (!node) {
        throw new Error('<DraggableCore>: Unmounted during event!');
    }
    return node;
}
function getBoundPosition(draggable, x, y) {
    if (!draggable.props.bounds) {
        return [x, y];
    }
    var bounds = draggable.props.bounds;
    bounds = typeof bounds === 'string' ? bounds : __assign({}, bounds);
    var node = findDOMNode(draggable);
    if (typeof bounds === 'string') {
        var ownerDocument = node.ownerDocument;
        var ownerWindow = ownerDocument.defaultView;
        var boundNode = bounds === 'parent' ? node.parentNode : ownerDocument.querySelector(bounds);
        if (!(boundNode instanceof HTMLElement)) {
            throw new Error("Bounds selector \"" + bounds + "\" could not find an element.");
        }
        if (node instanceof HTMLElement) {
            var nodeStyle = ownerWindow.getComputedStyle(node);
            var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
            bounds = {
                left: -node.offsetLeft + int(boundNodeStyle.paddingLeft) + int(nodeStyle.marginLeft),
                top: -node.offsetTop + int(boundNodeStyle.paddingTop) + int(nodeStyle.marginTop),
                right: innerWidth(boundNode) -
                    outerWidth(node) -
                    node.offsetLeft +
                    int(boundNodeStyle.paddingRight) -
                    int(nodeStyle.marginRight),
                bottom: innerHeight(boundNode) -
                    outerHeight(node) -
                    node.offsetTop +
                    int(boundNodeStyle.paddingBottom) -
                    int(nodeStyle.marginBottom),
            };
        }
    }
    bounds = bounds;
    /** x, y below right, bottom and above left, top */
    if (isNum(bounds.right)) {
        x = Math.min(x, bounds.right);
    }
    if (isNum(bounds.bottom)) {
        y = Math.min(y, bounds.bottom);
    }
    if (isNum(bounds.left)) {
        x = Math.max(x, bounds.left);
    }
    if (isNum(bounds.top)) {
        y = Math.max(y, bounds.top);
    }
    return [x, y];
}
function createCoreData(draggable, x, y) {
    var state = draggable.state;
    var isStart = !isNum(state.lastX);
    var node = findDOMNode(draggable);
    /** First drag */
    if (isStart) {
        return { node: node, deltaX: 0, deltaY: 0, lastX: x, lastY: y, x: x, y: y };
    }
    return { node: node, deltaX: x - state.lastX, deltaY: y - state.lastY, lastX: state.lastX, lastY: state.lastY, x: x, y: y };
}
function createDraggableData(draggable, coreData) {
    return {
        node: coreData.node,
        x: draggable.state.x + coreData.deltaX,
        y: draggable.state.y + coreData.deltaY,
        deltaX: coreData.deltaX,
        deltaY: coreData.deltaY,
        lastX: draggable.state.x,
        lastY: draggable.state.y,
    };
}
function canDragX(draggable) {
    return draggable.props.axis === 'both' || draggable.props.axis === 'x';
}
function canDragY(draggable) {
    return draggable.props.axis === 'both' || draggable.props.axis === 'y';
}
function getControlPosition(e, draggableCore) {
    var node = findDOMNode(draggableCore);
    var offsetParent = draggableCore.props.offsetParent;
    if (!offsetParent && node instanceof HTMLElement) {
        offsetParent = node.offsetParent || node.ownerDocument.body;
    }
    return offsetXYFromParent(e, offsetParent);
}

/*  eslint-disable */
var eventsFor = {
    touch: {
        start: 'touchstart',
        move: 'touchmove',
        stop: 'touchend',
    },
    mouse: {
        start: 'mousedown',
        move: 'mousemove',
        stop: 'mouseup',
    },
};
var dragEventFor = eventsFor.mouse;
var defaultCoreProps = {
    cancel: null,
    disabled: false,
    offsetParent: null,
    handle: null,
    transform: null,
    onStart: function () { },
    onDrag: function () { },
    onStop: function () { },
    onMouseDown: function () { },
};
var DraggableCore = /** @class */ (function (_super) {
    __extends(DraggableCore, _super);
    function DraggableCore() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            dragging: false,
            /** Used while dragging to determine deltas */
            lastX: NaN, lastY: NaN,
            touchIdentifier: undefined,
        };
        _this.getTouchFromEvent = function (e) {
            /**
             * Set touch identifier in component state if this is a touch event. This allows us to
             * distinguish between individual touches on multitouch screens by identifying which
             * touchpoint was set to this element
             */
            var touchIdentifier = getTouchIdentifier(e);
            _this.setState({ touchIdentifier: touchIdentifier });
            return getTouch(e, touchIdentifier);
        };
        _this.preventDefault = function (e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            if (e.stopPropagation) {
                e.stopPropagation();
            }
        };
        // @ts-ignore TS7030
        _this.handleDragStart = function (e) {
            var thisNode = ReactDOM.findDOMNode(_this);
            if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
                throw new Error('<DraggableCore> not mounted on DragStart!');
            }
            var ownerDocument = thisNode.ownerDocument;
            if (_this.props.disabled ||
                (!(e.target instanceof Node)) ||
                (_this.props.handle && !matchesSelectorAndParentsTo(e.target, _this.props.handle, thisNode)) ||
                (_this.props.cancel && matchesSelectorAndParentsTo(e.target, _this.props.cancel, thisNode))) {
                return false;
            }
            /** Get the current drag point from the event. This is used as the offset */
            var position = getControlPosition(e, _this);
            if (position == null) {
                return false;
            }
            var x = position.x, y = position.y;
            /** Create an event object with all the data parents need to make a decision here */
            var coreEvent = createCoreData(_this, x, y);
            var shouldUpdate = _this.props.onStart(e, coreEvent);
            if (shouldUpdate === false) {
                return false;
            }
            /**
             * Initiate dragging. Set the current x and y as offsets
             * so we know how much we've moved during the drag. This allows us
             * to drag elements around even if they have been moved, without issue.
             */
            _this.setState({ dragging: true, lastX: x, lastY: y });
            /**
             * Add events to the document directly so we catch when the user's mouse/touch moves outside of
             * this element. We use different events depending on whether or not we have detected that this
             * is a touch-capable device
             */
            if (dragEventFor.move === 'touchmove') {
                addEvent(ownerDocument, dragEventFor.move, _this.onTouchDrag);
            }
            else {
                addEvent(ownerDocument, dragEventFor.move, _this.onMouseDrag);
            }
            addEvent(ownerDocument, dragEventFor.stop, _this.handleDragStop);
        };
        _this.handleDrag = function (e) {
            /** Get the current drag point from the event. This is used as the offset */
            var position = getControlPosition(e, _this);
            if (position == null) {
                return;
            }
            var x = position.x, y = position.y;
            var coreEvent = createCoreData(_this, x, y);
            /** Call event handler. If it returns explicit false, trigger end */
            var shouldUpdate = _this.props.onDrag(e, coreEvent);
            if (shouldUpdate === false) {
                try {
                    _this.handleDragStop(new MouseEvent('mouseup'));
                }
                catch (err) {
                    /** Old browsers */
                    var evt = document.createEvent('MouseEvents');
                    evt.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                    _this.handleDragStop(evt);
                }
                return;
            }
            _this.setState({
                lastX: x,
                lastY: y,
            });
        };
        _this.handleDragStop = function (e) {
            if (!_this.state.dragging) {
                return;
            }
            var position = getControlPosition(e, _this);
            if (position == null) {
                return;
            }
            var x = position.x, y = position.y;
            var coreEvent = createCoreData(_this, x, y);
            var thisNode = ReactDOM.findDOMNode(_this);
            // Reset the el
            _this.setState({
                dragging: false,
                lastX: NaN,
                lastY: NaN,
            });
            /** Call event handler */
            _this.props.onStop(e, coreEvent);
            if (thisNode) {
                /** Remove event handlers */
                if (dragEventFor.move === 'touchmove') {
                    removeEvent(thisNode.ownerDocument, dragEventFor.move, _this.onTouchDrag);
                }
                else {
                    removeEvent(thisNode.ownerDocument, dragEventFor.move, _this.onMouseDrag);
                }
                removeEvent(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);
            }
        };
        _this.onMouseDown = function (e) {
            _this.preventDefault(e);
            dragEventFor = eventsFor.mouse; /** on touchscreen laptops we could switch back to mouse */
            _this.props.onMouseDown(e);
            /** left-click check */
            if (e.button && typeof e.button === 'number' && e.button !== 0) {
                return false;
            }
            return _this.handleDragStart(e);
        };
        _this.onMouseDrag = function (e) {
            _this.preventDefault(e);
            return _this.handleDrag(e);
        };
        _this.onMouseUp = function (e) {
            _this.preventDefault(e);
            dragEventFor = eventsFor.mouse;
            return _this.handleDragStop(e);
        };
        _this.onTouchStart = function (e) {
            _this.preventDefault(e);
            dragEventFor = eventsFor.touch;
            var touch = _this.getTouchFromEvent(e);
            return _this.handleDragStart(touch);
        };
        _this.onTouchDrag = function (e) {
            _this.preventDefault(e);
            dragEventFor = eventsFor.touch;
            var touch = _this.getTouchFromEvent(e);
            return _this.handleDrag(touch);
        };
        _this.onTouchEnd = function (e) {
            _this.preventDefault(e);
            dragEventFor = eventsFor.touch;
            var touch = _this.getTouchFromEvent(e);
            return _this.handleDragStop(touch);
        };
        return _this;
    }
    DraggableCore.prototype.componentWillUnmount = function () {
        var thisNode = ReactDOM.findDOMNode(this);
        if (thisNode) {
            var ownerDocument = thisNode.ownerDocument;
            removeEvent(ownerDocument, eventsFor.mouse.move, this.onMouseDrag);
            removeEvent(ownerDocument, eventsFor.touch.move, this.onTouchDrag);
            removeEvent(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
            removeEvent(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
        }
    };
    DraggableCore.prototype.render = function () {
        return React.cloneElement(React.Children.only(this.props.children), {
            style: __assign({ touchAction: 'none' }, this.props.children.props.style),
            /**
             * Note: mouseMove handler is attached to document so it will still function
             * when the user drags quickly and leaves the bounds of the element
             */
            onMouseDown: this.onMouseDown,
            onTouchStart: this.onTouchStart,
            onMouseUp: this.onMouseUp,
            onTouchEnd: this.onTouchEnd,
        });
    };
    DraggableCore.defaultProps = defaultCoreProps;
    DraggableCore.displayName = 'DraggableCore';
    return DraggableCore;
}(React.Component));

var defaultProps = __assign({}, defaultCoreProps, { axis: 'both', bounds: false, defaultClassName: 'draggable', defaultClassNameDragging: 'draggable-dragging', defaultClassNameDragged: 'draggable-dragged', defaultPosition: { x: 0, y: 0 }, position: null, rotation: 0, updateOnPosition: false });
var Draggable = /** @class */ (function (_super) {
    __extends(Draggable, _super);
    function Draggable(props) {
        var _this = _super.call(this, props) || this;
        // @ts-ignore TS7030
        _this.onDragStart = function (e, coreData) {
            var shouldStart = _this.props.onStart(e, createDraggableData(_this, coreData));
            if (shouldStart === false) {
                return false;
            }
            _this.setState({ dragging: true, dragged: true });
        };
        // @ts-ignore TS7030
        _this.onDrag = function (e, coreData) {
            var _a = _this.props, position = _a.position, defaultPosition = _a.defaultPosition, onDrag = _a.onDrag, bounds = _a.bounds;
            if (!_this.state.dragging) {
                return false;
            }
            var uiData = createDraggableData(_this, coreData);
            var controlled = Boolean(position);
            var newState = {
                x: controlled ? uiData.x : defaultPosition.x,
                y: controlled ? uiData.y : defaultPosition.y,
                slackX: 0,
                slackY: 0,
            };
            if (bounds) {
                var x = newState.x, y = newState.y;
                /**
                 * Add slack to the values used to calculate bound position. This will ensure that if
                 * we start removing slack, the element won't react to it right away until it's been
                 * completely removed
                 */
                newState.x += _this.state.slackX;
                newState.y += _this.state.slackY;
                /** Get bound position. This will ceil/floor the x and y within the boundaries */
                var _b = __read(getBoundPosition(_this, newState.x, newState.y), 2), newStateX = _b[0], newStateY = _b[1];
                newState.x = newStateX;
                newState.y = newStateY;
                /** Recalculate slack by noting how much was shaved by the boundPosition handler */
                newState.slackX = _this.state.slackX + (x - newState.x);
                newState.slackY = _this.state.slackY + (y - newState.y);
                /** Update the event we fire to reflect what really happened after bounds took effect */
                uiData.x = newState.x;
                uiData.y = newState.y;
                uiData.deltaX = newState.x - _this.state.x;
                uiData.deltaY = newState.y - _this.state.y;
            }
            var shouldUpdate = onDrag(e, uiData);
            if (shouldUpdate === false) {
                return false;
            }
            _this.setState(newState);
        };
        // @ts-ignore TS7030
        _this.onDragStop = function (e, coreData) {
            if (!_this.state.dragging) {
                return false;
            }
            var shouldStop = _this.props.onStop(e, createDraggableData(_this, coreData));
            if (shouldStop === false) {
                return false;
            }
            var newState = {
                dragging: false,
                slackX: 0,
                slackY: 0,
                x: 0,
                y: 0,
            };
            var controlled = Boolean(_this.props.position);
            if (controlled) {
                var _a = _this.props.position, x = _a.x, y = _a.y;
                newState.x = x;
                newState.y = y;
            }
            _this.setState(newState);
        };
        _this.state = {
            dragging: false,
            dragged: false,
            x: props.position ? props.position.x : props.defaultPosition.x,
            y: props.position ? props.position.y : props.defaultPosition.y,
            slackX: 0,
            slackY: 0,
        };
        return _this;
    }
    Draggable.prototype.componentDidUpdate = function (prevProps) {
        var controlled = Boolean(this.props.position);
        if (controlled) {
            if (this.props.updateOnPosition) {
                if (prevProps.position &&
                    prevProps.position.x !== this.props.position.x ||
                    prevProps.position.y !== this.props.position.y) {
                    this.setState({ x: this.props.position.x, y: this.props.position.y });
                }
            }
            else {
                if (prevProps.position &&
                    this.props.position.x !== this.state.x ||
                    this.props.position.y !== this.state.y) {
                    this.setState({ x: this.props.position.x, y: this.props.position.y });
                }
            }
        }
    };
    Draggable.prototype.componentWillUnmount = function () {
        /** prevents invariant if unmounted while dragging */
        this.setState({ dragging: false });
    };
    Draggable.prototype.render = function () {
        var _a = this.props, position = _a.position, defaultPosition = _a.defaultPosition, rotation = _a.rotation, defaultClassName = _a.defaultClassName, defaultClassNameDragging = _a.defaultClassNameDragging, defaultClassNameDragged = _a.defaultClassNameDragged, draggableCoreProps = __rest(_a, ["position", "defaultPosition", "rotation", "defaultClassName", "defaultClassNameDragging", "defaultClassNameDragged"]);
        var _b = this.state, x = _b.x, y = _b.y, dragging = _b.dragging, dragged = _b.dragged;
        var style = {};
        var controlled = Boolean(position);
        var draggable = !controlled || dragging;
        var validPosition = position || defaultPosition;
        var transformOptions = {
            x: canDragX(this) && draggable ? x : validPosition.x,
            y: canDragY(this) && draggable ? y : validPosition.y,
            rotation: rotation,
        };
        style = createCSSTransform(transformOptions);
        var children = React.Children.only(this.props.children);
        var className = [
            (children.props.className || ''),
            defaultClassName,
            dragging ? defaultClassNameDragging : '',
            dragged ? defaultClassNameDragged : '',
        ].join(' ').trim();
        var Child = React.cloneElement(children, {
            className: className,
            style: __assign({}, children.props.style, style),
        });
        return (React.createElement(DraggableCore, __assign({}, draggableCoreProps, { onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop }), Child));
    };
    Draggable.defaultProps = defaultProps;
    Draggable.displayName = 'Draggable';
    return Draggable;
}(React.Component));

var ModalButtonContainer = styled(ButtonContainer)(templateObject_1$T || (templateObject_1$T = __makeTemplateObject(["\n  border-top: 2px solid ", ";\n"], ["\n  border-top: 2px solid ", ";\n"])), function (props) { return (props.type === 'error' ? props.theme.error : props.theme.warning); });
var Wrapper$2 = styled.div(templateObject_2$q || (templateObject_2$q = __makeTemplateObject(["\n  display: block;\n"], ["\n  display: block;\n"])));
var Heading = styled.h3(templateObject_3$g || (templateObject_3$g = __makeTemplateObject(["\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  color: ", ";\n"], ["\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  color: ", ";\n"])), function (props) { return props.theme.measurements.fontSystem.headline2.size; }, function (props) { return props.theme.measurements.fontSystem.headline2.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.headline2.case; }, function (props) { return props.theme.modal.headerForeground; });
var Body = styled.p(templateObject_4$9 || (templateObject_4$9 = __makeTemplateObject(["\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  color: ", ";\n"], ["\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  color: ", ";\n"])), function (props) { return props.theme.measurements.fontSystem.body.size; }, function (props) { return props.theme.measurements.fontSystem.body.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.body.case; }, function (props) { return props.theme.modal.bodyForeground; });
var ModalComponent = /** @class */ (function (_super) {
    __extends(ModalComponent, _super);
    function ModalComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.closeModal = function (handle) {
            if (_this.props.handlers.close) {
                _this.props.handlers.close();
            }
            if (handle) {
                handle();
            }
        };
        return _this;
    }
    ModalComponent.prototype.render = function () {
        var _this = this;
        var _a = this.props, type = _a.type, handlers = _a.handlers, message = _a.message, show = _a.show, position = _a.position, preHeadingLocale = _a.preHeadingLocale;
        var renderModalFooter = function () {
            return handlers && message ? (React.createElement(ModalButtonContainer, { type: type },
                message.buttonNo && (React.createElement(SecondaryButton, { ariaLabel: message.buttonNo, onClick: function () { return _this.closeModal(handlers.buttonNo); } }, message.buttonNo)),
                message.buttonYes &&
                    (React.createElement(PrimaryButton, { ariaLabel: message.buttonYes, onClick: function () { return _this.closeModal(handlers.buttonYes); } }, message.buttonYes)))) : null;
        };
        var preHeading = type === 'error' ? preHeadingLocale.error : preHeadingLocale.warning;
        return (React.createElement(ModalWrapper, { heading: message ? message.heading : '', show: show || false, width: '350px', height: 'fit-content', position: position, footer: renderModalFooter },
            React.createElement(Wrapper$2, null,
                message ? (React.createElement(Heading, null,
                    preHeading,
                    ": ",
                    message.heading || '')) : null,
                message && message.body ? (React.createElement(Body, null, message.body)) : null)));
    };
    ModalComponent.defaultProps = {
        preHeadingLocale: { error: 'Error', warning: 'Warning' },
    };
    return ModalComponent;
}(React.PureComponent));
var templateObject_1$T, templateObject_2$q, templateObject_3$g, templateObject_4$9;

var Switch = /** @class */ (function (_super) {
    __extends(Switch, _super);
    function Switch() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Switch.prototype.getChildren = function () {
        var _this = this;
        var cases = [];
        var defaults = [];
        React.Children.forEach(this.props.children, function (item) {
            switch (item.type.componentName) {
                case 'case':
                    if (_this.props.type === item.props.value) {
                        cases.push(item);
                    }
                    break;
                case 'default':
                    defaults.push(item);
                    break;
            }
        });
        if (cases.length > 0) {
            return cases;
        }
        return defaults;
    };
    Switch.prototype.render = function () {
        var children = this.getChildren();
        return children.length === 0 ? null : React.createElement(React.Fragment, null, children);
    };
    return Switch;
}(React.Component));
var Case = /** @class */ (function (_super) {
    __extends(Case, _super);
    function Case() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Case.prototype.render = function () {
        return this.props.children;
    };
    Case.componentName = 'case';
    return Case;
}(React.Component));
var Default = /** @class */ (function (_super) {
    __extends(Default, _super);
    function Default() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Default.prototype.render = function () {
        return this.props.children;
    };
    Default.componentName = 'default';
    return Default;
}(React.Component));

var Components = {
    Container: AppContainer,
    ColorItem: ColorItem$1,
    Loader: Loader,
    Spacer: Spacer,
    Modal: ModalComponent,
    Draggable: Draggable,
    DraggableCore: DraggableCore,
    Toast: Toast,
    /**
     * All inputs follow the accessibility form guidelines
     */
    Input: {
        Label: Label,
        File: FileInputStyles,
        Search: Search,
        Slider: Slider,
        CarouselSlider: CarouselSlider,
        Selection: Selection,
        Checkbox: Checkbox,
        Dropdown: Dropdown,
        Text: Input,
        NummericInput: NummericInput,
        TextEdit: InputEdit,
        Form: form,
    },
    Switch: {
        Index: Switch,
        Case: Case,
        Default: Default,
    },
};

var isValid = function (x, y) {
    return x !== undefined && y !== undefined && !Number.isNaN(x) && !Number.isNaN(y);
};

var Knob$1 = styled(CanvasUIComponents.Controls.Knob)(templateObject_1$U || (templateObject_1$U = __makeTemplateObject(["\n  margin-top: -", "px;\n  margin-left: -", "px;\n"], ["\n  margin-top: -", "px;\n  margin-left: -", "px;\n"])), function (props) { return props.theme.measurements.canvasControls.knob.touchable.desktop / 2; }, function (props) { return props.theme.measurements.canvasControls.knob.touchable.desktop / 2; });
var Container$2 = styled(CanvasUIComponents.Controls.Container)(templateObject_2$r || (templateObject_2$r = __makeTemplateObject(["\n  overflow: unset;\n"], ["\n  overflow: unset;\n"])));
var Linear = /** @class */ (function (_super) {
    __extends(Linear, _super);
    function Linear() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.start = function (_, _a) {
            var x = _a.x, y = _a.y;
            if (isValid(x, y)) {
                _this.focusTool.setStart({ x: x, y: y });
            }
        };
        _this.end = function (_, _a) {
            var x = _a.x, y = _a.y;
            if (isValid(x, y)) {
                _this.focusTool.setEnd({ x: x, y: y });
            }
        };
        _this.onKnob1DragStart = function (_, e) {
            _this.focusTool.clickableCanvas(false);
            _this.start(_, e);
        };
        _this.onKnob1DragStop = function (_, e) {
            _this.addSnapshot(e, _this.historyLocale.focusPosition);
            _this.start(_, e);
            _this.focusTool.clickableCanvas(true);
        };
        _this.onKnob2DragStart = function (_, e) {
            _this.focusTool.clickableCanvas(false);
            _this.end(_, e);
        };
        _this.onKnob2DragStop = function (_, e) {
            _this.addSnapshot(e, _this.historyLocale.focusPosition);
            _this.end(_, e);
            _this.focusTool.clickableCanvas(true);
        };
        _this.addSnapshot = function (_a, description) {
            var x = _a.x, y = _a.y;
            if (isValid(x, y)) {
                _this.focusTool.toolSnapshot(description);
            }
        };
        _this.getLine = function () {
            var _a = _this.props.canvas.canvasSize, height = _a.height, width = _a.width;
            var start = _this.focusTool.startOnPreview;
            var end = _this.focusTool.endOnPreview;
            return (React.createElement("svg", { focusable: "false", height: height, width: width },
                React.createElement("line", { x1: start.x, y1: start.y, x2: end.x, y2: end.y, strokeWidth: "2", stroke: "currentColor" })));
        };
        return _this;
    }
    Object.defineProperty(Linear.prototype, "focusTool", {
        get: function () {
            return this.props.focusTool;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Linear.prototype, "historyLocale", {
        get: function () {
            return this.focusTool.locale.history;
        },
        enumerable: true,
        configurable: true
    });
    Linear.prototype.render = function () {
        return (React.createElement(Container$2, null,
            React.createElement(CanvasUIComponents.Controls.Line, null, this.getLine()),
            React.createElement(Components.Draggable, { bounds: "parent", position: this.focusTool.startOnPreview, onStart: this.onKnob1DragStart, onDrag: this.start, onStop: this.onKnob1DragStop },
                React.createElement(Knob$1, null)),
            React.createElement(Components.Draggable, { bounds: "parent", onStart: this.onKnob2DragStart, onDrag: this.end, onStop: this.onKnob2DragStop, position: this.focusTool.endOnPreview },
                React.createElement(Knob$1, null))));
    };
    return Linear;
}(React.Component));
Knob$1.defaultProps = { theme: defaultStyledTheme };
var Linear$1 = inject('canvas', 'focusTool')(observer(Linear));
var templateObject_1$U, templateObject_2$r;

var Radial = /** @class */ (function (_super) {
    __extends(Radial, _super);
    function Radial() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            knobAngle: 2.35,
        };
        _this.onCircle = function (_, _a) {
            var x = _a.x, y = _a.y;
            if (isValid(x, y)) {
                var radius = _this.focusTool.radius;
                _this.focusTool.setCenter({ x: x + radius, y: y + radius });
            }
        };
        _this.onKnob = function (_, _a) {
            var x = _a.x, y = _a.y;
            if (isValid(x, y)) {
                var center = _this.focusTool.center;
                var v1 = new Vector2(x, y);
                var v2 = new Vector2(center.x, center.y);
                var distance = v2.subtract(v1);
                var newRadius = distance.magnitude;
                var rotation = -Math.atan2(distance.y, distance.x);
                _this.setState({ knobAngle: rotation });
                _this.focusTool.setRadius(newRadius);
            }
        };
        _this.onCircleDragStart = function (_, e) {
            _this.focusTool.clickableCanvas(false);
            _this.onCircle(_, e);
        };
        _this.onCircleDragStop = function (_, e) {
            _this.addSnapshot(e, _this.historyLocale.focusPosition);
            _this.onCircle(_, e);
            _this.focusTool.clickableCanvas(true);
        };
        _this.onKnobDragStart = function (_, e) {
            _this.focusTool.clickableCanvas(false);
            _this.onKnob(_, e);
        };
        _this.onKnobDragStop = function (_, e) {
            _this.addSnapshot(e, _this.historyLocale.focusSize);
            _this.onKnob(_, e);
            _this.focusTool.clickableCanvas(true);
        };
        _this.addSnapshot = function (_a, description) {
            var x = _a.x, y = _a.y;
            if (isValid(x, y)) {
                _this.focusTool.toolSnapshot(description);
            }
        };
        return _this;
    }
    Radial.prototype.componentDidMount = function () {
        this.setState({
            knobAngle: 2.35,
        });
    };
    Object.defineProperty(Radial.prototype, "historyLocale", {
        get: function () {
            return this.focusTool.locale.history;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Radial.prototype, "focusTool", {
        get: function () {
            return this.props.focusTool;
        },
        enumerable: true,
        configurable: true
    });
    Radial.prototype.render = function () {
        var _a = this.focusTool, center = _a.center, radius = _a.radius;
        var circlePosition = { x: center.x - radius, y: center.y - radius };
        var rotation = Math.PI - this.state.knobAngle;
        var knobPosition = { x: center.x + radius * Math.cos(rotation), y: center.y + radius * Math.sin(rotation) };
        return (React.createElement(CanvasUIComponents.Controls.Container, null,
            React.createElement(Components.Draggable, { bounds: "parent", onStart: this.onKnobDragStart, onDrag: this.onKnob, onStop: this.onKnobDragStop, position: knobPosition },
                React.createElement(CanvasUIComponents.Controls.Knob, null)),
            React.createElement(Components.Draggable, { onStart: this.onCircleDragStart, onDrag: this.onCircle, onStop: this.onCircleDragStop, position: circlePosition },
                React.createElement(CanvasUIComponents.Controls.Circle, { radius: radius }))));
    };
    return Radial;
}(React.Component));
var Radial$1 = inject('focusTool', 'canvas')(observer(Radial));

var Mirrored = /** @class */ (function (_super) {
    __extends(Mirrored, _super);
    function Mirrored() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.getKnobPosition = function () {
            var origin = _this.focusTool.origin;
            var radius = _this.focusTool.size / 2;
            var rotation = Math.PI / 2 + _this.focusTool.rotationOnPreview;
            return { x: origin.x + radius * Math.cos(rotation), y: origin.y + radius * Math.sin(rotation) };
        };
        _this.onArea = function (_, _a) {
            var x = _a.x, y = _a.y;
            var editor = _this.props.editor;
            var knobSize = editor.configStore.measurements.canvasControls.knob.size;
            if (isValid(x, y)) {
                var canvas = _this.props.canvas;
                var _b = _this.focusTool, size = _b.size, mirroredAreaWidth = _b.mirroredAreaWidth;
                var originX = x + mirroredAreaWidth / 2;
                var originY = y + size / 2;
                var knobPosition = new Vector2(_this.getKnobPosition());
                var target = new Vector2({ x: x, y: y });
                var delta = target.subtract(new Vector2(_this.areaPosition));
                var newKnob = knobPosition.add(delta);
                if (newKnob.x > knobSize && newKnob.x < canvas.canvasSize.width - knobSize) {
                    if (newKnob.y > knobSize && newKnob.y < canvas.canvasSize.height - knobSize) {
                        _this.focusTool.setOrigin({ x: originX, y: originY });
                    }
                }
            }
        };
        _this.onKnob = function (_, _a) {
            var x = _a.x, y = _a.y;
            if (isValid(x, y)) {
                var origin_1 = new Vector2(_this.focusTool.origin);
                var knob = new Vector2(x, y);
                var distance = origin_1.subtract(knob);
                var radius = distance.magnitude;
                var rotation = Math.PI / 2 + Math.atan2(distance.y, distance.x);
                _this.focusTool.setSize(radius * 2);
                _this.focusTool.setRotation(rotation);
            }
        };
        _this.onAreaDragStop = function (_, e) {
            _this.addSnapshot(e, _this.historyLocale.focusPosition);
            _this.onArea(_, e);
        };
        _this.onKnobDragStop = function (_, e) {
            _this.addSnapshot(e, _this.historyLocale.focusSize);
            _this.onKnob(_, e);
        };
        _this.addSnapshot = function (_a, description) {
            var x = _a.x, y = _a.y;
            if (isValid(x, y)) {
                _this.focusTool.toolSnapshot(description);
            }
        };
        return _this;
    }
    Object.defineProperty(Mirrored.prototype, "historyLocale", {
        get: function () {
            return this.focusTool.locale.history;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mirrored.prototype, "focusTool", {
        get: function () {
            return this.props.focusTool;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mirrored.prototype, "areaPosition", {
        get: function () {
            var _a = this.focusTool, origin = _a.origin, size = _a.size, mirroredAreaWidth = _a.mirroredAreaWidth;
            return {
                x: origin.x - mirroredAreaWidth / 2,
                y: origin.y - size / 2,
            };
        },
        enumerable: true,
        configurable: true
    });
    Mirrored.prototype.render = function () {
        var _a = this.areaPosition, x = _a.x, y = _a.y;
        return (React.createElement(CanvasUIComponents.Controls.Container, null,
            React.createElement(Components.Draggable, { bounds: "parent", onStart: this.onKnob, onDrag: this.onKnob, onStop: this.onKnobDragStop, position: this.getKnobPosition() },
                React.createElement(CanvasUIComponents.Controls.Knob, null)),
            React.createElement(Components.Draggable, { onStart: this.onArea, onDrag: this.onArea, onStop: this.onAreaDragStop, position: { x: x, y: y }, rotation: this.focusTool.rotationOnPreview },
                React.createElement(CanvasUIComponents.Controls.Area, { height: this.focusTool.size, width: this.focusTool.mirroredAreaWidth }))));
    };
    return Mirrored;
}(React.Component));
var Mirrored$1 = inject('focusTool', 'canvas', 'editor')(observer(Mirrored));

var FocusCanvasControls = function (_a) {
    var focusTool = _a.focusTool;
    var state = focusTool.state;
    var getComponent = function () {
        switch (state.identifier) {
            case FocusIdentifier.LINEAR:
                return Linear$1;
            case FocusIdentifier.RADIAL:
                return Radial$1;
            case FocusIdentifier.MIRRORED:
                return Mirrored$1;
        }
        return null;
    };
    var ControlComponent = getComponent();
    return focusTool.isOptionSelected && ControlComponent ? React.createElement(ControlComponent, null) : null;
};
var FocusCanvasControls$1 = inject('focusTool')(observer(FocusCanvasControls));

var Container$3 = styled(CanvasUIComponents.Controls.Container)(templateObject_1$V || (templateObject_1$V = __makeTemplateObject(["\n  cursor: none;\n"], ["\n  cursor: none;\n"])));
var Cursor = styled.div(templateObject_2$s || (templateObject_2$s = __makeTemplateObject(["\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  transform: translate(-50%, -50%);\n  border-radius: 50%;\n  border-width: 2px;\n  border-style: solid;\n  box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(255, 255, 255, 1);\n"], ["\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  transform: translate(-50%, -50%);\n  border-radius: 50%;\n  border-width: 2px;\n  border-style: solid;\n  box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(255, 255, 255, 1);\n"])));
var CursorComponent = /** @class */ (function (_super) {
    __extends(CursorComponent, _super);
    function CursorComponent(props) {
        var _this = _super.call(this, props) || this;
        _this.INITIAL_POSITION = { x: undefined, y: undefined };
        _this.state = __assign({}, _this.INITIAL_POSITION, { isDrawing: false });
        _this.containerElementRef = null;
        _this.getCursorCoordinates = function (e) {
            var clientX = 0;
            var clientY = 0;
            if (e.type.indexOf('touch') !== -1) {
                var ev = e;
                if (!ev.touches.length) {
                    return __assign({}, _this.INITIAL_POSITION, { height: 0, width: 0 });
                }
                clientX = ev.touches[0].clientX;
                clientY = ev.touches[0].clientY;
            }
            else {
                var ev = e;
                clientX = ev.clientX;
                clientY = ev.clientY;
            }
            var rect = _this.containerElementRef.current.getBoundingClientRect();
            var x = clientX - rect.left;
            var y = clientY - rect.top;
            return { x: x, y: y, height: rect.height, width: rect.width };
        };
        _this.draw = function (e) {
            e.preventDefault();
            e.stopPropagation();
            _this.touchDraw(e);
        };
        _this.touchDraw = function (e) {
            var _a = _this.getCursorCoordinates(e), x = _a.x, y = _a.y;
            if (x !== undefined && y !== undefined) {
                _this.setState({ x: x, y: y });
                if (_this.state.isDrawing) {
                    _this.brushTool.strokePosition({ x: x, y: y });
                }
            }
        };
        _this.start = function () {
            _this.brushTool.clickableCanvas(false);
            _this.setState({ isDrawing: true });
            _this.brushTool.beginStroke();
        };
        _this.stop = function (e) {
            if (_this.state.isDrawing) {
                e.preventDefault();
                e.stopPropagation();
                _this.setState({ isDrawing: false });
                _this.brushTool.endStroke();
                _this.brushTool.clickableCanvas(true);
            }
        };
        _this.setInitialPosition = function () {
            _this.setState(__assign({}, _this.INITIAL_POSITION));
        };
        _this.mouseOut = function (e) {
            var config = _this.props.config;
            e.preventDefault();
            e.stopPropagation();
            var brushRadius = _this.brushTool.sizeOnScreenSpace / 2;
            var _a = _this.getCursorCoordinates(e), x = _a.x, y = _a.y, height = _a.height, width = _a.width;
            if (x && y) {
                if (x < 0 ||
                    y < 0 ||
                    x > width - brushRadius ||
                    y > height - brushRadius ||
                    y < config.measurements.mainCanvasActionBar.height) {
                    _this.setInitialPosition();
                }
            }
        };
        _this.touchEnd = function (e) {
            e.preventDefault();
            e.stopPropagation();
            // touches will be empty for the onTouchEnd event, take last saved values instead
            var _a = _this.state, x = _a.x, y = _a.y;
            if (x && y) {
                _this.setInitialPosition();
            }
        };
        _this.getCursor = function () {
            var _a = _this.state, x = _a.x, y = _a.y;
            if (x && y) {
                var color = convertToColorString(_this.brushTool.color);
                var size = _this.brushTool.sizeOnScreenSpace + "px";
                var style = {
                    left: _this.state.x + "px",
                    top: _this.state.y + "px",
                    borderColor: color,
                    height: size,
                    width: size,
                };
                return React.createElement(Cursor, { style: style });
            }
            return null;
        };
        _this.containerElementRef = React.createRef();
        return _this;
    }
    CursorComponent.prototype.componentDidMount = function () {
        document.addEventListener('mouseup', this.stop, false);
        document.addEventListener('touchend', this.stop, { passive: false });
    };
    CursorComponent.prototype.componentWillUnmount = function () {
        document.removeEventListener('mouseup', this.stop, false);
        document.removeEventListener('touchend', this.stop, false);
    };
    Object.defineProperty(CursorComponent.prototype, "brushTool", {
        get: function () {
            return this.props.brushTool;
        },
        enumerable: true,
        configurable: true
    });
    CursorComponent.prototype.render = function () {
        return (React.createElement(Container$3, { ref: this.containerElementRef, onMouseMove: this.draw, onTouchMove: this.touchDraw, onMouseDown: this.start, onTouchStart: this.start, onMouseOut: this.mouseOut, onTouchEnd: this.touchEnd }, this.getCursor()));
    };
    return CursorComponent;
}(React.Component));
var BrushCanvasControls = inject('brushTool', 'config')(observer(CursorComponent));
var templateObject_1$V, templateObject_2$s;

/* eslint-disable */
var Adjustments = function () { return (React.createElement("svg", { focusable: "false", "aria-hidden": "true", "aria-label": "Adjustments", width: "48", height: "48", viewBox: "0 0 48 48", xmlns: "http://www.w3.org/2000/svg" },
    React.createElement("g", { id: "icon/fidelity/adjust", fill: "none", fillRule: "evenodd" },
        React.createElement("g", { id: "ic_adjust" },
            React.createElement("g", { fill: "#D8D8D8", opacity: "0" },
                React.createElement("rect", { width: "48", height: "48" })),
            React.createElement("g", { transform: "translate(12 12)" },
                React.createElement("rect", { fill: "#D8D8D8", opacity: "0", width: "24", height: "24" }),
                React.createElement("g", { transform: "translate(2 13)", fill: "currentColor" },
                    React.createElement("path", { d: "M3.02746439,4 C3.00931666,4.16416693 3,4.33099545 3,4.5 C3,4.66900455 3.00931666,4.83583307 3.02746439,5 L0,5 L0,4 L3.02746439,4 Z M13,4 L20,4 L20,5 L13,5 L13,4 Z", fillOpacity: "0.2" }),
                    React.createElement("path", { d: "M5.09842503,6.29819429 C5.0340931,6.05140089 5,5.7851211 5,5.5 C5,3.56700338 6.56700338,2 8.5,2 C8.7851211,2 9.05140089,2.0340931 9.29819429,2.09842503 C10.0278893,2.64566496 10.5,3.5176988 10.5,4.5 C10.5,6.15685425 9.15685425,7.5 7.5,7.5 C6.5176988,7.5 5.64566496,7.02788926 5.09842503,6.29819429 Z M11.1637159,7.11349161 C10.874061,7.51881791 10.5188179,7.87406095 10.1134916,8.16371592 C10.5772175,7.93004328 10.9300433,7.5772175 11.1637159,7.11349161 Z", fillOpacity: "0.2" }),
                    React.createElement("path", { d: "M7.5,7.5 C9.15685425,7.5 10.5,6.15685425 10.5,4.5 C10.5,2.84314575 9.15685425,1.5 7.5,1.5 C5.84314575,1.5 4.5,2.84314575 4.5,4.5 C4.5,6.15685425 5.84314575,7.5 7.5,7.5 Z M7.5,9 C5.01471863,9 3,6.98528137 3,4.5 C3,2.01471863 5.01471863,0 7.5,0 C9.98528137,0 12,2.01471863 12,4.5 C12,6.98528137 9.98528137,9 7.5,9 Z", fillOpacity: "0.87" })),
                React.createElement("g", { transform: "rotate(-180 11 5.5)", fill: "currentColor" },
                    React.createElement("path", { d: "M11.9725356,4 L20,4 L20,5 L11.9725356,5 C11.9906833,4.83583307 12,4.66900455 12,4.5 C12,4.33099545 11.9906833,4.16416693 11.9725356,4 Z M0,4 L2,4 L2,5 L0,5 L0,4 Z", fillOpacity: "0.2" }),
                    React.createElement("g", { transform: "rotate(-180 5 3.5)", fillOpacity: "0.2" },
                        React.createElement("path", { d: "M0.0984250251,4.29819429 C0.0340930963,4.05140089 0,3.7851211 0,3.5 C0,1.56700338 1.56700338,0 3.5,0 C3.7851211,0 4.05140089,0.0340930963 4.29819429,0.0984250251 C5.02788926,0.645664963 5.5,1.5176988 5.5,2.5 C5.5,4.15685425 4.15685425,5.5 2.5,5.5 C1.5176988,5.5 0.645664963,5.02788926 0.0984250251,4.29819429 Z M6.16371592,5.11349161 C5.87406095,5.51881791 5.51881791,5.87406095 5.11349161,6.16371592 C5.5772175,5.93004328 5.93004328,5.5772175 6.16371592,5.11349161 Z" })),
                    React.createElement("path", { d: "M7.5,7.5 C9.15685425,7.5 10.5,6.15685425 10.5,4.5 C10.5,2.84314575 9.15685425,1.5 7.5,1.5 C5.84314575,1.5 4.5,2.84314575 4.5,4.5 C4.5,6.15685425 5.84314575,7.5 7.5,7.5 Z M7.5,9 C5.01471863,9 3,6.98528137 3,4.5 C3,2.01471863 5.01471863,-3.6739404e-16 7.5,-3.6739404e-16 C9.98528137,-3.6739404e-16 12,2.01471863 12,4.5 C12,6.98528137 9.98528137,9 7.5,9 Z", fillOpacity: "0.87" }))))))); };

/* eslint-disable */
var Filter = function () { return (React.createElement("svg", { "aria-hidden": "true", focusable: "false", "aria-label": "Filter", width: "48", height: "48", viewBox: "0 0 48 48", xmlns: "http://www.w3.org/2000/svg" },
    React.createElement("g", { id: "icon/fidelity/filter", fill: "none", fillRule: "evenodd" },
        React.createElement("g", { id: "ic_filter" },
            React.createElement("g", { fill: "#D8D8D8", opacity: "0" },
                React.createElement("rect", { width: "48", height: "48" })),
            React.createElement("g", { transform: "translate(16 14)", fill: "currentColor" },
                React.createElement("g", null,
                    React.createElement("path", { d: "M1.53468397,11.3244256 C2.30584171,10.1516526 4.0927284,8.69757613 8,10 C11.5643313,11.1881104 13.1877038,10.2588113 13.9183327,9.30853287 C14.2918933,10.1286474 14.5,11.0400207 14.5,12 C14.5,15.5898509 11.5898509,18.5 8,18.5 C4.41014913,18.5 1.5,15.5898509 1.5,12 C1.5,11.7718729 1.51175212,11.5464906 1.53468397,11.3244256 Z", fillOpacity: "0.2" }),
                    React.createElement("path", { d: "M1.53471819,12.6759057 C2.39408133,13.5811739 4.12541941,14.1109247 5.5,13.5 C9.81068889,11.5841383 9.99203585,9.66827654 14.3948028,10.8290113 C14.4639074,11.2088572 14.5,11.6002137 14.5,12 C14.5,15.5898509 11.5898509,18.5 8,18.5 C4.63838968,18.5 1.87279864,15.9481381 1.53471819,12.6759057 Z", fillOpacity: "0.25" }),
                    React.createElement("path", { d: "M11,1.44328993e-15 L11,4.58151705 C13.9318303,5.7682918 16,8.64262245 16,12 C16,16.418278 12.418278,20 8,20 C3.581722,20 0,16.418278 0,12 C0,8.64262245 2.06816966,5.7682918 5,4.58151705 L5,1.60982339e-15 L6.5,1.44328993e-15 L6.5,5.67393184 C3.6333,6.35109564 1.5,8.92641836 1.5,12 C1.5,15.5898509 4.41014913,18.5 8,18.5 C11.5898509,18.5 14.5,15.5898509 14.5,12 C14.5,8.92641836 12.3667,6.35109564 9.5,5.67393184 L9.5,1.77635684e-15 L11,1.44328993e-15 Z", fillOpacity: "0.87" }))))))); };

/* eslint-disable */
var Focus = function () { return (React.createElement("svg", { focusable: "false", "aria-hidden": "true", "aria-label": "Focus", width: "48", height: "48", viewBox: "0 0 48 48", xmlns: "http://www.w3.org/2000/svg" },
    React.createElement("g", { id: "icon/fidelity/blur", fill: "none", fillRule: "evenodd" },
        React.createElement("g", { id: "ic_blur" },
            React.createElement("g", { fill: "#D8D8D8", opacity: "0" },
                React.createElement("rect", { width: "48", height: "48" })),
            React.createElement("g", { id: "icon", transform: "translate(12 12)" },
                React.createElement("rect", { fill: "#D8D8D8", opacity: "0", width: "24", height: "24" }),
                React.createElement("g", { transform: "translate(4 2)", fill: "currentColor" },
                    React.createElement("path", { d: "M8.51312274,19.9836057 C8.77273397,19.9669655 9.02898229,19.9377873 9.2812837,19.8966625 C9.14309542,19.9643562 9.04607398,20 9,20 C8.83633495,20 8.67398178,19.9944755 8.51312274,19.9836057 Z M2.27242753,15.0235117 C2.09503729,14.4174909 2,13.7771617 2,13.115 C2,8.89625769 7.39855682,4.1952443 9.03524007,2.8669743 C9.66704719,3.45933018 10.2896864,4.09178959 10.8802638,4.75434357 C12.9939648,7.12565193 14.310818,9.45010207 14.481291,11.4644804 C14.4937541,11.6117488 14.5,11.7569175 14.5,11.9 C14.5,15.5490785 11.5855665,18.5 8,18.5 C5.525182,18.5 3.37015673,17.0943182 2.27242753,15.0235117 Z M15.999821,11.9547651 C15.9999402,11.9698392 16,11.9849176 16,12 C16,12.0581275 15.9984809,12.1163475 15.9954873,12.1746435 C15.9978914,12.1015915 15.9993401,12.0282946 15.999821,11.9547651 Z", fillOpacity: "0.2" }),
                    React.createElement("path", { d: "M3.47269084,16.6357644 C3.47244857,13.6389249 9.59189484,15.3529683 12,11.5 C13.2066771,9.56931667 12.316614,7.05620551 11.0727604,4.97270186 C13.0737756,7.26814668 14.316054,9.51197209 14.481291,11.4644804 C14.4937541,11.6117488 14.5,11.7569175 14.5,11.9 C14.5,15.5490785 11.5855665,18.5 8,18.5 C6.2411126,18.5 4.64375705,17.7899702 3.47269084,16.6357644 Z", fillOpacity: "0.25" }),
                    React.createElement("path", { d: "M7.73975027,2.16383649 C6.84545319,2.94914111 5.95084629,3.82194197 5.11973623,4.75434357 C3.00603518,7.12565193 1.68918197,9.45010207 1.51870896,11.4644804 C1.50624591,11.6117488 1.5,11.7569175 1.5,11.9 C1.5,15.5492218 4.41434886,18.5 8,18.5 C11.5855665,18.5 14.5,15.5490785 14.5,11.9 C14.5,11.7569175 14.4937541,11.6117488 14.481291,11.4644804 C14.310818,9.45010207 12.9939648,7.12565193 10.8802638,4.75434357 C10.0491537,3.82194197 9.15454681,2.94914111 8.26024973,2.16383649 C8.17157048,2.08596503 8.08476013,2.01060875 8,1.93784184 C7.91523987,2.01060875 7.82842952,2.08596503 7.73975027,2.16383649 Z M8,20 C3.581722,20 0,16.3735065 0,11.9 C0,6.05 8,0 8,0 C8,0 16,6.05 16,11.9 C16,16.3732777 12.418278,20 8,20 Z", id: "Oval-7", fillOpacity: "0.87" }))))))); };

/* eslint-disable */
var Library = function () { return (React.createElement("svg", { focusable: "false", "aria-hidden": "true", "aria-label": "Library", width: "48", height: "48", viewBox: "0 0 48 48", xmlns: "http://www.w3.org/2000/svg" },
    React.createElement("g", { id: "icon/fidelity/library", fill: "none", fillRule: "evenodd" },
        React.createElement("g", { id: "ic_library", transform: "translate(15 15)", fill: "currentColor" },
            React.createElement("g", null,
                React.createElement("polygon", { id: "Rectangle-5", fillOpacity: "0.2", points: "3 3 12.5 1.5 12.5 15.5 1.5 15.5" }),
                React.createElement("path", { d: "M1.5,1.5 L1.5,15.5 L12.5,15.5 L12.5,1.5 L1.5,1.5 Z M0,0 L14,0 L14,17 L0,17 L0,0 Z", id: "Rectangle-11", fillOpacity: "0.87" }),
                React.createElement("polygon", { id: "Path-5", fillOpacity: "0.25", points: "3 11 6 7 8 9 9 8.5 11 11" }),
                React.createElement("circle", { id: "Oval-4", fillOpacity: "0.25", cx: "9", cy: "5", r: "1" }),
                React.createElement("rect", { id: "Rectangle-13", fillOpacity: "0.25", x: "3", y: "13", width: "8", height: "1" }),
                React.createElement("g", { transform: "rotate(14 -2.352 56.952)", fillOpacity: "0.2" },
                    React.createElement("path", { d: "M1.32904158,1.07500967e-13 L5,1.07500967e-13 L5,14.7234101 L4,10.7126291 L4,1 L1.57836958,1 L1.32904158,1.07500967e-13 Z M5,14.9745817 L5,16 L0.887271787,16 L5,14.9745817 Z" }),
                    React.createElement("path", { d: "M1.82769758,2 L3,2 L3,6.70184819 L1.82769758,2 Z", id: "Rectangle-12" }))))))); };

/* eslint-disable */
var Overlay = function () { return (React.createElement("svg", { focusable: "false", "aria-hidden": "true", "aria-label": "Overlays", width: "48", height: "48", viewBox: "0 0 48 48", xmlns: "http://www.w3.org/2000/svg" },
    React.createElement("g", { id: "icon/fidelity/overlay", fill: "none", fillRule: "evenodd" },
        React.createElement("g", { transform: "translate(15 15)", fill: "currentColor" },
            React.createElement("path", { d: "M13.5,4 L13.5,13.5 L4,13.5 L4,5 C4,4.44771525 4.44771525,4 5,4 L13.5,4 Z M15,4 L17,4 C17.5522847,4 18,4.44771525 18,5 L18,17 C18,17.5522847 17.5522847,18 17,18 L5,18 C4.44771525,18 4,17.5522847 4,17 L4,15 L14,15 C14.5522847,15 15,14.5522847 15,14 L15,4 Z", fillOpacity: "0.2" }),
            React.createElement("path", { d: "M1.5,1.5 L1.5,13.5 L13.5,13.5 L13.5,1.5 L1.5,1.5 Z M1,0 L14,0 C14.5522847,-1.01453063e-16 15,0.44771525 15,1 L15,14 C15,14.5522847 14.5522847,15 14,15 L1,15 C0.44771525,15 6.76353751e-17,14.5522847 0,14 L0,1 C-6.76353751e-17,0.44771525 0.44771525,1.01453063e-16 1,0 Z", id: "Rectangle-27", fillOpacity: "0.87" }))))); };

/* eslint-disable */
var Sticker = function () { return (React.createElement("svg", { focusable: "false", "aria-hidden": "true", width: "48px", height: "48px", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "aria-label": "Stickers", viewBox: "0 0 48 48" },
    React.createElement("g", { id: "icon/fidelity/sticker", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd" },
        React.createElement("g", { id: "ic_sticker" },
            React.createElement("g", { transform: "translate(14.000000, 14.000000)", fill: "currentColor" },
                React.createElement("g", { transform: "translate(2.000000, 2.000000)", fillOpacity: "0.2" },
                    React.createElement("path", { d: "M11.5840291,0.290311095 C14.1040281,1.4637822 15.9529364,3.83641178 16.3972985,6.6747443 C11.4538042,7.5567274 7.55733385,11.4556991 6.68374109,16.3973312 C3.83946575,15.9530468 1.46423317,14.1041207 0.290132399,11.5832649 C0.0988489957,10.7650202 3.01980663e-14,9.89786431 3.01980663e-14,9 C3.01980663e-14,6.64646143 0.903391324,4.50392121 2.38232909,2.90022422 C4.02683831,1.11698861 6.38297582,-3.55271368e-15 9,-3.55271368e-15 C9.89814387,-3.55271368e-15 10.7655602,0.0989105588 11.5840291,0.290311095 Z" }),
                    React.createElement("path", { d: "M17.9877222,8 L8,17.9877222 C8.2591955,12.5923102 12.5906864,8.26470667 17.9877222,8 Z" })),
                React.createElement("path", { d: "M9.87290303,14.9211604 C9.09408801,14.4293124 5,11.7146562 5,9 C5,7.34 6.34,6 8,6 C8.77,6 9.47,6.52 10,7 C10.53,6.52 11.23,6 12,6 C13.66,6 15,7.34 15,9 C15,9.30171667 14.9494261,9.60343334 14.8584511,9.90209822 C12.7354304,11.0373368 10.9933363,12.7905402 9.87290303,14.9211604 Z", fillOpacity: "0.25" }),
                React.createElement("path", { d: "M10,1.5 C5.30557963,1.5 1.5,5.30557963 1.5,10 C1.5,14.2449983 4.61102233,17.7611603 8.68374109,18.3973312 C9.55733385,13.4556991 13.4538042,9.5567274 18.3972985,8.6747443 C17.7608961,4.60976745 14.2436106,1.5 10,1.5 Z M0,10 C0,4.4771525 4.4771525,0 10,0 C15.5228475,0 20,4.4771525 20,10 C14.5988732,10.2649073 10.2649073,14.5988732 10.0116954,19.9999933 C4.4771525,20 0,15.5228475 0,10 Z", fillOpacity: "0.87" })))))); };

/* eslint-disable */
var text = function () {
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 48 48", focusable: "false", "aria-hidden": "true", "aria-label": "Texts", width: "48", height: "48" },
        React.createElement("g", { fill: "currentColor", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("path", { fillOpacity: "0.2", d: "M17.883 19.5H16.07L11.702 6.833l1.235-1.411L17.883 19.5z", transform: "translate(12 12)" }),
            React.createElement("path", { fillOpacity: "0.87", d: "M10.8 8.818L8.483 14.5h4.275l-1.96-5.682zM10 6.5l3.5-4 5.973 17H21V21h-8v-1.5h1.483L13.276 16H7.873l-1.426 3.5H8V21H3v-1.5h1.704L10 6.5zm1.702.333L16.069 19.5h1.814L12.937 5.422l-1.235 1.411z", transform: "translate(12 12)" }),
            React.createElement("path", { fillOpacity: "0.2", d: "M19.55 15l-.35-1H21v1h-1.45zm1.05 3l-.35-1H21v1h-.4zM7.639 8L7.25 9H3V8h4.639zm1.167-3l-.39 1H7V5h1.806zm-2.334 6l-.389 1H6v-1h.472zm-1.166 3l-.39 1H3v-1h2.306zm-1.167 3l-.389 1H3v-1h1.139zM15.35 3L15 2h1v1h-.65zm3.15 9l-.35-1H21v1h-2.5zm-1.05-3l-.35-1H21v1h-3.55zM16.4 6l-.35-1H18v1h-1.6zm-5.9-3H9V2h2.5l-1 1zM3 5h3v1H3V5zm16 0h2v1h-2V5zM3 11h2v1H3v-1zm18-8h-4V2h4v1zM8 3H3V2h5v1z", transform: "translate(12 12)" }))));
};

/* eslint-disable */
var TextDesign = function () {
    return (React.createElement("svg", { focusable: "false", "aria-hidden": "true", "aria-label": "Text Design", width: "48", height: "48", viewBox: "0 0 48 48", xmlns: "http://www.w3.org/2000/svg" },
        React.createElement("g", { fill: "currentColor", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("path", { fillOpacity: "0.87", d: "M1 0h14a1 1 0 011 1v19l-8-6-8 6V1a1 1 0 011-1zm.5 1.5V17L8 12.125 14.5 17V1.5h-13z", transform: "translate(14 14) translate(2)" }),
            React.createElement("path", { fillOpacity: "0.2", d: "M1.5 1.5h13V17L8 12.125 1.5 17V1.5z", transform: "translate(14 14) translate(2)" }),
            React.createElement("path", { fillOpacity: "0.25", d: "M9 4l2.52 7H10.2l-.7-1.85H6.45L5.77 11H4.49L6.9 4H9zm-1.04.78h-.05L6.73 8.14H9.2L7.96 4.78z", transform: "translate(14 14) translate(2)" }))));
};

/* eslint-disable */
var Frame = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", focusable: "false", "aria-hidden": "true", "aria-label": "Frames", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("g", { fill: "currentColor", fillRule: "evenodd", stroke: "none", strokeWidth: "1", transform: "translate(12 12)" },
        React.createElement("path", { fillOpacity: "0.2", d: "M8 8L17 7 17 17 7 17z" }),
        React.createElement("path", { fillOpacity: "0.87", d: "M4.5 19.5h15v-15h-15v15zM3 3h18v18H3V3z" }),
        React.createElement("path", { fillOpacity: "0.87", d: "M7 17h10V7H7v10zM6 6h12v12H6V6z" }),
        React.createElement("path", { fillOpacity: "0.25", d: "M9 15L11 12 13 14 14 13.5 15 15z" })))); };

/* eslint-disable */
function Icon() {
    return (React.createElement("svg", { focusable: "false", "aria-hidden": "true", "aria-label": "Transform", width: "48", height: "48", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "currentColor", fillRule: "evenodd", stroke: "none", strokeWidth: "1", transform: "translate(12 12)" },
            React.createElement("path", { fillOpacity: "0.2", d: "M10 10L15 9 15 15 9 15z" }),
            React.createElement("path", { fillOpacity: "0.87", d: "M9 15h6V9H9v6zm-1.5 0V7.5H15V3h1.5v13.5H3V15h4.5zm0 2.5H9V21H7.5v-3.5zM21 7.5V9h-3.5V7.5H21z" }),
            React.createElement("g", { fillOpacity: "0.2" },
                React.createElement("path", { d: "M0 10h1a9.003 9.003 0 015.5-8.294L7 3 10.942.044C10.632.014 10.318 0 10 0 4.477 0 0 4.477 0 10z", transform: "translate(2 2)" }),
                React.createElement("path", { d: "M9 20h1a9.003 9.003 0 015.5-8.294L16 13l3.942-2.956c-.31-.03-.624-.044-.942-.044-5.523 0-10 4.477-10 10z", transform: "translate(2 2) rotate(-180 14.47 15)" })))));
}

/* eslint-disable */
function Icon$1() {
    return (React.createElement("svg", { focusable: "false", "aria-hidden": "true", "aria-label": "Brush", width: "48", height: "48", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "currentColor", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("path", { fillOpacity: "0.87", d: "M14.73 18.86C13.293 19.503 11.624 20 10 20 2 20 0 13 0 10c.486.972 2.37 5.848 7.537 4.165C7.873 17.125 10.427 19 13 19c.6 0 1.177-.05 1.73-.14zM8.422 8.63a7.352 7.352 0 00-1.127 1.616L2.401 3.705c-.215-.287-.178-.807.072-1.056l.088-.088L8.5 8.5l-.078.13z", opacity: "0.5", transform: "translate(12 12) translate(2 2)" }),
            React.createElement("path", { fillOpacity: "0.87", d: "M7.295 10.246c-.27.526-.48 1.09-.615 1.68L1.2 4.603c-.663-.885-.564-2.24.212-3.015l.176-.176c.78-.78 2.121-.881 3.015-.212l7.245 5.421a6.088 6.088 0 00-1.67.624L3.706 2.401c-.294-.22-.801-.184-1.056.072l-.176.176c-.25.25-.287.769-.072 1.056l4.894 6.54z", transform: "translate(12 12) translate(2 2)" }),
            React.createElement("path", { fillOpacity: "0.87", d: "M9.702 6.554c-.185-.869-.151-.71-.207-.955C8.88 2.902 8.145 2 6 2 3.98 2 2 4.08 2 6.5c0 2.294 1.835 4 4 4 1.545 0 2.915-.342 4.544-1.088-.332-.7-.578-1.619-.842-2.858z", opacity: "0.5", transform: "translate(12 12) translate(2 2) translate(7 7)" }),
            React.createElement("path", { fillOpacity: "0.25", d: "M10.379 9.027c.053.135.108.263.165.385C8.914 10.158 7.545 10.5 6 10.5c-2.165 0-4-1.706-4-4 0-1.528.79-2.921 1.88-3.74-.882 2.084-1.025 6.482 6.499 6.267z", transform: "translate(12 12) translate(2 2) translate(7 7)" }),
            React.createElement("path", { fillOpacity: "0.87", d: "M9.702 6.554c-.185-.869-.151-.71-.207-.955C8.88 2.902 8.145 2 6 2 3.98 2 2 4.08 2 6.5c0 2.294 1.835 4 4 4 1.545 0 2.915-.342 4.544-1.088-.332-.7-.578-1.619-.842-2.858zM6 12C3.239 12 .5 9.842.5 6.5S3.239.5 6 .5c6.5 0 4 8 7 9.342C11 10.947 8.761 12 6 12z", transform: "translate(12 12) translate(2 2) translate(7 7)" }))));
}

var Icon$2 = function () {
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", viewBox: "0 0 48 48", focusable: "false", "aria-hidden": "true", "aria-label": "Left Align", width: "26", height: "26" },
        React.createElement("defs", null,
            React.createElement("path", { id: "align-left-icon", d: "M27 30v3H12v-3h15zm9-7.5v3H12v-3h24zm0-7.5v3H12v-3h24z" })),
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("mask", { fill: "#fff" },
                React.createElement("use", { xlinkHref: "#align-left-icon" })),
            React.createElement("use", { fill: "currentColor", xlinkHref: "#align-left-icon" }))));
};

function Icon$3() {
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", viewBox: "0 0 48 48", width: "26", height: "26", focusable: "false", "aria-hidden": "true", "aria-label": "Right Align" },
        React.createElement("defs", null,
            React.createElement("path", { id: "align-right-icon", d: "M27 30v3H12v-3h15zm9-7.5v3H12v-3h24zm0-7.5v3H12v-3h24z" })),
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("path", { d: "M0 0H48V48H0z" }),
            React.createElement("mask", { fill: "#fff" },
                React.createElement("use", { xlinkHref: "#align-right-icon" })),
            React.createElement("use", { fill: "currentColor", transform: "matrix(-1 0 0 1 48 0)", xlinkHref: "#align-right-icon" }))));
}

function Icon$4() {
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", viewBox: "0 0 48 48", focusable: "false", "aria-hidden": "true", "aria-label": "Center Align", width: "26", height: "26" },
        React.createElement("defs", null,
            React.createElement("path", { id: "align-center-icon", d: "M31.5 30v3h-15v-3h15zm4.5-7.5v3H12v-3h24zm0-7.5v3H12v-3h24z" })),
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("mask", { fill: "#fff" },
                React.createElement("use", { xlinkHref: "#align-center-icon" })),
            React.createElement("use", { fill: "currentColor", xlinkHref: "#align-center-icon" }))));
}

var AddText = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 24 24" },
    React.createElement("defs", null,
        React.createElement("path", { id: "icon-add-text", d: "M12 0c6.627 0 12 5.373 12 12s-5.373 12-12 12S0 18.627 0 12 5.373 0 12 0zm1 6h-2v5H6v2h5v5h2v-5h5v-2h-5V6z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#icon-add-text" })),
        React.createElement("use", { fill: "currentColor", fillRule: "nonzero", xlinkHref: "#icon-add-text" })))); };

var OpenWebcam = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24" },
    React.createElement("path", { fill: "currentColor", fillOpacity: "0.9", fillRule: "evenodd", stroke: "none", strokeWidth: "1", d: "M12 1c5.523 0 10 4.477 10 10a9.98 9.98 0 01-3.678 7.749c1.877.92 3.445 2.251 4.502 3.88l.176.283-1.743 1.02c-1.04-1.735-2.824-3.102-4.995-3.884A9.94 9.94 0 0112 21a9.962 9.962 0 01-4.255-.948c-2.076.748-3.797 2.033-4.852 3.661l-.147.237L1 22.935c1.053-1.766 2.694-3.204 4.684-4.183A9.975 9.975 0 012 11C2 5.477 6.477 1 12 1zm0 2a8 8 0 100 16 8 8 0 000-16zm0 5a5 5 0 110 10 5 5 0 010-10zm0 2a3 3 0 100 6 3 3 0 000-6zm1-4v1h-2V6h2z" }))); };

var Reset = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24" },
    React.createElement("path", { fill: "currentColor", fillOpacity: "0.9", fillRule: "evenodd", stroke: "none", strokeWidth: "1", d: "M16.23 10.885a2.292 2.292 0 00-2.285-2.286 2.292 2.292 0 00-2.286 2.286 2.292 2.292 0 002.286 2.286 2.292 2.292 0 002.286-2.286zM13.946.599C8.265.6 3.66 5.205 3.66 10.885H.231l4.571 4.571 4.572-4.571H5.945c0-4.423 3.577-8 8-8s8 3.577 8 8a7.994 7.994 0 01-12.64 6.514l-1.623 1.646a10.3 10.3 0 006.263 2.126c5.68 0 10.286-4.606 10.286-10.286S19.625.599 13.945.599z", transform: "rotate(56 11.298 10.261)" }))); };

function Icon$5() {
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 24 24" },
        React.createElement("defs", null,
            React.createElement("path", { id: "a", d: "M24 10v8a3 3 0 01-3 3H6v3l-6-4 6-4v3h15a1 1 0 001-1v-8h2zM18 0l6 4-6 4V5H3a1 1 0 00-1 1v8H0V6a3 3 0 013-3h15V0z" })),
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("mask", { fill: "currentColor" },
                React.createElement("use", { xlinkHref: "#a" })),
            React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#a" }))));
}

var Export = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 24 24" },
    React.createElement("defs", null,
        React.createElement("path", { id: "upload-icon", d: "M4.143 17.286l-.001 3.142h15.715v-3.142H23v6.285H1v-6.285h3.143zM12 0l9.429 9.429-2.2 2.2L13.57 5.97v9.743H10.43V5.971L4.77 11.63l-2.2-2.2L12 0z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#upload-icon" })),
        React.createElement("use", { fill: "currentColor", xlinkHref: "#upload-icon" })))); };

var Undo = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "25", height: "25", viewBox: "0 0 25 25" },
    React.createElement("defs", null,
        React.createElement("path", { id: "undo-icon", d: "M4 10.065C4 4.506 8.365 0 13.75 0s9.75 4.506 9.75 10.065v9.29h-3v-9.29c0-3.849-3.022-6.968-6.75-6.968S7 6.217 7 10.065v7.741h3L5.5 24 1 17.806h3v-7.741z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#undo-icon" })),
        React.createElement("use", { fill: "currentColor", transform: "rotate(90 12.25 12)", xlinkHref: "#undo-icon" })))); };

var Redo = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "25", height: "25", viewBox: "0 0 25 25" },
    React.createElement("defs", null,
        React.createElement("path", { id: "redo-icon", d: "M4 10.065C4 4.506 8.365 0 13.75 0s9.75 4.506 9.75 10.065v9.29h-3v-9.29c0-3.849-3.022-6.968-6.75-6.968S7 6.217 7 10.065v7.741h3L5.5 24 1 17.806h3v-7.741z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#redo-icon" })),
        React.createElement("use", { fill: "currentColor", transform: "matrix(0 1 1 0 .25 -.25)", xlinkHref: "#redo-icon" })))); };

var Close = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 24 24" },
    React.createElement("defs", null,
        React.createElement("path", { id: "close-icon", d: "M21.583 0L24 2.416 14.416 12 24 21.584 21.583 24 12 14.416 2.417 24 0 21.584 9.584 12 0 2.416 2.417 0 12 9.584 21.583 0z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#close-icon" })),
        React.createElement("use", { fill: "currentColor", fillRule: "nonzero", xlinkHref: "#close-icon" })))); };

function Icon$6() {
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 24 24" },
        React.createElement("defs", null,
            React.createElement("path", { id: "export-icon", d: "M22 1.5a1.5 1.5 0 011.493 1.356L23.5 3H22h1.5v17a1.5 1.5 0 01-1.5 1.5H12a1.5 1.5 0 01-1.493-1.356L10.5 20v-6h2v5.499h9v-16h-9V9h-2V3A1.5 1.5 0 0112 1.5h10zM6.15 5.817L7.634 7.3l-3.171 3.171h13.978v2H4.47l3.171 3.17-1.483 1.483L.5 11.467l5.65-5.65z" })),
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("mask", { fill: "#fff" },
                React.createElement("use", { xlinkHref: "#export-icon" })),
            React.createElement("use", { fill: "currentcolor", fillOpacity: "0.9", transform: "rotate(90 12 11.5)", xlinkHref: "#export-icon" }))));
}

var Edit = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24" },
    React.createElement("path", { fill: "currentColor", fillRule: "evenodd", stroke: "none", strokeWidth: "1", d: "M2.087 7.115h7.66v15.32h5.027l.223-15.32h7.438V2.087H2.087v5.028zM14.075 24h-4.15a2.42 2.42 0 01-1.718-.711 2.423 2.423 0 01-.711-1.717V9.01H2.429c-.67 0-1.278-.273-1.718-.713A2.426 2.426 0 010 6.579V2.43C0 1.76.272 1.153.711.713A2.424 2.424 0 012.43 0h19.142c.671 0 1.278.272 1.718.713.439.44.711 1.047.711 1.718v4.148c0 .671-.272 1.278-.711 1.718-.44.44-1.047.713-1.718.713h-5.067v12.562c0 .67-.272 1.278-.711 1.717a2.42 2.42 0 01-1.718.711z" }))); };

var Duplicate = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 24 24" },
    React.createElement("defs", null,
        React.createElement("path", { id: "duplicate-icon", d: "M3.429 8.571v12h12v-12h-12zM1.714 5.143h15.429c.947 0 1.714.767 1.714 1.714v15.429c0 .946-.767 1.714-1.714 1.714H1.714A1.714 1.714 0 010 22.286V6.857c0-.947.768-1.714 1.714-1.714zM22.286 0C23.232 0 24 .768 24 1.714v15.429c0 .947-.768 1.714-1.714 1.714H20.57V3.429L5.142 3.428V1.714C5.143.768 5.91 0 6.858 0h15.429z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#duplicate-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#duplicate-icon" })))); };

var Delete = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 24 24" },
    React.createElement("defs", null,
        React.createElement("path", { id: "delete-icon", d: "M20 6l-2.312 15.718A1.5 1.5 0 0116.204 23H5.796a1.5 1.5 0 01-1.484-1.282L2 6h18zM7 1a1 1 0 011-1h6a1 1 0 011 1v1h7v2H0V2h7V1z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#delete-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#delete-icon" })))); };

var BringToFront = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 24 24" },
    React.createElement("defs", null,
        React.createElement("path", { id: "bring-to-front-icon", d: "M21 16a2 2 0 012 2v4a2 2 0 01-2 2H3a2 2 0 01-2-2v-4a2 2 0 012-2h18zM12.006 1l5.996 5.996-1.414 1.414-3.578-3.577V12h-2.008V4.833L7.418 8.417 6.004 7.003 12.006 1z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H24V24H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#bring-to-front-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#bring-to-front-icon" })))); };

var FlipHorizontal = function (_a) {
    var className = _a.className;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 15 14", transform: "scale(-1, 1)", className: className },
        React.createElement("title", null, "Flip Horizontal"),
        React.createElement("defs", null,
            React.createElement("path", { id: "flip-horizontal-icon", d: "M42 1v14h-1.167v-1.167H37a2 2 0 01-2-2V4.167a2 2 0 012-2l3.833-.001V1H42zm5.833 11.958a.875.875 0 01-.875.875h-3.791v-1.166l3.499-.001V3.333h-3.5V2.167h3.792c.446 0 .815.333.869.765l.006.11v9.916z" })),
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1", transform: "translate(-34 -1)" },
            React.createElement("mask", { fill: "none" },
                React.createElement("use", { xlinkHref: "#flip-horizontal-icon" })),
            React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#flip-horizontal-icon" }))));
};

var FlipVertical = function (_a) {
    var className = _a.className;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 15 14", className: className },
        React.createElement("title", null, "Flip Vertical"),
        React.createElement("defs", null,
            React.createElement("path", { id: "flip-vertical-icon", d: "M42 1v14h-1.167v-1.167H37a2 2 0 01-2-2V4.167a2 2 0 012-2l3.833-.001V1H42zm5.833 11.958a.875.875 0 01-.875.875h-3.791v-1.166l3.499-.001V3.333h-3.5V2.167h3.792c.446 0 .815.333.869.765l.006.11v9.916z" })),
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1", transform: "translate(-34 -1)" },
            React.createElement("mask", { fill: "none" },
                React.createElement("use", { xlinkHref: "#flip-vertical-icon" })),
            React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", transform: "rotate(-90 41.417 8)", xlinkHref: "#flip-vertical-icon" }))));
};

var Dots = function (_a) {
    var height = _a.height, width = _a.width, x = _a.x, className = _a.className, style = _a.style;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 102 3", className: className, style: style },
        React.createElement("pattern", { id: "slider-dots", fill: "currentColor", patternUnits: "userSpaceOnUse", width: "102", height: "3" },
            React.createElement("rect", { width: "3", height: "3", x: "99", y: "0", opacity: "0.5", rx: "1.5" }),
            React.createElement("rect", { width: "3", height: "3", x: "88", y: "0", opacity: "0.5", rx: "1.5" }),
            React.createElement("rect", { width: "3", height: "3", x: "77", y: "0", opacity: "0.5", rx: "1.5" }),
            React.createElement("rect", { width: "3", height: "3", x: "66", y: "0", rx: "1.5" }),
            React.createElement("rect", { width: "3", height: "3", x: "55", y: "0", opacity: "0.5", rx: "1.5" }),
            React.createElement("rect", { width: "3", height: "3", x: "44", y: "0", opacity: "0.5", rx: "1.5" }),
            React.createElement("rect", { width: "3", height: "3", x: "33", y: "0", opacity: "0.5", rx: "1.5" }),
            React.createElement("rect", { width: "3", height: "3", x: "22", y: "0", opacity: "0.5", rx: "1.5" }),
            React.createElement("rect", { width: "3", height: "3", x: "11", y: "0", rx: "1.5" })),
        React.createElement("rect", { fill: "url(#slider-dots)", x: -width * 1.5, y: "0", width: width * 4, height: "3", transform: "translate(" + x + ", 0)" })));
};
Dots.defaultProps = {
    height: 3,
    width: 102,
    x: -102,
};

var Rotate = function (_a) {
    var alt = _a.alt, className = _a.className;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "24", height: "24", viewBox: "0 0 16 16", className: className },
        React.createElement("title", null, alt),
        React.createElement("defs", null,
            React.createElement("path", { id: "rotate-icon", d: "M132 0l1.25 1.57a8.01 8.01 0 0110.41.77 8.015 8.015 0 010 11.32c-.33.33-.67.62-1.04.859-1.38.991-3 1.481-4.62 1.481v-2c1.22 0 2.44-.37 3.47-1.111a6 6 0 00.77-9.129 5.992 5.992 0 00-7.73-.63L136 5h-5l1-5zm2.43 12.82c.5.38 1.06.67 1.66.87l-.64 1.89a7.56 7.56 0 01-1.48-.67l-.03-.01v-.01h-.02v-.01h-.01c0-.01-.01-.01-.01-.01h-.01v-.01h-.02v-.01h-.01l-.01-.01s-.01 0-.01-.01h-.01c-.2-.12-.4-.26-.6-.4zm-2.15-3.02c.18.6.47 1.17.83 1.68l-1.63 1.16v-.01s-.01 0-.01-.01c0 0 0-.01-.01-.01v-.01h-.01v-.01c-.01 0-.01-.01-.01-.01v-.01h-.01v-.01h-.01v-.01c0-.01-.01-.01-.01-.01v-.01c-.01 0-.01 0-.01-.01-.27-.39-.49-.79-.68-1.21-.01 0-.01-.01-.01-.01v-.01h-.01v-.02l-.01-.01c0-.02-.01-.02-.01-.02v-.02h-.01v-.02h-.01v-.03h-.01v-.02h-.01v-.02c-.01 0-.01 0-.01-.01v-.01c-.1-.23-.19-.47-.26-.7z" })),
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1", transform: "translate(-130)" },
            React.createElement("mask", { fill: "none" },
                React.createElement("use", { xlinkHref: "#rotate-icon" })),
            React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#rotate-icon" }))));
};
Rotate.defaultProps = {
    alt: 'Rotate',
};

var CommonCategory = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("g", { fill: "none", fillOpacity: "0.9", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("g", { fill: "currentColor", transform: "translate(13 13)" },
            React.createElement("path", { d: "M22 3.701h-1.642V1.644l-2.06-.001V0h2.538c.421 0 .682.174.827.32.322.322.337.748.337.83v2.551z" }),
            React.createElement("path", { d: "M1.643 3.701H0V1.165C0 .743.174.482.32.336.64.016 1.06 0 1.147 0H3.701v1.643H1.644l-.001 2.058z" }),
            React.createElement("path", { d: "M13.7232174 1.5486087L17.4249565 1.5486087 17.4249565 0 13.7232174 0z" }),
            React.createElement("path", { d: "M9.15008696 1.5486087L12.8508696 1.5486087 12.8508696 0 9.15008696 0z" }),
            React.createElement("path", { d: "M4.57504348 1.5486087L8.27678261 1.5486087 8.27678261 0 4.57504348 0z" }),
            React.createElement("path", { d: "M0 8.27582609L1.5486087 8.27582609 1.5486087 4.57504348 0 4.57504348z" }),
            React.createElement("path", { d: "M20.4513913 8.27582609L22 8.27582609 22 4.57504348 20.4513913 4.57504348z" }),
            React.createElement("path", { d: "M0 12.8508696L1.5486087 12.8508696 1.5486087 9.14913043 0 9.14913043z" }),
            React.createElement("path", { d: "M0 17.4249565L1.5486087 17.4249565 1.5486087 13.7232174 0 13.7232174z" }),
            React.createElement("path", { d: "M20.4513913 12.8508696L22 12.8508696 22 9.14913043 20.4513913 9.14913043z" }),
            React.createElement("path", { d: "M20.4513913 17.4249565L22 17.4249565 22 13.7232174 20.4513913 13.7232174z" }),
            React.createElement("path", { d: "M3.702 22H1.165c-.421 0-.682-.174-.828-.32-.322-.322-.337-.748-.337-.83v-2.552h1.643v2.059h2.059V22z" }),
            React.createElement("path", { d: "M20.853 22h-2.554v-1.642h2.057l.001-2.06H22v2.538c0 .42-.174.682-.319.827-.32.32-.742.337-.828.337" }),
            React.createElement("path", { d: "M4.57504348 22L8.27678261 22 8.27678261 20.4513913 4.57504348 20.4513913z" }),
            React.createElement("path", { d: "M9.15008696 22L12.8508696 22 12.8508696 20.4513913 9.15008696 20.4513913z" }),
            React.createElement("path", { d: "M13.7232174 22L17.4249565 22 17.4249565 20.4513913 13.7232174 20.4513913z" }))))); };

var FacebookCategory = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { fill: "currentColor", d: "M29.967 13.005L26.984 13c-3.35 0-5.516 2.222-5.516 5.66v2.61h-2.999c-.26 0-.469.21-.469.47v3.78c0 .26.21.47.469.47h2.999v9.541c0 .26.21.469.469.469h3.912c.26 0 .47-.21.47-.469V25.99h3.506c.259 0 .469-.21.469-.47l.001-3.78a.47.47 0 00-.469-.47h-3.508v-2.212c0-1.064.254-1.603 1.639-1.603l2.01-.001c.258 0 .468-.21.468-.47v-3.51a.47.47 0 00-.468-.47z" })))); };

var InstagramCategory = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("g", { fill: "currentColor", transform: "translate(13 13)" },
            React.createElement("path", { d: "M15.125 0h-8.25A6.876 6.876 0 000 6.875v8.25A6.876 6.876 0 006.875 22h8.25A6.876 6.876 0 0022 15.125v-8.25A6.876 6.876 0 0015.125 0zm4.813 15.125a4.818 4.818 0 01-4.813 4.813h-8.25a4.818 4.818 0 01-4.813-4.813v-8.25a4.818 4.818 0 014.813-4.813h8.25a4.818 4.818 0 014.813 4.813v8.25z" }),
            React.createElement("path", { d: "M11 5.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zm0 8.938A3.442 3.442 0 017.562 11 3.441 3.441 0 0111 7.562 3.441 3.441 0 0114.438 11 3.442 3.442 0 0111 14.438z" }),
            React.createElement("circle", { cx: "16.913", cy: "5.088", r: "1" }))))); };

var TwitterCategory = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("g", { fill: "none", fillOpacity: "0.9", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { fill: "currentColor", d: "M36 17.305c-.892.402-1.843.668-2.835.797a4.997 4.997 0 002.165-2.79 9.685 9.685 0 01-3.12 1.222 4.874 4.874 0 00-3.595-1.596c-2.723 0-4.916 2.267-4.916 5.047 0 .4.032.785.113 1.151-4.09-.205-7.71-2.215-10.141-5.278a5.18 5.18 0 00-.673 2.55c0 1.748.877 3.297 2.185 4.194a4.766 4.766 0 01-2.223-.621v.055c0 2.452 1.705 4.49 3.942 4.958-.4.113-.837.167-1.29.167-.315 0-.633-.019-.931-.087.637 1.999 2.446 3.468 4.597 3.516a9.73 9.73 0 01-6.1 2.152c-.404 0-.791-.018-1.178-.07a13.601 13.601 0 007.548 2.266c9.054 0 14.004-7.693 14.004-14.36 0-.224-.008-.439-.018-.653A9.958 9.958 0 0036 17.305z" })))); };

var Custom = function (_a) {
    var _b = _a.highlight, highlight = _b === void 0 ? '#565656' : _b, _c = _a.width, width = _c === void 0 ? '32px' : _c, _d = _a.height, height = _d === void 0 ? '32px' : _d;
    return (React.createElement("svg", { className: "common-crop-thumbnail", xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 32 32" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("g", { fill: highlight, transform: "translate(-8 -8)" },
                React.createElement("g", { transform: "translate(8 8)" },
                    React.createElement("g", null,
                        React.createElement("path", { d: "M.941 31.992h2.824v-.94L.941 31.05v-2.822h-.94v2.846s-.004.918.94.918" }),
                        React.createElement("path", { d: "M31.974 31.051v-2.823h-.942v2.823h-2.823v.941h2.846s.919.003.919-.94" }),
                        React.createElement("path", { d: "M4.62305882 31.9926588L8.38776471 31.9926588 8.38776471 31.0514824 4.62305882 31.0514824z" }),
                        React.createElement("path", { d: "M9.32894118 31.9926588L13.0936471 31.9926588 13.0936471 31.0514824 9.32894118 31.0514824z" }),
                        React.createElement("path", { d: "M14.0348235 31.9926588L17.7995294 31.9926588 17.7995294 31.0514824 14.0348235 31.0514824z" }),
                        React.createElement("path", { d: "M18.7407059 31.9926588L22.5054118 31.9926588 22.5054118 31.0514824 18.7407059 31.0514824z" }),
                        React.createElement("path", { d: "M23.4465882 31.9926588L27.2112941 31.9926588 27.2112941 31.0514824 23.4465882 31.0514824z" }),
                        React.createElement("path", { d: "M0 .94v2.824h.941L.942.941h2.823V0H.919S0-.002 0 .94" }),
                        React.createElement("path", { d: "M31.032 0H28.21v.94l2.823.002v2.822h.942V.92s.002-.92-.942-.92" }),
                        React.createElement("path", { d: "M4.62305882 0.940423529L8.38776471 0.940423529 8.38776471 -0.000752941176 4.62305882 -0.000752941176z" }),
                        React.createElement("path", { d: "M9.32894118 0.940423529L13.0936471 0.940423529 13.0936471 -0.000752941176 9.32894118 -0.000752941176z" }),
                        React.createElement("path", { d: "M14.0348235 0.940423529L17.7995294 0.940423529 17.7995294 -0.000752941176 14.0348235 -0.000752941176z" }),
                        React.createElement("path", { d: "M18.7407059 0.940423529L22.5054118 0.940423529 22.5054118 -0.000752941176 18.7407059 -0.000752941176z" }),
                        React.createElement("path", { d: "M23.4465882 0.940423529L27.2112941 0.940423529 27.2112941 -0.000752941176 23.4465882 -0.000752941176z" }),
                        React.createElement("path", { d: "M0 8.46324706L0.941176471 8.46324706 0.941176471 4.69854118 0 4.69854118z" }),
                        React.createElement("path", { d: "M0 13.1691294L0.941176471 13.1691294 0.941176471 9.40442353 0 9.40442353z" }),
                        React.createElement("path", { d: "M0 17.8750118L0.941176471 17.8750118 0.941176471 14.1103059 0 14.1103059z" }),
                        React.createElement("path", { d: "M0 22.5808941L0.941176471 22.5808941 0.941176471 18.8161882 0 18.8161882z" }),
                        React.createElement("path", { d: "M0 27.2867765L0.941176471 27.2867765 0.941176471 23.5220706 0 23.5220706z" }),
                        React.createElement("path", { d: "M30.976 8.46324706L31.9171765 8.46324706 31.9171765 4.69854118 30.976 4.69854118z" }),
                        React.createElement("path", { d: "M30.976 13.1691294L31.9171765 13.1691294 31.9171765 9.40442353 30.976 9.40442353z" }),
                        React.createElement("path", { d: "M30.976 17.8750118L31.9171765 17.8750118 31.9171765 14.1103059 30.976 14.1103059z" }),
                        React.createElement("path", { d: "M30.976 22.5808941L31.9171765 22.5808941 31.9171765 18.8161882 30.976 18.8161882z" }),
                        React.createElement("path", { d: "M30.976 27.2867765L31.9171765 27.2867765 31.9171765 23.5220706 30.976 23.5220706z" })))))));
};

var Square = function (_a) {
    var _b = _a.highlight, highlight = _b === void 0 ? '#565656' : _b, _c = _a.mask, mask = _c === void 0 ? '#fff' : _c, _d = _a.width, width = _d === void 0 ? '32px' : _d, _e = _a.height, height = _e === void 0 ? '32px' : _e;
    return (React.createElement("svg", { className: "common-crop-thumbnail", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: width, height: height, viewBox: "0 0 32 32" },
        React.createElement("defs", null,
            React.createElement("rect", { id: "square-icon", width: "32", height: "32", x: "0.92", y: "0.707", rx: "1" })),
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("g", { transform: "translate(-8 -8)" },
                React.createElement("g", { transform: "translate(7.08 7.293)" },
                    React.createElement("mask", { fill: mask },
                        React.createElement("use", { xlinkHref: "#square-icon" })),
                    React.createElement("use", { fill: highlight, xlinkHref: "#square-icon" }))))));
};

var FourByThree = function (_a) {
    var _b = _a.highlight, highlight = _b === void 0 ? '#565656' : _b, _c = _a.width, width = _c === void 0 ? '32px' : _c, _d = _a.height, height = _d === void 0 ? '48px' : _d;
    return (React.createElement("svg", { className: "common-crop-thumbnail", xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 42 32" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("g", { fill: highlight, transform: "translate(-3 -8)" },
                React.createElement("rect", { width: "42", height: "32", x: "3", y: "8", rx: "0.5" })))));
};

var ThreeByFour = function (_a) {
    var _b = _a.highlight, highlight = _b === void 0 ? '#565656' : _b, _c = _a.width, width = _c === void 0 ? '32px' : _c, _d = _a.height, height = _d === void 0 ? '42px' : _d;
    return (React.createElement("svg", { className: "common-crop-thumbnail", xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 32 42" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("g", { fill: highlight, transform: "translate(-8 -3)" },
                React.createElement("rect", { width: "42", height: "32", x: "3", y: "8", rx: "0.5", transform: "rotate(90 24 24)" })))));
};

var SixteenByNine = function (_a) {
    var _b = _a.highlight, highlight = _b === void 0 ? '#565656' : _b, _c = _a.width, width = _c === void 0 ? '26px' : _c, _d = _a.height, height = _d === void 0 ? '46px' : _d;
    return (React.createElement("svg", { className: "common-crop-thumbnail", xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 26 46" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("g", { fill: highlight, transform: "translate(-11 -1)" },
                React.createElement("path", { d: "M1 11.496A.5.5 0 011.5 11h45a.5.5 0 01.5.496v25.008a.5.5 0 01-.5.496h-45a.5.5 0 01-.5-.496V11.496z" })))));
};

var NineBySixteen = function (_a) {
    var _b = _a.highlight, highlight = _b === void 0 ? '#565656' : _b, _c = _a.width, width = _c === void 0 ? '26px' : _c, _d = _a.height, height = _d === void 0 ? '46px' : _d;
    return (React.createElement("svg", { className: "common-crop-thumbnail", xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 26 46" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("g", { fill: highlight, transform: "translate(-11 -1)" },
                React.createElement("path", { d: "M1 11.496A.5.5 0 011.5 11h45a.5.5 0 01.5.496v25.008a.5.5 0 01-.5.496h-45a.5.5 0 01-.5-.496V11.496z", transform: "rotate(90 24 24)" })))));
};

var FacebookPost = function (_a) {
    var _b = _a.main, main = _b === void 0 ? '#424242' : _b, _c = _a.highlight, highlight = _c === void 0 ? '#565656' : _c, _d = _a.width, width = _d === void 0 ? '48px' : _d, _e = _a.height, height = _e === void 0 ? '48px' : _e;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("rect", { width: "28", height: "3", x: "12", y: "41", fill: main, rx: "0.5", transform: "matrix(-1 0 0 1 52 0)" }),
            React.createElement("rect", { width: "34", height: "28", x: "7", y: "8", fill: highlight, rx: "0.5", transform: "matrix(1 0 0 -1 0 44)" }),
            React.createElement("rect", { width: "3", height: "3", x: "8", y: "41", fill: main, rx: "0.5", transform: "matrix(-1 0 0 1 19 0)" }),
            React.createElement("rect", { width: "28", height: "3", x: "12", y: "37", fill: main, rx: "0.5", transform: "matrix(-1 0 0 1 52 0)" }),
            React.createElement("rect", { width: "28", height: "3", x: "12", y: "4", fill: main, rx: "0.5", transform: "matrix(1 0 0 -1 0 11)" }),
            React.createElement("rect", { width: "3", height: "3", x: "8", y: "37", fill: main, rx: "0.5", transform: "matrix(-1 0 0 1 19 0)" }),
            React.createElement("rect", { width: "3", height: "3", x: "8", y: "4", fill: main, rx: "0.5", transform: "matrix(1 0 0 -1 0 11)" }))));
};

var FacebookProfile = function (_a) {
    var _b = _a.main, main = _b === void 0 ? '#424242' : _b, _c = _a.highlight, highlight = _c === void 0 ? '#565656' : _c, _d = _a.width, width = _d === void 0 ? '48px' : _d, _e = _a.height, height = _e === void 0 ? '48px' : _e;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("g", null,
                React.createElement("path", { fill: main, d: "M42 5a1 1 0 011 1v13a1 1 0 01-1 1H6a1 1 0 01-1-1V6a1 1 0 011-1h36zM21.505 18h-2.01a.494.494 0 00-.495.5c0 .268.222.5.495.5h2.01c.28 0 .495-.224.495-.5l-.008-.088a.503.503 0 00-.487-.412zm8.004 0h-5.018a.5.5 0 000 1h5.018a.5.5 0 00.491-.5l-.008-.088A.5.5 0 0029.51 18z" }),
                React.createElement("rect", { width: "22", height: "11", x: "20", y: "29", fill: main, rx: "1" }),
                React.createElement("rect", { width: "13", height: "10", x: "6", y: "23", fill: main, rx: "1" }),
                React.createElement("rect", { width: "22", height: "5", x: "20", y: "23", fill: main, rx: "1" }),
                React.createElement("rect", { width: "7", height: "7", x: "9", y: "14", fill: highlight, rx: "1" }),
                React.createElement("rect", { width: "13", height: "9", x: "6", y: "34", fill: main, rx: "1" })))));
};

var FacebookTitle = function (_a) {
    var _b = _a.main, main = _b === void 0 ? '#424242' : _b, _c = _a.highlight, highlight = _c === void 0 ? '#565656' : _c, _d = _a.width, width = _d === void 0 ? '48px' : _d, _e = _a.height, height = _e === void 0 ? '48px' : _e;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("g", { transform: "translate(5 5)" },
                React.createElement("path", { fill: highlight, d: "M37 0a1 1 0 011 1v13a1 1 0 01-1 1H1a1 1 0 01-1-1V1a1 1 0 011-1h36zM16.505 13h-2.01a.494.494 0 00-.495.5c0 .268.222.5.495.5h2.01c.28 0 .495-.224.495-.5l-.008-.088a.503.503 0 00-.487-.412zm8.004 0h-5.018a.5.5 0 000 1h5.018a.5.5 0 00.491-.5l-.008-.088A.5.5 0 0024.51 13z" }),
                React.createElement("rect", { width: "22", height: "11", x: "15", y: "24", fill: main, rx: "1" }),
                React.createElement("rect", { width: "13", height: "10", x: "1", y: "18", fill: main, rx: "1" }),
                React.createElement("rect", { width: "22", height: "5", x: "15", y: "18", fill: main, rx: "1" }),
                React.createElement("rect", { width: "7", height: "7", x: "4", y: "9", fill: main, rx: "1" }),
                React.createElement("rect", { width: "13", height: "9", x: "1", y: "29", fill: main, rx: "1" })))));
};

var InstagramLandscape = function (_a) {
    var _b = _a.main, main = _b === void 0 ? '#424242' : _b, _c = _a.highlight, highlight = _c === void 0 ? '#565656' : _c, _d = _a.width, width = _d === void 0 ? '48px' : _d, _e = _a.height, height = _e === void 0 ? '48px' : _e;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("rect", { width: "26", height: "7", x: "7", y: "18", fill: main, rx: "1" }),
            React.createElement("rect", { width: "9", height: "7", x: "34", y: "11", fill: main, rx: "1" }),
            React.createElement("rect", { width: "9", height: "8", x: "34", y: "19", fill: main, rx: "1" }),
            React.createElement("rect", { width: "3", height: "3", x: "40", y: "6", fill: main, rx: "1" }),
            React.createElement("rect", { width: "26", height: "21", x: "7", y: "27", fill: main, rx: "1" }),
            React.createElement("rect", { width: "26", height: "16", x: "7", y: "5", fill: highlight, rx: "1" }))));
};

var InstagramPortrait = function (_a) {
    var _b = _a.main, main = _b === void 0 ? '#424242' : _b, _c = _a.highlight, highlight = _c === void 0 ? '#565656' : _c, _d = _a.width, width = _d === void 0 ? '48px' : _d, _e = _a.height, height = _e === void 0 ? '48px' : _e;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("rect", { width: "26", height: "7", x: "7", y: "34", fill: main, rx: "1" }),
            React.createElement("rect", { width: "26", height: "32", x: "7", y: "5", fill: highlight, rx: "1" }),
            React.createElement("rect", { width: "9", height: "7", x: "34", y: "11", fill: main, rx: "1" }),
            React.createElement("rect", { width: "9", height: "8", x: "34", y: "19", fill: main, rx: "1" }),
            React.createElement("rect", { width: "3", height: "3", x: "40", y: "6", fill: main, rx: "1" }),
            React.createElement("rect", { width: "26", height: "5", x: "7", y: "43", fill: main, rx: "1" }))));
};

var InstagramSquare = function (_a) {
    var _b = _a.main, main = _b === void 0 ? '#424242' : _b, _c = _a.highlight, highlight = _c === void 0 ? '#565656' : _c, _d = _a.width, width = _d === void 0 ? '48px' : _d, _e = _a.height, height = _e === void 0 ? '48px' : _e;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("rect", { width: "26", height: "7", x: "7", y: "28", fill: main, rx: "1" }),
            React.createElement("rect", { width: "26", height: "26", x: "7", y: "5", fill: highlight, rx: "1" }),
            React.createElement("rect", { width: "9", height: "7", x: "34", y: "11", fill: main, rx: "1" }),
            React.createElement("rect", { width: "9", height: "8", x: "34", y: "19", fill: main, rx: "1" }),
            React.createElement("rect", { width: "3", height: "3", x: "40", y: "6", fill: main, rx: "1" }),
            React.createElement("rect", { width: "26", height: "11", x: "7", y: "37", fill: main, rx: "1" }))));
};

var InstagramStory = function (_a) {
    var _b = _a.main, main = _b === void 0 ? '#424242' : _b, _c = _a.highlight, highlight = _c === void 0 ? '#565656' : _c, _d = _a.width, width = _d === void 0 ? '48px' : _d, _e = _a.height, height = _e === void 0 ? '48px' : _e;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("rect", { width: "20", height: "34", x: "14", y: "10", fill: highlight, rx: "1.5" }),
            React.createElement("rect", { width: "3", height: "3", x: "14", y: "5", fill: main, rx: "1" }))));
};

var TwitterPost = function (_a) {
    var _b = _a.main, main = _b === void 0 ? '#424242' : _b, _c = _a.highlight, highlight = _c === void 0 ? '#565656' : _c, _d = _a.shadow, shadow = _d === void 0 ? '#333333' : _d, _e = _a.width, width = _e === void 0 ? '48px' : _e, _f = _a.height, height = _f === void 0 ? '48px' : _f;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 48 48" },
        React.createElement("defs", null,
            React.createElement("filter", { id: "twitter-post-icon", width: "166.7%", height: "166.7%", x: "-33.3%", y: "-33.3%", filterUnits: "objectBoundingBox" },
                React.createElement("feGaussianBlur", { in: "SourceGraphic", stdDeviation: "1" }))),
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("rect", { width: "38", height: "15", x: "5", y: "5", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "11", height: "1", x: "5", y: "24", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "11", height: "1", x: "5", y: "26", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "11", height: "1", x: "5", y: "28", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "26", height: "13", x: "17", y: "24", fill: highlight, rx: "0.5" }),
            React.createElement("rect", { width: "26", height: "3", x: "17", y: "38", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "26", height: "3", x: "17", y: "42", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "9", height: "9", x: "8", y: "13", fill: shadow, filter: "url(#twitter-post-icon)", rx: "1" }),
            React.createElement("rect", { width: "7", height: "7", x: "9", y: "14", fill: main, rx: "1" }))));
};

var TwitterProfile = function (_a) {
    var _b = _a.main, main = _b === void 0 ? '#424242' : _b, _c = _a.highlight, highlight = _c === void 0 ? '#565656' : _c, _d = _a.width, width = _d === void 0 ? '48px' : _d, _e = _a.height, height = _e === void 0 ? '48px' : _e;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("rect", { width: "38", height: "15", x: "5", y: "5", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "11", height: "1", x: "5", y: "24", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "11", height: "1", x: "5", y: "26", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "11", height: "1", x: "5", y: "28", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "26", height: "13", x: "17", y: "24", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "26", height: "3", x: "17", y: "38", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "26", height: "3", x: "17", y: "42", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "7", height: "7", x: "9", y: "14", fill: highlight, rx: "1" }))));
};

var TwitterTitle = function (_a) {
    var _b = _a.main, main = _b === void 0 ? '#424242' : _b, _c = _a.highlight, highlight = _c === void 0 ? '#565656' : _c, _d = _a.width, width = _d === void 0 ? '48px' : _d, _e = _a.height, height = _e === void 0 ? '48px' : _e;
    return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: width, height: height, viewBox: "0 0 48 48" },
        React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
            React.createElement("rect", { width: "38", height: "15", x: "5", y: "5", fill: highlight, rx: "0.5" }),
            React.createElement("rect", { width: "11", height: "1", x: "5", y: "24", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "11", height: "1", x: "5", y: "26", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "11", height: "1", x: "5", y: "28", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "26", height: "13", x: "17", y: "24", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "26", height: "3", x: "17", y: "38", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "26", height: "3", x: "17", y: "42", fill: main, rx: "0.5" }),
            React.createElement("rect", { width: "7", height: "7", x: "9", y: "14", fill: main, rx: "1" }))));
};

var Brightness = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "brightness-icon", d: "M22.185 33.836c.594.109 1.2.164 1.815.164v2c-.735 0-1.462-.066-2.175-.197zm5.58-.568l.753 1.852c-.675.275-1.375.487-2.093.635l-.402-1.96c.597-.122 1.18-.299 1.741-.527zm-9.446-1.037c.5.346 1.03.646 1.586.895l-.82 1.824c-.666-.3-1.303-.66-1.903-1.074zm12.884-1.295l1.44 1.388a12.06 12.06 0 01-1.65 1.429l-1.167-1.625a10.06 10.06 0 001.377-1.192zm-15.758-1.754c.316.52.679 1.01 1.083 1.464l-1.493 1.33a12.038 12.038 0 01-1.3-1.756zm17.97-1.802l1.882.676a11.948 11.948 0 01-.925 1.982l-1.727-1.008a9.948 9.948 0 00.77-1.65zM24 18c.091 0 .182.002.273.006L24 18a6.071 6.071 0 01.668.037l.192.024a5.974 5.974 0 011.847.585l.01.005a5.992 5.992 0 011.154.768A5.99 5.99 0 0130 24c0 3.309-2.691 6-6 6a5.985 5.985 0 01-4.404-1.929l.163.17a6.052 6.052 0 01-1.353-2.07A5.951 5.951 0 0118 24c0-3.309 2.691-6 6-6zm2.827 3.173l-5.654 5.654A3.988 3.988 0 0024 28c2.206 0 4-1.794 4-4a3.988 3.988 0 00-1.173-2.827zM14.08 25.268c.076.606.208 1.2.392 1.777l-1.905.608a11.936 11.936 0 01-.472-2.134zm21.885-2.192a12.16 12.16 0 01-.032 2.198l-1.989-.21a10.193 10.193 0 00.027-1.836zM12.522 20.49l1.912.584a9.943 9.943 0 00-.37 1.783l-1.987-.226c.083-.73.232-1.445.445-2.14zm22.059-2.155c.345.643.63 1.316.853 2.013l-1.905.608a9.934 9.934 0 00-.71-1.676zm-19.587-2.266l1.5 1.323c-.402.456-.762.948-1.075 1.47l-1.715-1.03c.376-.625.808-1.215 1.29-1.763zm16.272-1.62c.58.442 1.12.936 1.61 1.476l-1.479 1.346c-.41-.45-.859-.862-1.343-1.23zm-12.241-1.372l.83 1.82a9.986 9.986 0 00-1.58.903l-1.147-1.638a11.986 11.986 0 011.897-1.085zm7.7-.766c.714.166 1.408.396 2.076.688L28 14.832a9.916 9.916 0 00-1.727-.573zm-2.857-.31l.021 2c-.613.006-1.22.068-1.812.184l-.383-1.964a12.046 12.046 0 012.174-.22z" })),
    React.createElement("g", { fill: "currentColor", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("mask", null,
            React.createElement("use", { xlinkHref: "#brightness-icon" })),
        React.createElement("use", { fillOpacity: "0.9", transform: "rotate(-45 24.039 24)", xlinkHref: "#brightness-icon" })))); };

var Contrast = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "contrast-icon", d: "M24 34V14c5.51 0 10 4.49 10 10s-4.49 10-10 10m0-22c-6.62 0-12 5.38-12 12s5.38 12 12 12 12-5.38 12-12-5.38-12-12-12" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#contrast-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#contrast-icon" })))); };

var Saturation = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "saturation-icon", d: "M17 31c1.334 1.099 2 2.177 2 3.234 0 .797-.454 1.39-1.211 1.655-.165.057-.428.094-.789.111l-.172-.01a2.54 2.54 0 01-.617-.101C15.454 35.624 15 35.03 15 34.234c0-1.057.666-2.135 2-3.234zm8.7-6l-4.24 4H17v-3.81l.2-.19h8.5zm-.7-7.59l4.24 4.25L26.76 24h-8.54L25 17.41zm7.778-3.532a3 3 0 01.135 4.1l-.135.143-1.414 1.414 1.414 1.415-1.414 1.414-7.07-7.071 1.413-1.414 1.414 1.413 1.414-1.414a3.001 3.001 0 014.243 0z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#saturation-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#saturation-icon" })))); };

var Clarity = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "clarity-icon", d: "M24 12L13 24.001 24 36l11-11.999L24 12zm-8.29 12.001H21l3-9.041 8.29 9.041-8.28 9.029L28 24.001h-7l2.99 9.029-8.28-9.029z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#clarity-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#clarity-icon" })))); };

var Shadows = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "shadows-icon", d: "M30.365 17.637l3.076 3.076c.382 1.09.566 2.234.56 3.387l-5.05-5.049-1.414 1.414 6.123 6.124a9.674 9.674 0 01-.792 2.036l-6.746-6.745-1.414 1.414 7.036 7.036c-.212.254-.43.502-.672.742-.24.24-.488.46-.742.672l-7.036-7.036-1.414 1.414 6.745 6.746a9.674 9.674 0 01-2.036.792l-6.124-6.123-1.414 1.414L24.101 34a10.012 10.012 0 01-3.388-.558l-3.076-3.076-.707.707c-3.896-3.896-3.896-10.246 0-14.142 3.896-3.896 10.246-3.896 14.142 0l-.707.707zm-14.849-2.12c-4.688 4.687-4.688 12.281 0 16.97a12.036 12.036 0 004.108 2.693c.064.022.127.057.191.078 4.264 1.577 9.242.658 12.671-2.772 3.43-3.429 4.35-8.407 2.772-12.67-.02-.065-.056-.128-.078-.192a12.036 12.036 0 00-2.694-4.108c-4.688-4.688-12.282-4.688-16.97 0z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#shadows-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#shadows-icon" })))); };

var Highlights = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "highlights-icon", d: "M31.07 31.07A9.932 9.932 0 0124 34c-2.67 0-5.18-1.04-7.07-2.93l14.14-14.14c3.9 3.9 3.9 10.24 0 14.14m1.42-15.56A11.995 11.995 0 0024 12c-3.07 0-6.14 1.17-8.49 3.51-4.68 4.69-4.68 12.29 0 16.98C17.86 34.83 20.93 36 24 36c3.07 0 6.14-1.17 8.49-3.51 4.68-4.69 4.68-12.29 0-16.98" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#highlights-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#highlights-icon" })))); };

var Exposure = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "exposure-icon", d: "M24 34V14c5.51 0 10 4.49 10 10s-4.49 10-10 10m0-22c6.62 0 12 5.38 12 12s-5.38 12-12 12-12-5.38-12-12 5.38-12 12-12zm-3.536 8.464l-2.121 2.122-2.121-2.122-1.414 1.415L16.929 24l-2.121 2.121 1.414 1.415 2.121-2.122 2.121 2.122 1.415-1.415L19.757 24l2.122-2.121-1.415-1.415zm5.304 4.597l4.242-4.243 1.415 1.414-4.243 4.243-1.414-1.414z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#exposure-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", transform: "rotate(45 24 24)", xlinkHref: "#exposure-icon" })))); };

var Gamma = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "gamma-icon", d: "M22.185 33.836c.594.109 1.2.164 1.815.164v2c-.735 0-1.462-.066-2.175-.197zm5.58-.568l.753 1.852c-.675.275-1.375.487-2.093.635l-.402-1.96c.597-.122 1.18-.299 1.741-.527zm-9.446-1.037c.5.346 1.03.646 1.586.895l-.82 1.824c-.666-.3-1.303-.66-1.903-1.074zm12.884-1.295l1.44 1.388a12.06 12.06 0 01-1.65 1.429l-1.167-1.625a10.06 10.06 0 001.377-1.192zm-15.758-1.754c.316.52.679 1.01 1.083 1.464l-1.493 1.33a12.038 12.038 0 01-1.3-1.756zm17.97-1.802l1.882.676a11.948 11.948 0 01-.925 1.982l-1.727-1.008a9.948 9.948 0 00.77-1.65zM24 18c.091 0 .182.002.273.006L24 18a6.071 6.071 0 01.668.037l.192.024a5.974 5.974 0 011.847.585l.01.005a5.992 5.992 0 011.154.768A5.99 5.99 0 0130 24c0 3.309-2.691 6-6 6a5.985 5.985 0 01-4.404-1.929l.163.17a6.052 6.052 0 01-1.353-2.07A5.951 5.951 0 0118 24c0-3.309 2.691-6 6-6zm2.827 3.173l-5.654 5.654A3.988 3.988 0 0024 28c2.206 0 4-1.794 4-4a3.988 3.988 0 00-1.173-2.827zM14.08 25.268c.076.606.208 1.2.392 1.777l-1.905.608a11.936 11.936 0 01-.472-2.134zm21.885-2.192a12.16 12.16 0 01-.032 2.198l-1.989-.21a10.193 10.193 0 00.027-1.836zM12.522 20.49l1.912.584a9.943 9.943 0 00-.37 1.783l-1.987-.226c.083-.73.232-1.445.445-2.14zm22.059-2.155c.345.643.63 1.316.853 2.013l-1.905.608a9.934 9.934 0 00-.71-1.676zm-19.587-2.266l1.5 1.323c-.402.456-.762.948-1.075 1.47l-1.715-1.03c.376-.625.808-1.215 1.29-1.763zm16.272-1.62c.58.442 1.12.936 1.61 1.476l-1.479 1.346c-.41-.45-.859-.862-1.343-1.23zm-12.241-1.372l.83 1.82a9.986 9.986 0 00-1.58.903l-1.147-1.638a11.986 11.986 0 011.897-1.085zm7.7-.766c.714.166 1.408.396 2.076.688L28 14.832a9.916 9.916 0 00-1.727-.573zm-2.857-.31l.021 2c-.613.006-1.22.068-1.812.184l-.383-1.964a12.046 12.046 0 012.174-.22z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "#fff" },
            React.createElement("use", { xlinkHref: "#gamma-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#gamma-icon" })))); };

var Blacks = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "blacks-icon", d: "M24 12c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12m0 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10m4 12c0 2.788-2.326 3.879-7 3V18.5c4.148-.459 6.516.226 6.516 2.623 0 1.207-.492 1.998-1.512 2.474C27.504 23.999 28 24.619 28 26zm-5-6v3c2.244.068 2.775-.719 2.775-1.536 0-1.22-.531-1.812-2.775-1.464zm0 7.5c2.19.193 3.038-.04 3.038-1.484 0-1.37-1.096-1.695-3.038-1.516v3z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#blacks-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#blacks-icon" })))); };

var Whites = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "whites-icon", d: "M24 12c6.627 0 12 5.373 12 12s-5.373 12-12 12-12-5.373-12-12 5.373-12 12-12zm-2 6.46h-2c.221 4.539.762 9.051 1 11.04h1.5l1.5-5.52 1.5 5.52H27c.238-1.989.779-6.501 1-11.04h-2c-.051 1.071-.432 7.446-.5 7.973-.459-1.717-.541-3.111-1-4.811h-1c-.442 1.7-.541 2.975-1 4.811-.051-.527-.466-6.902-.5-7.973z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#whites-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#whites-icon" })))); };

var Temperature = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "temperature-icon", d: "M24 12a4 4 0 014 4v7.255a7 7 0 11-8 0V16a4 4 0 014-4zm0 2a2 2 0 00-2 2v8.298l-.856.597a5 5 0 105.712 0L26 24.298V16a2 2 0 00-2-2zm1 6v5.126A4.002 4.002 0 0124 33a4 4 0 01-1-7.874V20h2z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#temperature-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#temperature-icon" })))); };

var Sharpness = function () { return (React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "48", height: "48", viewBox: "0 0 48 48" },
    React.createElement("defs", null,
        React.createElement("path", { id: "sharpness-icon", d: "M24 12l11 24H13l11-24zm0 4.8V34h7.883L24 16.8z" })),
    React.createElement("g", { fill: "none", fillRule: "evenodd", stroke: "none", strokeWidth: "1" },
        React.createElement("path", { d: "M0 0H48V48H0z" }),
        React.createElement("mask", { fill: "currentColor" },
            React.createElement("use", { xlinkHref: "#sharpness-icon" })),
        React.createElement("use", { fill: "currentColor", fillOpacity: "0.9", xlinkHref: "#sharpness-icon" })))); };

var _a$2, _b, _c;
var ToolbarIcons = {
    adjustment: Adjustments,
    filter: Filter,
    library: Library,
    overlay: Overlay,
    focus: Focus,
    sticker: Sticker,
    text: text,
    textdesign: TextDesign,
    frame: Frame,
    transform: Icon,
    brush: Icon$1,
};
var AlignIcons = {
    left: Icon$2,
    right: Icon$3,
    center: Icon$4,
};
var ToolControlBarIcons = {
    addText: AddText,
    openWebcam: OpenWebcam,
    reset: Reset,
    shuffle: Icon$5,
    uploadImage: Export,
};
var EditorIcons = {
    undo: Undo,
    redo: Redo,
    close: Close,
    export: Icon$6,
};
var TransformIcons = {
    categories: (_a$2 = {},
        _a$2[TransformIdentifier.CommonCategory] = CommonCategory,
        _a$2[TransformIdentifier.FacebookCategory] = FacebookCategory,
        _a$2[TransformIdentifier.TwitterCategory] = TwitterCategory,
        _a$2[TransformIdentifier.InstagramCategory] = InstagramCategory,
        _a$2),
    crops: (_b = {},
        _b[TransformIdentifier.Custom] = Custom,
        _b[TransformIdentifier.Square] = Square,
        _b[TransformIdentifier.ThreeByFour] = ThreeByFour,
        _b[TransformIdentifier.FourByThree] = FourByThree,
        _b[TransformIdentifier.NineBySixteen] = NineBySixteen,
        _b[TransformIdentifier.SixteenByNine] = SixteenByNine,
        _b[TransformIdentifier.FacebookPost] = FacebookPost,
        _b[TransformIdentifier.FacebookProfile] = FacebookProfile,
        _b[TransformIdentifier.FacebookTitle] = FacebookTitle,
        _b[TransformIdentifier.InstagramLandscape] = InstagramLandscape,
        _b[TransformIdentifier.InstagramPortrait] = InstagramPortrait,
        _b[TransformIdentifier.InstagramSquare] = InstagramSquare,
        _b[TransformIdentifier.InstagramStory] = InstagramStory,
        _b[TransformIdentifier.TwitterPost] = TwitterPost,
        _b[TransformIdentifier.TwitterProfile] = TwitterProfile,
        _b[TransformIdentifier.TwitterTitle] = TwitterTitle,
        _b),
    dots: Dots,
    duplicate: Duplicate,
    edit: Edit,
    bringToFront: BringToFront,
    delete: Delete,
    flipHorizontal: FlipHorizontal,
    flipVertical: FlipVertical,
    rotate: Rotate,
};
var AdjustmentIcons = (_c = {},
    _c[AdjustmentIdentifier.BRIGHTNESS] = Brightness,
    _c[AdjustmentIdentifier.CONTRAST] = Contrast,
    _c[AdjustmentIdentifier.SATURATION] = Saturation,
    _c[AdjustmentIdentifier.CLARITY] = Clarity,
    _c[AdjustmentIdentifier.SHADOWS] = Shadows,
    _c[AdjustmentIdentifier.HIGHLIGHTS] = Highlights,
    _c[AdjustmentIdentifier.EXPOSURE] = Exposure,
    _c[AdjustmentIdentifier.GAMMA] = Gamma,
    _c[AdjustmentIdentifier.BLACKS] = Blacks,
    _c[AdjustmentIdentifier.WHITES] = Whites,
    _c[AdjustmentIdentifier.TEMPERATURE] = Temperature,
    _c[AdjustmentIdentifier.SHARPNESS] = Sharpness,
    _c);

var Slider$1 = styled.div(templateObject_1$W || (templateObject_1$W = __makeTemplateObject(["\n  overflow: hidden;\n  display: inline-block;\n  position: relative;\n  transform: unset !important;\n  vertical-align: bottom;\n"], ["\n  overflow: hidden;\n  display: inline-block;\n  position: relative;\n  transform: unset !important;\n  vertical-align: bottom;\n"])));
var Div$1 = styled.div(templateObject_2$t || (templateObject_2$t = __makeTemplateObject(["\n  position: relative;\n  cursor: pointer;\n  display: flex;\n  align-self: center;\n"], ["\n  position: relative;\n  cursor: pointer;\n  display: flex;\n  align-self: center;\n"])));
var Value = styled.div(templateObject_3$h || (templateObject_3$h = __makeTemplateObject(["\n  font-size: 15px;\n  display: inline-block;\n  width: 33px;\n  text-align: right;\n  color: ", ";\n  z-index: 1;\n  margin: 2px;\n"], ["\n  font-size: 15px;\n  display: inline-block;\n  width: 33px;\n  text-align: right;\n  color: ", ";\n  z-index: 1;\n  margin: 2px;\n"])), function (props) { return props.theme.foreground; });
var Wrapper$3 = styled.div(templateObject_4$a || (templateObject_4$a = __makeTemplateObject(["\n  transform: translate(0, 0) !important;\n"], ["\n  transform: translate(0, 0) !important;\n"])));
var RotateSlider = /** @class */ (function (_super) {
    __extends(RotateSlider, _super);
    function RotateSlider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.SLIDER_WIDTH = 213;
        _this.MAX_ROTATION = 45;
        _this.DEGREES_PER_PIXEL = (_this.MAX_ROTATION * 2) / _this.SLIDER_WIDTH;
        _this.drag = function (_, _a) {
            var x = _a.x;
            var angle = _this.transformTool.defaultAngle + x * _this.DEGREES_PER_PIXEL;
            var degree = Math.min(_this.MAX_ROTATION, Math.max(angle, _this.MAX_ROTATION * -1));
            _this.transformTool.setRotation(parseInt("" + degree, 10));
        };
        _this.stop = function () {
            _this.transformTool.setDefaultAngle(_this.transformTool.rotationInDegrees);
            _this.transformTool.addSnapshot();
        };
        return _this;
    }
    Object.defineProperty(RotateSlider.prototype, "transformTool", {
        get: function () {
            return this.props.transformTool;
        },
        enumerable: true,
        configurable: true
    });
    RotateSlider.prototype.render = function () {
        var currentRotation = this.transformTool.rotationInDegrees - this.transformTool.defaultAngle;
        return (React.createElement(Div$1, null,
            React.createElement(Components.Draggable, { axis: "x", position: { x: 0, y: 0 }, onStart: this.drag, onDrag: this.drag, onStop: this.stop, updateOnPosition: true },
                React.createElement(Wrapper$3, null,
                    React.createElement(Slider$1, null,
                        React.createElement(TransformIcons.dots, { width: 90, height: 15, x: currentRotation * 2 })),
                    React.createElement(Value, null,
                        this.props.transformTool.rotationInDegrees,
                        "\u00B0"),
                    React.createElement(Slider$1, null,
                        React.createElement(TransformIcons.dots, { width: 90, height: 15, x: currentRotation * 2 }))))));
    };
    return RotateSlider;
}(React.Component));
var RotateSlider$1 = inject('transformTool')(observer(RotateSlider));
var templateObject_1$W, templateObject_2$t, templateObject_3$h, templateObject_4$a;

var Button = styled(TextSecondaryButton)(templateObject_1$X || (templateObject_1$X = __makeTemplateObject(["\n  align-self: center;\n  color: ", ";\n"], ["\n  align-self: center;\n  color: ", ";\n"])), function (props) { return props.theme.foreground; });
var ButtonGroup$2 = styled(CanvasUIComponents.Bar.ButtonGroup)(templateObject_2$u || (templateObject_2$u = __makeTemplateObject(["\n  transform: scale(0.9);\n\n  @media all and (min-width: 0) and (max-width: 599px) {\n    transform: scale(0.7);\n  }\n"], ["\n  transform: scale(0.9);\n\n  @media all and (min-width: 0) and (max-width: 599px) {\n    transform: scale(0.7);\n  }\n"])));
var FlipRotateControls = function (_a) {
    var transformTool = _a.transformTool, config = _a.config, custom = _a.custom;
    var actionLocale = transformTool.locale.transformActions;
    var createButton = function (_a) {
        var customButtonKey = _a.customButtonKey, onClick = _a.onClick, label = _a.label, icon = _a.icon;
        var customButton = custom.getButton(customButtonKey)({
            key: label,
            label: label,
            onClick: onClick,
            icon: icon,
        });
        return customButton;
    };
    var flipHorizontally = createButton({
        label: actionLocale.buttonFlipHorizontal,
        icon: React.createElement(FlipHorizontal$1, null),
        onClick: function () {
            transformTool.flipHorizontally();
        },
        customButtonKey: 'transformActionFlipHorizontal',
    }) || (React.createElement(Button, { ariaLabel: actionLocale.buttonFlipHorizontal, onClick: function () {
            transformTool.flipHorizontally();
        } },
        React.createElement(FlipHorizontal$1, null)));
    var flipVertically = createButton({
        label: actionLocale.buttonFlipVertical,
        icon: React.createElement(FlipVertical$1, null),
        onClick: function () {
            transformTool.flipVertically();
        },
        customButtonKey: 'transformActionFlipVertical',
    }) || (React.createElement(Button, { ariaLabel: actionLocale.buttonFlipVertical, onClick: function () {
            transformTool.flipVertically();
        } },
        React.createElement(FlipVertical$1, null)));
    var rotateClockwise = createButton({
        label: actionLocale.buttonRotateClockwise,
        icon: React.createElement(FlippedRotate, null),
        onClick: transformTool.rotateClockwise,
        customButtonKey: 'transformActionRotateClockwise',
    }) || (React.createElement(Button, { ariaLabel: actionLocale.buttonRotateClockwise, onClick: transformTool.rotateClockwise },
        React.createElement(FlippedRotate, null)));
    var rotateAntiClockwise = createButton({
        label: actionLocale.buttonRotateAntiClockwise,
        icon: React.createElement(Rotate$1, null),
        onClick: transformTool.rotateAntiClockwise,
        customButtonKey: 'transformActionRotateAntiClockwise',
    }) || (React.createElement(Button, { ariaLabel: actionLocale.buttonRotateAntiClockwise, onClick: transformTool.rotateAntiClockwise },
        React.createElement(Rotate$1, null)));
    /**
     * This piece of extra rotation style is needed because,
     * in advanced layout - dark mode, background of canvasbar is a gradient,
     * which for the top part is top-bottom but for flip rotate controls should work bottom-top
     */
    var style = config.isLayoutAdvanced ? { transform: 'rotate(180deg)' } : {};
    return (React.createElement(ButtonGroup$2, { style: style },
        (transformTool.config.enableFlip && flipHorizontally) || null,
        (transformTool.config.enableFlip && flipVertically) || null,
        (transformTool.config.enableRotation && React.createElement(RotateSlider$1, null)) || null,
        (transformTool.config.enableRotation && rotateAntiClockwise) || null,
        (transformTool.config.enableRotation && rotateClockwise) || null));
};
var FlipRotateControls$1 = inject('transformTool', 'config', 'custom')(observer(FlipRotateControls));
var FlippedRotate = styled(TransformIcons.rotate)(templateObject_3$i || (templateObject_3$i = __makeTemplateObject(["\n  height: 16px;\n  width: 16px;\n  transform: scaleX(-1);\n"], ["\n  height: 16px;\n  width: 16px;\n  transform: scaleX(-1);\n"])));
var Rotate$1 = styled(TransformIcons.rotate)(templateObject_4$b || (templateObject_4$b = __makeTemplateObject(["\n  height: 16px;\n  width: 16px;\n"], ["\n  height: 16px;\n  width: 16px;\n"])));
var FlipHorizontal$1 = styled(TransformIcons.flipHorizontal)(templateObject_5$8 || (templateObject_5$8 = __makeTemplateObject(["\n  height: 16px;\n  width: 16px;\n"], ["\n  height: 16px;\n  width: 16px;\n"])));
var FlipVertical$1 = styled(TransformIcons.flipVertical)(templateObject_6$7 || (templateObject_6$7 = __makeTemplateObject(["\n  height: 16px;\n  width: 16px;\n"], ["\n  height: 16px;\n  width: 16px;\n"])));
var templateObject_1$X, templateObject_2$u, templateObject_3$i, templateObject_4$b, templateObject_5$8, templateObject_6$7;

var GridLine$1 = CanvasUIComponents.Crop.GridLine;
var CropMask$1 = CanvasUIComponents.Crop.Mask;
var Draggable$1 = Components.Draggable;
var borderWidth = 3;
var LeftTop = styled(Control)(templateObject_1$Y || (templateObject_1$Y = __makeTemplateObject(["\n  left: 3px;\n  top: 3px;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    left: 4px;\n    top: 4px;\n  }\n"], ["\n  left: 3px;\n  top: 3px;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    left: 4px;\n    top: 4px;\n  }\n"])));
var RightTop = styled(Control)(templateObject_2$v || (templateObject_2$v = __makeTemplateObject(["\n  left: -27px;\n  top: 3px;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    left: -28px;\n    top: 4px;\n  }\n"], ["\n  left: -27px;\n  top: 3px;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    left: -28px;\n    top: 4px;\n  }\n"])));
var RightBottom = styled(Control)(templateObject_3$j || (templateObject_3$j = __makeTemplateObject(["\n  left: -27px;\n  top: -27px;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    left: -28px;\n    top: -28px;\n  }\n"], ["\n  left: -27px;\n  top: -27px;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    left: -28px;\n    top: -28px;\n  }\n"])));
var LeftBottom = styled(Control)(templateObject_4$c || (templateObject_4$c = __makeTemplateObject(["\n  top: -27px;\n  left: 3px;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    top: -28px;\n    left: 4px;\n  }\n"], ["\n  top: -27px;\n  left: 3px;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    top: -28px;\n    left: 4px;\n  }\n"])));
var CropMaskControl = function (_a) {
    var transformTool = _a.transformTool;
    var _b = transformTool, leftTop = _b.leftTop, leftBottom = _b.leftBottom, rightTop = _b.rightTop, rightBottom = _b.rightBottom;
    var _c = transformTool.cropMaskSize, cropMaskHeight = _c.height, cropMaskWidth = _c.width;
    var _d = transformTool, defaultCropMaskSize = _d.defaultCropMaskSize, defaultCropMaskPosition = _d.defaultCropMaskPosition;
    var cropMaskWrapper = __assign({}, defaultCropMaskSize, { left: defaultCropMaskPosition.x, top: defaultCropMaskPosition.y });
    var cropMaskStyle = { height: cropMaskHeight, width: cropMaskWidth };
    var transition = transformTool.isDragMode ? { transition: 'unset' } : {};
    var onLeftTopStart = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.setDragMode(true);
        transformTool.clickableCanvas(false);
        transformTool.onLeftTop({ x: x, y: y });
    };
    var onLeftTop = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.onLeftTop({ x: x, y: y });
    };
    var onLeftTopStop = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.setDragMode(false);
        transformTool.onLeftTop({ x: x, y: y });
        transformTool.clickableCanvas(true);
        transformTool.addSnapshot();
    };
    var onLeftBottomStart = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.setDragMode(true);
        transformTool.clickableCanvas(false);
        transformTool.onLeftBottom({ x: x, y: y });
    };
    var onLeftBottom = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.onLeftBottom({ x: x, y: y });
    };
    var onLeftBottomStop = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.setDragMode(false);
        transformTool.onLeftBottom({ x: x, y: y });
        transformTool.clickableCanvas(true);
        transformTool.addSnapshot();
    };
    var onRightTopStart = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.setDragMode(true);
        transformTool.clickableCanvas(false);
        transformTool.onRightTop({ x: x, y: y });
    };
    var onRightTop = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.onRightTop({ x: x, y: y });
    };
    var onRightTopStop = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.setDragMode(false);
        transformTool.onRightTop({ x: x, y: y });
        transformTool.clickableCanvas(true);
        transformTool.addSnapshot();
    };
    var onRightBottomStart = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.setDragMode(true);
        transformTool.clickableCanvas(false);
        transformTool.onRightBottom({ x: x, y: y });
    };
    var onRightBottom = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.onRightBottom({ x: x, y: y });
    };
    var onRightBottomStop = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.setDragMode(false);
        transformTool.onRightBottom({ x: x, y: y });
        transformTool.clickableCanvas(true);
        transformTool.addSnapshot();
    };
    var onCropMaskDragStart = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.setDragMode(true);
        transformTool.clickableCanvas(false);
        transformTool.changePosition({ x: x, y: y });
    };
    var onCropMaskDrag = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.changePosition({ x: x, y: y });
    };
    var onCropMaskDragStop = function (_, _a) {
        var x = _a.x, y = _a.y;
        transformTool.setDragMode(false);
        transformTool.changePosition({ x: x, y: y });
        transformTool.clickableCanvas(true);
        transformTool.addSnapshot();
    };
    return (React.createElement("div", { style: __assign({}, cropMaskWrapper, { position: 'absolute' }) },
        React.createElement(Draggable$1, { bounds: "parent", position: leftTop, onStart: onCropMaskDragStart, onDrag: onCropMaskDrag, onStop: onCropMaskDragStop },
            React.createElement(CropMask$1, { style: __assign({}, cropMaskStyle, transition) })),
        React.createElement(GridLine$1, { style: __assign({ left: leftTop.x + cropMaskWidth / 3, top: leftTop.y, height: cropMaskHeight, width: 1 }, transition) }),
        React.createElement(GridLine$1, { style: __assign({ left: leftTop.x + (cropMaskWidth / 3) * 2, top: leftTop.y, height: cropMaskHeight, width: 1 }, transition) }),
        React.createElement(GridLine$1, { style: __assign({ left: leftTop.x, top: leftTop.y + cropMaskHeight / 3, height: 1, width: cropMaskWidth }, transition) }),
        React.createElement(GridLine$1, { style: __assign({ left: leftTop.x, top: leftTop.y + (cropMaskHeight / 3) * 2, height: 1, width: cropMaskWidth }, transition) }),
        React.createElement(Draggable$1, { bounds: "parent", position: __assign({}, leftTop), onStart: onLeftTopStart, onDrag: onLeftTop, onStop: onLeftTopStop },
            React.createElement(LeftTop, { vertical: "top", horizontal: "left", borderWidth: borderWidth, style: transition })),
        React.createElement(Draggable$1, { bounds: "parent", position: leftBottom, onStart: onLeftBottomStart, onDrag: onLeftBottom, onStop: onLeftBottomStop },
            React.createElement(LeftBottom, { vertical: "bottom", horizontal: "left", borderWidth: borderWidth, style: transition })),
        React.createElement(Draggable$1, { bounds: "parent", position: rightTop, onStart: onRightTopStart, onDrag: onRightTop, onStop: onRightTopStop },
            React.createElement(RightTop, { vertical: "top", horizontal: "right", borderWidth: borderWidth, style: transition })),
        React.createElement(Draggable$1, { bounds: "parent", position: rightBottom, onStart: onRightBottomStart, onDrag: onRightBottom, onStop: onRightBottomStop },
            React.createElement(RightBottom, { vertical: "bottom", horizontal: "right", borderWidth: borderWidth, style: transition }))));
};
var CropMask$2 = inject('transformTool')(observer(CropMaskControl));
var templateObject_1$Y, templateObject_2$v, templateObject_3$j, templateObject_4$c;

var CanvasBar$1 = CanvasUIComponents.Bar.Index;
var Backdrop$1 = CanvasUIComponents.Crop.Backdrop;
var CanvasControls = function (_a) {
    var transformTool = _a.transformTool, canvas = _a.canvas, config = _a.config;
    var _b = transformTool, leftTop = _b.leftTop, leftBottom = _b.leftBottom, rightTop = _b.rightTop;
    var imageHeight = transformTool.cropMaskSize.height;
    var _c = canvas.canvasSize, height = _c.height, width = _c.width;
    var defaultPosition = transformTool.defaultCropMaskPosition;
    var transition = transformTool.isDragMode ? { transition: 'unset' } : {};
    return (React.createElement(CanvasUIComponents.Controls.Container, null,
        React.createElement(Backdrop$1, { style: __assign({ left: 0, top: 0, width: width, height: leftTop.y + defaultPosition.y }, transition) }),
        React.createElement(Backdrop$1, { style: __assign({ left: 0, top: leftTop.y + defaultPosition.y, width: defaultPosition.x + leftTop.x, height: imageHeight }, transition) }),
        React.createElement(Backdrop$1, { style: __assign({ left: rightTop.x + defaultPosition.x, top: rightTop.y + defaultPosition.y, width: width - rightTop.x - defaultPosition.x, height: imageHeight }, transition) }),
        React.createElement(Backdrop$1, { style: __assign({ left: 0, top: leftBottom.y + defaultPosition.y, width: width, height: height - leftBottom.y - defaultPosition.y + config.measurements.basicToolControlBar.controlsBarHeight }, transition) }),
        React.createElement(CropMask$2, null),
        config.isLayoutAdvanced ? (React.createElement(CanvasBar$1, { bottom: true },
            React.createElement(FlipRotateControls$1, null))) : null));
};
var TransformCanvasControls = inject('transformTool', 'canvas', 'config')(observer(CanvasControls));

var Container$4 = styled(CanvasUIComponents.Controls.Container)(templateObject_2$w || (templateObject_2$w = __makeTemplateObject(["\n  ", "\n  z-index: ", ";\n"], ["\n  ",
    "\n  z-index: ", ";\n"])), function (props) {
    return props.activeCursor
        ? css(templateObject_1$Z || (templateObject_1$Z = __makeTemplateObject(["\n          cursor: move;\n        "], ["\n          cursor: move;\n        "]))) : '';
}, function (props) { return props.theme.measurements.zIndex.canvas.crop.dragImage; });
var DragImage = /** @class */ (function (_super) {
    __extends(DragImage, _super);
    function DragImage(props) {
        var _this = _super.call(this, props) || this;
        _this.INITIAL_POSITION = { x: undefined, y: undefined };
        _this.state = __assign({}, _this.INITIAL_POSITION, { isDragging: false });
        _this.containerRef = null;
        _this.getCursorCoordinates = function (e) {
            var clientX = 0;
            var clientY = 0;
            if (e.type.indexOf('touch') !== -1) {
                var ev = e;
                if (!ev.touches.length) {
                    return _this.INITIAL_POSITION;
                }
                clientX = ev.touches[0].clientX;
                clientY = ev.touches[0].clientY;
            }
            else {
                var ev = e;
                clientX = ev.clientX;
                clientY = ev.clientY;
            }
            var rect = _this.containerRef.current.getBoundingClientRect();
            var x = clientX - rect.left;
            var y = clientY - rect.top;
            return { x: x, y: y };
        };
        _this.move = function (e) {
            if (_this.scale.canDrag) {
                var _a = _this.getCursorCoordinates(e), x = _a.x, y = _a.y;
                if (x !== undefined && y !== undefined) {
                    if (_this.state.isDragging) {
                        var offset = {
                            x: _this.state.x - x,
                            y: _this.state.y - y,
                        };
                        _this.scale.setOffset(offset);
                    }
                }
            }
        };
        _this.touchDrag = function (e) {
            if (_this.scale.canDrag) {
                var _a = _this.getCursorCoordinates(e), x = _a.x, y = _a.y;
                if (x !== undefined && y !== undefined) {
                    _this.setState({ x: x, y: y, isDragging: true });
                }
            }
        };
        _this.drag = function (e) {
            e.preventDefault();
            _this.touchDrag(e);
        };
        _this.stop = function () {
            if (_this.scale.canDrag) {
                _this.scale.savePosition();
                _this.setState(__assign({}, _this.INITIAL_POSITION, { isDragging: false }));
            }
        };
        _this.touchEnd = function (e) {
            e.preventDefault();
            e.stopPropagation();
            // touches will be empty for the onTouchEnd event, take last saved values instead
            var _a = _this.state, x = _a.x, y = _a.y;
            if (x && y) {
                _this.setState(__assign({}, _this.INITIAL_POSITION, { isDragging: false }));
            }
        };
        _this.containerRef = React.createRef();
        return _this;
    }
    DragImage.prototype.componentDidMount = function () {
        document.addEventListener('mouseup', this.stop, false);
        document.addEventListener('touchend', this.stop, { passive: true });
    };
    DragImage.prototype.componentWillUnmount = function () {
        document.removeEventListener('mouseup', this.stop, false);
        document.removeEventListener('touchend', this.stop, false);
    };
    Object.defineProperty(DragImage.prototype, "scale", {
        get: function () {
            return this.props.scale;
        },
        enumerable: true,
        configurable: true
    });
    DragImage.prototype.render = function () {
        return (React.createElement(Container$4, { ref: this.containerRef, onMouseMove: this.move, onTouchMove: this.move, onMouseDown: this.drag, onTouchStart: this.touchDrag, onMouseUp: this.stop, onTouchEnd: this.touchEnd, activeCursor: this.scale.canDrag }));
    };
    return DragImage;
}(React.Component));
var DragImage$1 = inject('scale')(observer(DragImage));
var templateObject_1$Z, templateObject_2$w;

var ArrowLeft = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAANJJREFUSA3tlEsKwjAURUv9Vq3gBlyjKxF/c0EQxIEgggjiwP/ILbgU6ykYuLMGeRlp4JJH+3JOEmij6D9C3UCWZTWSBOEDbpM7eZCOqQRgSm7EjZ6ZAGIOvzoycz8kfGAJb7Hbi+x8aA0/C3xkCW8CPgl8bA0/CnzyDTwuWPSS9wmyon5p9ygBNshBTjGlNpfkO9+LZBZCUge6E8mcuuRxCf4tAPOf21YkC+qyP8Gj8yPZiGQZQlIFuhaJ3VftDgm8QlbkSbruuekMOCapKfQ3YW/1Myhh/78bMQAAAABJRU5ErkJggg==";

var ArrowRight = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAPhJREFUSA3tlLkKwlAQRYOVnXZ+gEshIiJ+hAgiCBJc8Sf8XgsVFBVLt2g8UwhBMomZtLlwIMxy3uMVcZwsaV/A9/1iWoe6j3wFV+iqQ9YG0hJcQHKDntWl7iHtwPeQO999ddjaQNqGM0geMLC61D2kLTiBRA4ZqsPWBtImHEHyhJHVpe4hbcABJHKIqw5bG0jrsAeJB5MoVy6qqfQ86u9AL/gdKBs+uW0NdiCR248NmvAVZFUIyiOfJtyiVBFXYAuSF0yV0eRlZL/yWXKLsoG8DBuQyM3nymjyMrI8rEEi8kVyS8wGUhfkJ7eMGbW3kRfs29nmHy/wAUVpDIFPWLFFAAAAAElFTkSuQmCC";

/**
 * These values are coming from the image size ie 24x24
 */
var Left = styled.img(templateObject_1$_ || (templateObject_1$_ = __makeTemplateObject(["\n  position: absolute;\n  left: -24px;\n  top: calc(50% - 12px);\n  cursor: ew-resize;\n"], ["\n  position: absolute;\n  left: -24px;\n  top: calc(50% - 12px);\n  cursor: ew-resize;\n"])));
var Right = styled.img(templateObject_2$x || (templateObject_2$x = __makeTemplateObject(["\n  position: absolute;\n  right: -24px;\n  top: calc(50% - 12px);\n  cursor: ew-resize;\n"], ["\n  position: absolute;\n  right: -24px;\n  top: calc(50% - 12px);\n  cursor: ew-resize;\n"])));
var initialCursorPosition = new Vector2(0, 0);
var initialPadPosition = new Vector2(0, 0);
var Padding = function (_a) {
    var sprite = _a.sprite;
    var left = sprite.leftMidPadPosition;
    var right = sprite.rightMidPadPosition;
    var onPaddingDragStart = function (e, indicator) {
        sprite.setDragMode(true);
        sprite.clickableCanvas(false);
        var clientX = e.clientX, clientY = e.clientY;
        initialCursorPosition = new Vector2(clientX, clientY);
        initialPadPosition = new Vector2(indicator === 'left' ? left : right);
    };
    var onPaddingDragStop = function () {
        sprite.clickableCanvas(true);
        sprite.setDragMode(false);
        sprite.addSnapshot("edit" /* EDIT */, sprite.textDesignLocale.padding);
        initialCursorPosition = new Vector2(0, 0);
        initialPadPosition = new Vector2(0, 0);
    };
    var onPaddingDrag = function (_a) {
        var clientX = _a.clientX, clientY = _a.clientY;
        if (clientX !== undefined && clientY !== undefined) {
            var newPos = initialPadPosition.subtract(initialCursorPosition.subtract(new Vector2(clientX, clientY)));
            sprite.onPaddingDrag(newPos);
        }
    };
    return (React.createElement(React.Fragment, null,
        React.createElement(Components.Draggable, { onStart: function (e) { return onPaddingDragStart(e, 'left'); }, onDrag: onPaddingDrag, onStop: onPaddingDragStop },
            React.createElement(Left, { src: ArrowLeft })),
        React.createElement(Components.Draggable, { onStart: function (e) { return onPaddingDragStart(e, 'right'); }, onDrag: onPaddingDrag, onStop: onPaddingDragStop },
            React.createElement(Right, { src: ArrowRight }))));
};
var PaddingControls = inject('sprite')(observer(Padding));
var templateObject_1$_, templateObject_2$x;

var TextWidth = styled(CanvasUIComponents.Controls.Width)(templateObject_1$$ || (templateObject_1$$ = __makeTemplateObject(["\n  cursor: ew-resize;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    display: none;\n  }\n"], ["\n  cursor: ew-resize;\n  @media all and (min-width: 0) and (max-width: 599px) {\n    display: none;\n  }\n"])));
var Left$1 = styled(TextWidth)(templateObject_2$y || (templateObject_2$y = __makeTemplateObject(["\n  left: -3px;\n  top: calc(50% - ", "px);\n"], ["\n  left: -3px;\n  top: calc(50% - ", "px);\n"])), function (props) { return props.theme.measurements.canvasControls.width.size / 2; });
var Right$1 = styled(TextWidth)(templateObject_3$k || (templateObject_3$k = __makeTemplateObject(["\n  right: -3px;\n  top: calc(50% - ", "px);\n"], ["\n  right: -3px;\n  top: calc(50% - ", "px);\n"])), function (props) { return props.theme.measurements.canvasControls.width.size / 2; });
var initialCursorPosition$1 = new Vector2(0, 0);
var initialWidthPosition = new Vector2(0, 0);
var Width$1 = function (_a) {
    var sprite = _a.sprite, textTool = _a.textTool;
    var left = sprite.leftMidPadPosition;
    var right = sprite.rightMidPadPosition;
    var onWidthDragStart = function (e, indicator) {
        sprite.setDragMode(true);
        sprite.clickableCanvas(false);
        var clientX = e.clientX, clientY = e.clientY;
        initialCursorPosition$1 = new Vector2(clientX, clientY);
        initialWidthPosition = new Vector2(indicator === 'left' ? left : right);
    };
    var onWidthDragStop = function () {
        sprite.clickableCanvas(true);
        sprite.setDragMode(false);
        sprite.addSnapshot("edit" /* EDIT */, sprite.textLocale.width);
        sprite.setDefaultSize();
        textTool.updateDefaultFontSize();
        initialCursorPosition$1 = new Vector2(0, 0);
        initialWidthPosition = new Vector2(0, 0);
    };
    var onWidthDrag = function (_a) {
        var clientX = _a.clientX, clientY = _a.clientY;
        if (clientX !== undefined && clientY !== undefined) {
            var newPos = initialWidthPosition.subtract(initialCursorPosition$1.subtract(new Vector2(clientX, clientY)));
            sprite.onWidthDrag(newPos);
        }
    };
    return (React.createElement(React.Fragment, null,
        React.createElement(Components.Draggable, { onStart: function (e) { return onWidthDragStart(e, 'left'); }, onDrag: onWidthDrag, onStop: onWidthDragStop },
            React.createElement(Left$1, null)),
        React.createElement(Components.Draggable, { onStart: function (e) { return onWidthDragStart(e, 'right'); }, onDrag: onWidthDrag, onStop: onWidthDragStop },
            React.createElement(Right$1, null))));
};
Left$1.defaultProps = { theme: defaultStyledTheme };
Right$1.defaultProps = { theme: defaultStyledTheme };
var WidthControls = inject('sprite', 'textTool')(observer(Width$1));
var templateObject_1$$, templateObject_2$y, templateObject_3$k;

var TextSpriteControls = function (_a) {
    var textTool = _a.textTool, sprite = _a.sprite, custom = _a.custom;
    var _b;
    var textSpriteLocale = textTool.locale.canvasActions;
    var deleteText = function (e) {
        e.stopPropagation();
        textTool.delete();
    };
    var moveTextToFront = function (e) {
        e.stopPropagation();
        textTool.bringToFront();
    };
    var createButton = function (_a) {
        var key = _a.key, customButtonKey = _a.customButtonKey, onClick = _a.onClick, label = _a.label, icon = _a.icon;
        var button = (React.createElement(CanvasUIComponents.Controls.SpriteActionButton, { ariaLabel: label, key: key, onClick: onClick, icon: icon }, label));
        var customButton = custom.getButton(customButtonKey)({
            key: key,
            label: label,
            onClick: onClick,
            icon: icon,
        });
        return customButton || button;
    };
    var actionsSettings = (_b = {},
        _b[CanvasAction.EDIT] = {
            key: CanvasAction.EDIT,
            customButtonKey: 'canvasActionEdit',
            onClick: function () { return textTool.setEditMode(true); },
            label: textSpriteLocale.buttonEdit,
            icon: React.createElement(TransformIcons.edit, null),
        },
        _b[CanvasAction.BRING_TO_FRONT] = {
            key: CanvasAction.BRING_TO_FRONT,
            customButtonKey: 'canvasActionBringToFront',
            onClick: moveTextToFront,
            label: textSpriteLocale.buttonBringToFront,
            icon: React.createElement(TransformIcons.bringToFront, null),
        },
        _b[CanvasAction.DUPLICATE] = {
            key: CanvasAction.DUPLICATE,
            customButtonKey: 'canvasActionDuplicate',
            onClick: function () { return textTool.duplicate(); },
            label: textSpriteLocale.buttonDuplicate,
            icon: React.createElement(TransformIcons.duplicate, null),
        },
        _b[CanvasAction.DELETE] = {
            key: CanvasAction.DELETE,
            customButtonKey: 'canvasActionDelete',
            onClick: deleteText,
            label: textSpriteLocale.buttonDelete,
            icon: React.createElement(TransformIcons.delete, null),
        },
        _b);
    var actions = textTool.config.canvasActions.map(function (action) {
        if (actionsSettings[action]) {
            return createButton(actionsSettings[action]);
        }
        return null;
    });
    if (!sprite.isSpriteText) {
        return null;
    }
    return React.createElement(CanvasUIComponents.Bar.ButtonGroup, null, actions);
};
var TextSpriteControls$1 = inject('textTool', 'sprite', 'custom')(observer(TextSpriteControls));

var StickerSpriteControls = function (_a) {
    var stickerTool = _a.stickerTool, custom = _a.custom;
    var _b;
    var locale = stickerTool.locale.canvasActions;
    var deleteSticker = function (e) {
        e.stopPropagation();
        stickerTool.delete();
    };
    var moveStickerToFront = function (e) {
        e.stopPropagation();
        stickerTool.bringToFront();
    };
    var flipHorizontally = function (e) {
        e.stopPropagation();
        stickerTool.flipHorizontally();
    };
    var createButton = function (_a) {
        var key = _a.key, customButtonKey = _a.customButtonKey, onClick = _a.onClick, label = _a.label, icon = _a.icon;
        var button = (React.createElement(CanvasUIComponents.Controls.SpriteActionButton, { ariaLabel: label, key: key, onClick: onClick, icon: icon }, label));
        var customButton = custom.getButton(customButtonKey)({
            key: key,
            label: label,
            onClick: onClick,
            icon: icon,
        });
        return customButton || button;
    };
    var actionsSettings = (_b = {},
        _b[CanvasAction.BRING_TO_FRONT] = {
            key: CanvasAction.BRING_TO_FRONT,
            customButtonKey: 'canvasActionBringToFront',
            onClick: moveStickerToFront,
            label: locale.buttonBringToFront,
            icon: React.createElement(TransformIcons.bringToFront, null),
        },
        _b[CanvasAction.FLIP] = {
            key: CanvasAction.FLIP,
            customButtonKey: 'canvasActionFlip',
            onClick: flipHorizontally,
            label: locale.buttonFlipHorizontal,
            icon: React.createElement(TransformIcons.flipHorizontal, null),
        },
        _b[CanvasAction.DUPLICATE] = {
            key: CanvasAction.DUPLICATE,
            customButtonKey: 'canvasActionDuplicate',
            onClick: function () { return stickerTool.duplicate(); },
            label: locale.buttonDuplicate,
            icon: React.createElement(TransformIcons.duplicate, null),
        },
        _b[CanvasAction.DELETE] = {
            key: CanvasAction.DELETE,
            customButtonKey: 'canvasActionDelete',
            onClick: deleteSticker,
            label: locale.buttonDelete,
            icon: React.createElement(TransformIcons.delete, null),
        },
        _b);
    var actions = stickerTool.config.canvasActions.map(function (action) {
        if (actionsSettings[action]) {
            return createButton(actionsSettings[action]);
        }
        return null;
    });
    if (!stickerTool.isStickerSelected) {
        return null;
    }
    return React.createElement(CanvasUIComponents.Bar.ButtonGroup, null, actions);
};
var StickerSpriteControls$1 = inject('stickerTool', 'custom')(observer(StickerSpriteControls));

var TextDesignSpriteControls = function (_a) {
    var textDesignTool = _a.textDesignTool, custom = _a.custom;
    var _b;
    var textSpriteLocale = textDesignTool.locale.canvasActions;
    var deleteTextDesign = function (e) {
        e.stopPropagation();
        textDesignTool.delete();
    };
    var moveTextDesignToFront = function (e) {
        e.stopPropagation();
        textDesignTool.bringToFront();
    };
    var invert = function (e) {
        e.stopPropagation();
        textDesignTool.invertBackground();
    };
    var createButton = function (_a) {
        var key = _a.key, customButtonKey = _a.customButtonKey, onClick = _a.onClick, label = _a.label, icon = _a.icon;
        var button = (React.createElement(CanvasUIComponents.Controls.SpriteActionButton, { ariaLabel: label, key: key, onClick: onClick, icon: icon }, label));
        var customButton = custom.getButton(customButtonKey)({
            key: key,
            label: label,
            onClick: onClick,
            icon: icon,
        });
        return customButton || button;
    };
    var actionsSettings = (_b = {},
        _b[CanvasAction.EDIT] = {
            key: CanvasAction.EDIT,
            customButtonKey: 'canvasActionEdit',
            onClick: function () { return textDesignTool.setEditMode(true); },
            label: textSpriteLocale.buttonEdit,
            icon: React.createElement(TransformIcons.edit, null),
        },
        _b[CanvasAction.BRING_TO_FRONT] = {
            key: CanvasAction.BRING_TO_FRONT,
            customButtonKey: 'canvasActionBringToFront',
            onClick: moveTextDesignToFront,
            label: textSpriteLocale.buttonBringToFront,
            icon: React.createElement(TransformIcons.bringToFront, null),
        },
        _b[CanvasAction.INVERT] = {
            key: CanvasAction.INVERT,
            customButtonKey: 'canvasActionInvert',
            onClick: invert,
            label: textSpriteLocale.buttonInvert,
            icon: React.createElement(TransformIcons.flipHorizontal, null),
        },
        _b[CanvasAction.DUPLICATE] = {
            key: CanvasAction.DUPLICATE,
            customButtonKey: 'canvasActionDuplicate',
            onClick: function () { return textDesignTool.duplicate(); },
            label: textSpriteLocale.buttonDuplicate,
            icon: React.createElement(TransformIcons.duplicate, null),
        },
        _b[CanvasAction.DELETE] = {
            key: CanvasAction.DELETE,
            customButtonKey: 'canvasActionDelete',
            onClick: deleteTextDesign,
            label: textSpriteLocale.buttonDelete,
            icon: React.createElement(TransformIcons.delete, null),
        },
        _b);
    var actions = textDesignTool.config.canvasActions.map(function (action) {
        if (actionsSettings[action]) {
            return createButton(actionsSettings[action]);
        }
        return null;
    });
    if (!textDesignTool.isTextDesignSelected) {
        return null;
    }
    return React.createElement(CanvasUIComponents.Bar.ButtonGroup, null, actions);
};
var TextDesignSpriteControls$1 = inject('textDesignTool', 'custom')(observer(TextDesignSpriteControls));

var SpriteControls = /** @class */ (function (_super) {
    __extends(SpriteControls, _super);
    function SpriteControls(props) {
        var _this = _super.call(this, props) || this;
        _this.actionsRef = null;
        _this.spriteControlPosition = function () {
            var _a = _this.props, config = _a.config, sprite = _a.sprite;
            var measurements = config.measurements;
            var _b = sprite, position = _b.position, height = _b.size.height, rotationWRTOutputRotation = _b.rotationWRTOutputRotation;
            var rotation = rotationWRTOutputRotation;
            var SpriteControlOffset = measurements.canvasControls.sprite.controlOffset;
            var RotateHandleHeight = measurements.canvasControls.sprite.rotateHandle.height;
            var CanvasBarHeight = measurements.mainCanvasActionBar.height;
            var controlPadding = measurements.canvasControls.sprite.controlPadding;
            var controlElement = _this.actionsRef.current;
            var spriteElement = _this.props.spriteRef.current;
            var canvasElement = document.getElementById('CanvasContainer');
            if (controlElement && spriteElement && canvasElement) {
                var spriteEl = spriteElement.getBoundingClientRect();
                var controlEl = controlElement.getBoundingClientRect();
                var canvasEl = canvasElement.getBoundingClientRect();
                var relativeSpriteEl = {
                    top: spriteEl.top - canvasEl.top,
                    left: spriteEl.left - canvasEl.left,
                    right: canvasEl.right - spriteEl.right,
                    bottom: canvasEl.bottom - spriteEl.bottom,
                };
                /**
                 * the spriteEl.width is not used because
                 * We are looking for the sprite width at all times for eg: also when it's rotated
                 */
                var spriteWidth = Math.abs(spriteEl.left - spriteEl.right);
                var spriteHeight = Math.abs(spriteEl.top - spriteEl.bottom);
                var minLeft = SpriteControlOffset;
                var minRight = SpriteControlOffset;
                var minTop = SpriteControlOffset + CanvasBarHeight + controlEl.height;
                var tooLeft = relativeSpriteEl.left < minLeft;
                var tooRight = relativeSpriteEl.right < minRight;
                var tooUp = relativeSpriteEl.top < minTop;
                var x = relativeSpriteEl.left + spriteWidth / 2;
                var y = relativeSpriteEl.top - SpriteControlOffset;
                var newPosition = { x: x, y: y };
                var newTransform = { x: -50, y: -100 };
                if (tooUp) {
                    newPosition.y = relativeSpriteEl.top + spriteHeight + SpriteControlOffset + RotateHandleHeight;
                    newTransform.y = 0;
                }
                if (tooLeft) {
                    newPosition.x = minLeft;
                    newTransform.x = 0;
                }
                if (tooRight) {
                    newPosition.x = canvasEl.width - SpriteControlOffset;
                    newTransform.x = -100;
                }
                var tooLong = relativeSpriteEl.left < SpriteControlOffset && relativeSpriteEl.right > canvasEl.width - SpriteControlOffset;
                var tooTall = tooUp && relativeSpriteEl.bottom > canvasEl.height;
                if (tooLong) {
                    newPosition.x = x;
                }
                if (tooTall) {
                    newPosition.y = relativeSpriteEl.top + spriteHeight / 2;
                }
                if (tooUp || tooLeft || tooRight || tooLong || tooTall || rotation) {
                    return {
                        transform: "translate(" + newTransform.x + "%, " + newTransform.y + "%)",
                        left: newPosition.x + "px",
                        top: newPosition.y - controlPadding / 2 + "px",
                    };
                }
            }
            return {
                left: position.x + "px",
                top: position.y - SpriteControlOffset - height / 2 - controlPadding / 2 + "px",
            };
        };
        _this.getSpriteControls = function () {
            switch (_this.props.sprite.tool) {
                case Tool.TEXT:
                    return React.createElement(TextSpriteControls$1, null);
                case Tool.TEXT_DESIGN:
                    return React.createElement(TextDesignSpriteControls$1, null);
                case Tool.STICKER:
                    return React.createElement(StickerSpriteControls$1, null);
            }
            return null;
        };
        _this.actionsRef = React.createRef();
        return _this;
    }
    SpriteControls.prototype.render = function () {
        var sprite = this.props.sprite;
        var show = !sprite.isDragMode && !sprite.isEditMode;
        if (sprite.isSpriteSelected) {
            var style = this.spriteControlPosition();
            return (React.createElement(CanvasUIComponents.Controls.SpriteActionsWrapper, { ref: this.actionsRef, show: show, style: style }, this.getSpriteControls()));
        }
        return null;
    };
    return SpriteControls;
}(React.Component));
var SpriteActions = inject('sprite', 'config')(observer(SpriteControls));

var Knob$2 = styled(CanvasUIComponents.Controls.Knob)(templateObject_1$10 || (templateObject_1$10 = __makeTemplateObject(["\n  margin-left: -11px;\n  margin-top: 0px;\n  cursor: url(", ") 9 9, ew-resize;\n  &:before {\n    top: unset;\n    bottom: 0px;\n    left: calc(50% - ", "px);\n  }\n"], ["\n  margin-left: -11px;\n  margin-top: 0px;\n  cursor: url(", ") 9 9, ew-resize;\n  &:before {\n    top: unset;\n    bottom: 0px;\n    left: calc(50% - ", "px);\n  }\n"])), function (props) { return props.url; }, function (props) { return props.theme.measurements.canvasControls.knob.size / 2; });
var initialCursorPosition$2 = new Vector2(0, 0);
var initialRotateKnobPosition = new Vector2(0, 0);
var Rotate$2 = function (_a) {
    var config = _a.config, sprite = _a.sprite, snapping = _a.snapping;
    var p1 = sprite.rightBottomHandlePosition;
    var p2 = sprite.leftBottomHandlePosition;
    var rotateKnobPosition = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    var onRotateDragStart = function (_a) {
        var clientX = _a.clientX, clientY = _a.clientY;
        initialCursorPosition$2 = new Vector2(clientX, clientY);
        initialRotateKnobPosition = new Vector2(rotateKnobPosition);
        sprite.setDragMode(true);
        sprite.clickableCanvas(false);
    };
    var onRotateDragStop = function () {
        sprite.clickableCanvas(true);
        sprite.setDragMode(false);
        sprite.spriteSnapshot('rotation');
        snapping.hideRotationGuides();
        initialCursorPosition$2 = new Vector2(0, 0);
        initialRotateKnobPosition = new Vector2(0, 0);
    };
    var onRotate = function (_a) {
        var clientX = _a.clientX, clientY = _a.clientY;
        if (clientX !== undefined && clientY !== undefined) {
            var v2 = initialRotateKnobPosition.subtract(initialCursorPosition$2.subtract(new Vector2(clientX, clientY)));
            var center = sprite.position;
            var v1 = new Vector2(center.x, center.y);
            var distance = v2.subtract(v1);
            /**
             * The angle is calculated wrt x-axis
             * But here we are looking for angle wrt center and rotateknob line,
             * which is perpandicular to x-axis so -90° = Math.PI / 2 radians
             */
            var rotation = Math.atan2(distance.y, distance.x) - Math.PI / 2;
            var nextRotation = snapping.snapToRotation(rotation, distance, sprite.currentRect);
            sprite.setRotation(nextRotation);
        }
    };
    var onRotateDrag = function (e) {
        onRotate(e);
    };
    var url = config.assetProvider.getAbsolutePath("controls/" + (isWindows() ? 'rotate-windows' : 'rotate-osx') + ".png");
    return (React.createElement(Components.Draggable, { onStart: onRotateDragStart, onDrag: onRotateDrag, onStop: onRotateDragStop },
        React.createElement(Knob$2, { url: url })));
};
Knob$2.defaultProps = { theme: defaultStyledTheme };
var RotateControls = inject('sprite', 'snapping', 'config')(observer(Rotate$2));
var templateObject_1$10;

var Corner$1 = CanvasUIComponents.Controls.Corner;
var Draggable$2 = Components.Draggable;
var initialCursorPosition$3 = new Vector2(0, 0);
var initialKnobPosition = new Vector2(0, 0);
var Resize = /** @class */ (function (_super) {
    __extends(Resize, _super);
    function Resize() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Resize.prototype, "sprite", {
        get: function () {
            return this.props.sprite;
        },
        enumerable: true,
        configurable: true
    });
    Resize.prototype.render = function () {
        var _a = this.props, sprite = _a.sprite, config = _a.config;
        var _b = sprite, leftTopPosition = _b.leftTopPosition, leftBottomPosition = _b.leftBottomPosition, rightTopPosition = _b.rightTopPosition, rightBottomPosition = _b.rightBottomPosition;
        var borderWidth = config.measurements.canvasControls.corner.borderWidth;
        var onCornerDrag = function (_a) {
            var clientX = _a.clientX, clientY = _a.clientY;
            if (clientX !== undefined && clientY !== undefined) {
                var newPos = initialKnobPosition.subtract(initialCursorPosition$3.subtract(new Vector2(clientX, clientY)));
                sprite.onCornerDrag(newPos);
            }
        };
        var getInitialKnobPosition = function (indicator) {
            switch (indicator) {
                case 'leftTop':
                    return leftTopPosition;
                case 'leftBottom':
                    return leftBottomPosition;
                case 'rightTop':
                    return rightTopPosition;
                case 'rightBottom':
                    return rightBottomPosition;
                default:
                    return leftTopPosition;
            }
        };
        var onCornerDragStart = function (e, indicator) {
            var clientX = e.clientX, clientY = e.clientY;
            initialCursorPosition$3 = new Vector2(clientX, clientY);
            initialKnobPosition = new Vector2(getInitialKnobPosition(indicator));
            sprite.clickableCanvas(false);
            sprite.setDragMode(true);
        };
        var onCornerDragStop = function () {
            sprite.clickableCanvas(true);
            sprite.setDragMode(false);
            sprite.spriteSnapshot('size');
            initialCursorPosition$3 = new Vector2(0, 0);
            initialKnobPosition = new Vector2(0, 0);
        };
        return (React.createElement(React.Fragment, null,
            React.createElement(Draggable$2, { onStop: onCornerDragStop, onDrag: onCornerDrag, onStart: function (e) { return onCornerDragStart(e, 'leftTop'); } },
                React.createElement(Corner$1, { vertical: "top", horizontal: "left", borderWidth: borderWidth })),
            React.createElement(Draggable$2, { onStop: onCornerDragStop, onDrag: onCornerDrag, onStart: function (e) { return onCornerDragStart(e, 'leftBottom'); } },
                React.createElement(Corner$1, { vertical: "bottom", horizontal: "left", borderWidth: borderWidth })),
            React.createElement(Draggable$2, { onStop: onCornerDragStop, onDrag: onCornerDrag, onStart: function (e) { return onCornerDragStart(e, 'rightTop'); } },
                React.createElement(Corner$1, { vertical: "top", horizontal: "right", borderWidth: borderWidth })),
            React.createElement(Draggable$2, { onStop: onCornerDragStop, onDrag: onCornerDrag, onStart: function (e) { return onCornerDragStart(e, 'rightBottom'); } },
                React.createElement(Corner$1, { vertical: "bottom", horizontal: "right", borderWidth: borderWidth }))));
    };
    return Resize;
}(React.Component));
var CornerControls = inject('sprite', 'config')(observer(Resize));

var Draggable$3 = Components.Draggable;
var initialCursorPosition$4 = new Vector2(0, 0);
var initialCenterPosition = new Vector2(0, 0);
var Sprite$1 = /** @class */ (function (_super) {
    __extends(Sprite, _super);
    function Sprite(props) {
        var _this = _super.call(this, props) || this;
        _this.spriteRef = null;
        _this.onAreaDrag = function (_a) {
            var clientX = _a.clientX, clientY = _a.clientY;
            var snapping = _this.props.snapping;
            var newPos = initialCenterPosition.subtract(initialCursorPosition$4.subtract(new Vector2(clientX, clientY)));
            var _b = snapping.snapToPosition({ x: newPos.x, y: newPos.y }, _this.sprite.currentRect), x = _b.x, y = _b.y;
            _this.sprite.setPosition({ x: x, y: y });
        };
        _this.onAreaDragStart = function (e) {
            var snapping = _this.props.snapping;
            var clientX = e.clientX, clientY = e.clientY;
            initialCursorPosition$4 = new Vector2(clientX, clientY);
            initialCenterPosition = new Vector2(_this.sprite.position);
            _this.sprite.setDragMode(true);
            snapping.updateGuides();
        };
        _this.onAreaDragStop = function () {
            var snapping = _this.props.snapping;
            initialCursorPosition$4 = new Vector2(0, 0);
            initialCenterPosition = new Vector2(0, 0);
            _this.sprite.setDragMode(false);
            _this.sprite.spriteSnapshot('position');
            snapping.hidePositionGuides();
        };
        _this.onDoubleClick = function (e) {
            e.preventDefault();
            e.stopPropagation();
            _this.sprite.setEditMode(true);
        };
        _this.isSpriteSelected = function () {
            var active = _this.props.active;
            var activeTool = active.tool;
            var activeSpriteTool = _this.sprite.tool;
            return _this.sprite.isSpriteSelected && activeTool === activeSpriteTool;
        };
        _this.spriteRef = React.createRef();
        return _this;
    }
    Object.defineProperty(Sprite.prototype, "sprite", {
        get: function () {
            return this.props.sprite;
        },
        enumerable: true,
        configurable: true
    });
    Sprite.prototype.render = function () {
        var _a = this.props, sprite = _a.sprite, config = _a.config;
        var isSpriteSelected = this.isSpriteSelected();
        if (!isSpriteSelected) {
            return null;
        }
        var isSpriteText = this.sprite.isSpriteText;
        var paddingHandles = this.sprite.isSpriteTextDesign && this.sprite.textDesignToolStore.isInverted;
        var _b = sprite.size, height = _b.height, width = _b.width;
        var position = sprite.spritePosition;
        var rotation = sprite.rotationWRTOutputRotation;
        var controlPadding = config.measurements.canvasControls.sprite.controlPadding;
        return (React.createElement(CanvasUIComponents.Controls.Container, null,
            React.createElement(Draggable$3, { onStart: this.onAreaDragStart, onDrag: this.onAreaDrag, onStop: this.onAreaDragStop, rotation: rotation, position: position },
                React.createElement(CanvasUIComponents.Controls.Sprite, { ref: this.spriteRef, onDoubleClick: this.onDoubleClick, height: height, width: width },
                    (isSpriteText && React.createElement(WidthControls, null)) || null,
                    (paddingHandles && React.createElement(PaddingControls, null)) || null,
                    React.createElement(CornerControls, null),
                    React.createElement(CanvasUIComponents.Controls.RotateHandle, { x: width / 2 + controlPadding / 2 },
                        React.createElement(RotateControls, null)))),
            React.createElement(SpriteActions, { spriteRef: this.spriteRef })));
    };
    return Sprite;
}(React.Component));
var SpriteComponent = inject('sprite', 'active', 'snapping', 'config')(observer(Sprite$1));

var CanvasControls$1 = /** @class */ (function (_super) {
    __extends(CanvasControls, _super);
    function CanvasControls(props) {
        var _this = _super.call(this, props) || this;
        _this.containerElementRef = null;
        _this.getControls = function (children) {
            switch (_this.props.active.tool) {
                case Tool.FOCUS:
                    return React.createElement(FocusCanvasControls$1, null);
                case Tool.TEXT:
                case Tool.TEXT_DESIGN:
                case Tool.STICKER:
                    return React.createElement(SpriteComponent, null);
                case Tool.BRUSH:
                    return React.createElement(BrushCanvasControls, null);
                case Tool.TRANSFORM:
                    return React.createElement(TransformCanvasControls, null);
                default:
                    return React.createElement(CanvasUIComponents.Controls.Container, null, children);
            }
        };
        _this.canvasClicked = function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (_this.props.canvas.isCanvasClickable) {
                var clientX = e.clientX;
                var clientY = e.clientY;
                if (e.type.indexOf('touch') !== -1) {
                    var ev = e;
                    if (!ev.touches.length) {
                        return;
                    }
                    clientX = ev.touches[0].clientX;
                    clientY = ev.touches[0].clientY;
                }
                var rect = _this.containerElementRef.current.getBoundingClientRect();
                var x = clientX - rect.left;
                var y = clientY - rect.top;
                _this.props.canvas.getContainersAtPreviewPoint({ x: x, y: y });
            }
        };
        _this.onKeyDown = function (e) {
            if (e.code === 'Tab') {
                _this.props.sprite.selectLast();
            }
        };
        _this.containerElementRef = React.createRef();
        return _this;
    }
    CanvasControls.prototype.render = function () {
        var children = this.props.children;
        var canvasSize = this.props.canvas.canvasSize;
        var styles = {
            height: canvasSize.height,
            width: canvasSize.width,
        };
        return (React.createElement(CanvasUIComponents.Controls.Wrapper, __assign({ "aria-hidden": true, ref: this.containerElementRef, onClick: this.canvasClicked, onKeyDown: this.onKeyDown }, styles),
            children,
            this.getControls(React.createElement(DragImage$1, null))));
    };
    return CanvasControls;
}(React.Component));
var CanvasControls$2 = inject('active', 'canvas', 'sprite')(observer(CanvasControls$1));

var Root$1 = styled.div(templateObject_1$11 || (templateObject_1$11 = __makeTemplateObject(["\n  display: ", ";\n  position: absolute;\n  z-index: ", ";\n"], ["\n  display: ", ";\n  position: absolute;\n  z-index: ", ";\n"])), function (_a) {
    var isVisible = _a.isVisible;
    return (isVisible ? 'block' : 'none');
}, function (props) { return props.theme.measurements.zIndex.canvas.snappingGuide; });
var Guide = function (_a) {
    var isVisible = _a.isVisible, className = _a.className;
    return React.createElement(Root$1, { isVisible: isVisible, className: className });
};
Guide.defaultProps = {
    direction: 'horizontal',
    left: 0,
    top: 0,
};
var templateObject_1$11;

var PositionGuide = styled(Guide)(templateObject_3$l || (templateObject_3$l = __makeTemplateObject(["\n  background: ", ";\n  ", "\n"], ["\n  background: ", ";\n  ",
    "\n"])), function (props) { return props.theme.snapping.positionGuideColor; }, function (props) {
    if (props.direction === 'horizontal') {
        return css(templateObject_1$12 || (templateObject_1$12 = __makeTemplateObject(["\n        width: 100%;\n        height: 2px;\n        top: ", "px;\n      "], ["\n        width: 100%;\n        height: 2px;\n        top: ", "px;\n      "])), function () { return props.position; });
    }
    return css(templateObject_2$z || (templateObject_2$z = __makeTemplateObject(["\n      width: 2px;\n      height: 100%;\n      left: ", "px;\n    "], ["\n      width: 2px;\n      height: 100%;\n      left: ", "px;\n    "])), function () { return props.position; });
});
var RotationGuide = styled(Guide)(templateObject_4$d || (templateObject_4$d = __makeTemplateObject(["\n  border: none;\n  border-top: 2px dashed ", ";\n  background: transparent;\n  left: ", "px;\n  top: ", "px;\n  transform: rotate(", "rad);\n  width: 200%;\n"], ["\n  border: none;\n  border-top: 2px dashed ", ";\n  background: transparent;\n  left: ", "px;\n  top: ", "px;\n  transform: rotate(", "rad);\n  width: 200%;\n"])), function (props) { return props.theme.snapping.rotationGuideColor; }, function (_a) {
    var position = _a.position;
    return position.x;
}, function (_a) {
    var position = _a.position;
    return position.y;
}, function (_a) {
    var rotation = _a.rotation;
    return rotation;
});
var Root$2 = styled.div(templateObject_5$9 || (templateObject_5$9 = __makeTemplateObject(["\n  position: absolute;\n  width: ", "px;\n  height: ", "px;\n  top: ", "px;\n  left: ", "px;\n  overflow: hidden;\n"], ["\n  position: absolute;\n  width: ", "px;\n  height: ", "px;\n  top: ", "px;\n  left: ", "px;\n  overflow: hidden;\n"])), function (_a) {
    var width = _a.width;
    return width;
}, function (_a) {
    var height = _a.height;
    return height;
}, function (_a) {
    var top = _a.top;
    return top;
}, function (_a) {
    var left = _a.left;
    return left;
});
var Guides = function (_a) {
    var snapping = _a.snapping, editor = _a.editor;
    var _b = editor.getPreviewSize(), width = _b.width, height = _b.height;
    var _c = snapping.previewTopLeftPosition, x = _c.x, y = _c.y;
    var positionGuides = snapping.positionGuides.map(function (_a, i) {
        var direction = _a.direction, value = _a.value, isVisible = _a.isVisible;
        return (React.createElement(PositionGuide
        // eslint-disable-next-line react/no-array-index-key
        , { 
            // eslint-disable-next-line react/no-array-index-key
            key: "positionGuide-" + i, direction: direction, position: value, isVisible: isVisible }));
    });
    var visibleRotationGuide = snapping.rotationGuides.find(function (_a) {
        var isVisible = _a.isVisible;
        return isVisible;
    });
    return (React.createElement(Root$2, { width: width, height: height, left: x, top: y },
        positionGuides,
        React.createElement(RotationGuide, { key: "rotationGuide", rotation: visibleRotationGuide ? visibleRotationGuide.value : 0, position: visibleRotationGuide ? visibleRotationGuide.position : { x: 0, y: 0 }, isVisible: !!visibleRotationGuide })));
};
var Guides$1 = inject('snapping', 'editor')(observer(Guides));
var templateObject_1$12, templateObject_2$z, templateObject_3$l, templateObject_4$d, templateObject_5$9;

var CanvasContainerComponent = /** @class */ (function (_super) {
    __extends(CanvasContainerComponent, _super);
    function CanvasContainerComponent(props) {
        var _this = _super.call(this, props) || this;
        _this.previewCanvasRef = null;
        _this.previewCanvasRef = React.createRef();
        return _this;
    }
    CanvasContainerComponent.prototype.componentDidMount = function () {
        var element = this.previewCanvasRef.current;
        this.props.canvas.setCanvasElement(element);
    };
    CanvasContainerComponent.prototype.render = function () {
        return (React.createElement(Window, null,
            this.props.active.isWebcam ? React.createElement(Webcam$1, null) : null,
            React.createElement(CanvasUIComponents.Element, { ref: this.previewCanvasRef, "aria-label": "Canvas" }),
            React.createElement(CanvasControls$2, null,
                React.createElement(Guides$1, null))));
    };
    return CanvasContainerComponent;
}(React.Component));
var CanvasContainer$1 = inject('active', 'canvas')(observer(CanvasContainerComponent));

var Button$1 = CanvasUIComponents.Button.TextSecondary;
var Span = styled.span(templateObject_1$13 || (templateObject_1$13 = __makeTemplateObject(["\n  font-size: 14px;\n  padding: 3px 1px 2px;\n  color: ", ";\n  display: flex;\n  align-self: center;\n"], ["\n  font-size: 14px;\n  padding: 3px 1px 2px;\n  color: ", ";\n  display: flex;\n  align-self: center;\n"])), function (props) { return props.theme.canvasActionBar.foreground; });
var ZoomComponent = function (_a) {
    var scale = _a.scale, active = _a.active;
    var canZoomIn = scale.canZoomIn;
    var canZoomOut = scale.canZoomOut;
    var zoomLevel = scale.zoomLevel;
    var toolControlsDraggable = [Tool.TRANSFORM, Tool.BRUSH, Tool.FOCUS, Tool.STICKER, Tool.TEXT, Tool.TEXT_DESIGN].indexOf(active.tool) !== -1;
    return !toolControlsDraggable ? (React.createElement(CanvasUIComponents.Bar.ButtonGroup, null,
        React.createElement(Button$1, { ariaLabel: 'Zoom out', isDisabled: !canZoomOut, onClick: scale.out }, "-"),
        React.createElement(Span, null,
            zoomLevel,
            " %"),
        React.createElement(Button$1, { ariaLabel: 'Zoom in', isDisabled: !canZoomIn, onClick: scale.in }, "+"))) : null;
};
var ZoomComponent$1 = inject('scale', 'active')(observer(ZoomComponent));
Span.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$13;

var Button$2 = CanvasUIComponents.Button.TextSecondary;
var Primary = CanvasUIComponents.Button.ContainedPrimary;
var Secondary = CanvasUIComponents.Button.OutlinedSecondary;
var CanvasBarComponent = function (_a) {
    var config = _a.config, editor = _a.editor, history = _a.history, custom = _a.custom;
    var commonLocale = config.locale.mainCanvasActions;
    var canUndo = history.canUndo;
    var canRedo = history.canRedo;
    var actionsConfig = config.config.mainCanvasActions;
    var exportImage = function () {
        editor.export();
    };
    var close = function () {
        editor.close();
    };
    var undo = function () {
        var icon = React.createElement(EditorIcons.undo, null);
        var button = (React.createElement(Button$2, { ariaLabel: commonLocale.buttonUndo, onClick: history.undo, isDisabled: !canUndo, icon: icon }, commonLocale.buttonUndo));
        var customButton = custom.getButton('mainCanvasActionUndo')({
            key: 'mainCanvasActionUndo',
            onClick: history.undo,
            isDisabled: !canUndo,
            label: commonLocale.buttonUndo,
            icon: icon,
        });
        return customButton || button;
    };
    var redo = function () {
        var icon = React.createElement(EditorIcons.redo, null);
        var button = (React.createElement(Button$2, { ariaLabel: commonLocale.buttonRedo, onClick: history.redo, isDisabled: !canRedo, icon: icon }, commonLocale.buttonRedo));
        var customButton = custom.getButton('mainCanvasActionRedo')({
            key: 'mainCanvasActionRedo',
            onClick: history.redo,
            isDisabled: !canRedo,
            label: commonLocale.buttonRedo,
            icon: icon,
        });
        return customButton || button;
    };
    var exportImg = function () {
        var icon = React.createElement(EditorIcons.export, null);
        var button = (React.createElement(Primary, { ariaLabel: commonLocale.buttonExport, onClick: exportImage, icon: icon }, commonLocale.buttonExport));
        var customButton = custom.getButton('mainCanvasActionExport')({
            key: 'mainCanvasActionExport',
            onClick: exportImage,
            label: commonLocale.buttonExport,
            icon: icon,
        });
        return customButton || button;
    };
    var closeImg = function () {
        if (!config.displayCloseButton) {
            return null;
        }
        var icon = React.createElement(EditorIcons.close, null);
        var button = (React.createElement(Secondary, { ariaLabel: commonLocale.buttonClose, onClick: close, icon: icon }, commonLocale.buttonClose));
        var customButton = custom.getButton('mainCanvasActionClose')({
            key: 'mainCanvasActionClose',
            onClick: close,
            label: commonLocale.buttonClose,
            icon: icon,
        });
        return customButton || button;
    };
    var mappedActions = actionsConfig.map(function (action) {
        switch (action) {
            case CanvasAction.UNDO:
                return undo;
            case CanvasAction.REDO:
                return redo;
            case CanvasAction.EXPORT:
                return exportImg;
            case CanvasAction.CLOSE:
                return closeImg;
        }
        return null;
    });
    return (React.createElement(CanvasUIComponents.Bar.Index, null,
        React.createElement(CanvasUIComponents.Bar.ButtonGroup, null,
            (mappedActions[0] && mappedActions[0]()) || null,
            (mappedActions[1] && mappedActions[1]()) || null),
        config.config.enableZoom ? React.createElement(ZoomComponent$1, null) : null,
        React.createElement(CanvasUIComponents.Bar.ButtonGroup, null,
            (mappedActions[2] && mappedActions[2]()) || null,
            (mappedActions[3] && mappedActions[3]()) || null)));
};
var CanvasBar$2 = inject('config', 'editor', 'history', 'custom')(observer(CanvasBarComponent));

var InlineDiv = styled.div(templateObject_1$14 || (templateObject_1$14 = __makeTemplateObject(["\n  display: inline-flex;\n  justify-content: space-between;\n  max-width: ", "px;\n"], ["\n  display: inline-flex;\n  justify-content: space-between;\n  max-width: ", "px;\n"])), function (props) { return props.theme.measurements.advancedToolControlBar.width; });
var X = styled.span(templateObject_2$A || (templateObject_2$A = __makeTemplateObject(["\n  font-size: ", "px;\n  margin-top: 10px;\n  margin-right: 13px;\n"], ["\n  font-size: ", "px;\n  margin-top: 10px;\n  margin-right: 13px;\n"])), function (props) { return props.theme.measurements.fontSystem.label.size; });
var InlineLabel = styled(Components.Input.Label)(templateObject_3$m || (templateObject_3$m = __makeTemplateObject(["\n  position: absolute;\n  right: 8px;\n  top: 8px;\n"], ["\n  position: absolute;\n  right: 8px;\n  top: 8px;\n"])));
var TransformScaleInput = /** @class */ (function (_super) {
    __extends(TransformScaleInput, _super);
    function TransformScaleInput() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onWidthChange = function (v) {
            _this.props.onChangeWidth(parseInt(v, 10) || 0);
        };
        _this.onHeightChange = function (v) {
            _this.props.onChangeHeight(parseInt(v, 10) || 0);
        };
        _this.onKeyUpWidth = function (e) {
            if (e.keyCode === 13) {
                _this.props.onBlurWidth();
            }
        };
        _this.onKeyUpHeight = function (e) {
            if (e.keyCode === 13) {
                _this.props.onBlurHeight();
            }
        };
        _this.onBlurHeight = function () {
            _this.props.onBlurHeight();
        };
        _this.onBlurWidth = function () {
            _this.props.onBlurWidth();
        };
        return _this;
    }
    TransformScaleInput.prototype.render = function () {
        var _a = this.props, label = _a.label, showLabel = _a.showLabel, isDisabled = _a.isDisabled, labelWidth = _a.labelWidth, labelHeight = _a.labelHeight, valueWidth = _a.valueWidth, valueHeight = _a.valueHeight;
        return (React.createElement("div", null,
            React.createElement(Components.Input.Label, { name: label, show: showLabel }),
            React.createElement(InlineDiv, null,
                React.createElement(Components.Input.Text, { id: labelWidth.replace(' ', '-'), value: valueWidth, isDisabled: isDisabled, onChange: this.onWidthChange, onBlur: this.onBlurWidth, onKeyUp: this.onKeyUpWidth },
                    React.createElement(InlineLabel, { name: labelWidth, htmlFor: labelWidth.replace(' ', '-') })),
                React.createElement(X, null, "x"),
                React.createElement(Components.Input.Text, { id: labelHeight.replace(' ', '-'), value: valueHeight, isDisabled: isDisabled, onChange: this.onHeightChange, onBlur: this.onBlurHeight, onKeyUp: this.onKeyUpHeight },
                    React.createElement(InlineLabel, { name: labelHeight, htmlFor: labelHeight.replace(' ', '-') })))));
    };
    TransformScaleInput.defaultProps = {
        showLabel: true,
    };
    return TransformScaleInput;
}(React.Component));
var templateObject_1$14, templateObject_2$A, templateObject_3$m;

var Modal = function (_a) {
    var modal = _a.modal, textTool = _a.textTool, textDesignTool = _a.textDesignTool, custom = _a.custom;
    var _b = modal, type = _b.type, infoModalProps = _b.infoModalProps, modalProps = _b.modalProps;
    var offset = modal.positionOffset;
    var loader = custom.getLoader(__assign({}, infoModalProps, { position: offset }));
    switch (type) {
        case ModalType.INFO:
            if (modal.identifier === 'loading') {
                // note: that has to be cast this since https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18912 is still open
                return loader;
            }
            return React.createElement(Components.Loader, __assign({}, infoModalProps, { position: offset }));
        case ModalType.TEXT_EDIT:
            if (textTool.isTextSelected) {
                return (React.createElement(Components.Input.TextEdit, { defaultText: TextToolStore.defaultText(), show: modal.show, save: textTool.changeText, close: textTool.setEditMode, text: textTool.text, position: offset, saveLabel: textTool.locale.canvasControls.buttonSave, closeLabel: textTool.locale.canvasControls.buttonClose, editLabel: textTool.locale.canvasControls.inputText }));
            }
            if (textDesignTool.isTextDesignSelected) {
                return (React.createElement(Components.Input.TextEdit, { defaultText: TextDesignToolStore.defaultText(), show: modal.show, save: textDesignTool.changeText, close: textDesignTool.setEditMode, text: textDesignTool.text, position: offset, saveLabel: textTool.locale.canvasControls.buttonSave, closeLabel: textTool.locale.canvasControls.buttonClose, editLabel: textTool.locale.canvasControls.inputText }));
            }
            return null;
        default:
            // Action Modals
            return React.createElement(Components.Modal, __assign({}, modalProps, { position: offset }));
    }
};
var Modal$1 = inject('textTool', 'textDesignTool', 'modal', 'custom')(observer(Modal));

/**
 * Custom Component factory helps send only the configured props for custom components
 */
var CustomComponentsFactory = /** @class */ (function () {
    function CustomComponentsFactory(customComponents, originalComponents) {
        var _this = this;
        this.getAdvancedCategoryCard = function (props) {
            if (_this.AdvancedCategoryCard) {
                return _this.customAdvancedCategoryCard(props);
            }
            return _this.currentAdvancedCard(props);
        };
        this.getAdvancedOptionCard = function (props) {
            if (_this.AdvancedOptionCard) {
                return _this.customAdvancedOptionCard(props);
            }
            return _this.currentAdvancedCard(props);
        };
        this.getAdvancedToolbarItem = function (props) {
            if (_this.AdvancedToolbarItem) {
                return _this.customAdvancedToolbarItem(props);
            }
            return _this.currentAdvancedToolbarItem(props);
        };
        this.getLoader = function (props) {
            if (_this.Loader) {
                return _this.customLoader(props);
            }
            return _this.loader(props);
        };
        this.getButton = function (key) { return function (props) {
            if (_this.Buttons && _this.Buttons[key]) {
                return _this.customButton(key)(props);
            }
            return null;
        }; };
        this.customLoader = function (props) {
            var show = props.show;
            var Loader = _this.Loader;
            return React.createElement(Loader, { show: show });
        };
        this.customAdvancedCategoryCard = function (props) {
            var derivedProps = props;
            var AdvancedCategoryCard = _this.AdvancedCategoryCard;
            return React.createElement(AdvancedCategoryCard, __assign({}, derivedProps));
        };
        this.customAdvancedOptionCard = function (props) {
            var derivedProps = props;
            var AdvancedOptionCard = _this.AdvancedOptionCard;
            return React.createElement(AdvancedOptionCard, __assign({ key: props.key }, derivedProps));
        };
        this.customAdvancedToolbarItem = function (props) {
            var tool = props.tool, icon = props.icon, label = props.label, onClick = props.onClick, isActive = props.isActive;
            var derivedProps = { tool: tool, icon: icon, label: label, onClick: onClick, isActive: isActive };
            var ToolbarItemComponent = _this.AdvancedToolbarItem;
            return React.createElement(ToolbarItemComponent, __assign({ key: tool }, derivedProps));
        };
        this.customButton = function (buttonName) { return function (props) {
            var Button = _this.Buttons[buttonName];
            return React.createElement(Button, __assign({ key: props.key }, props));
        }; };
        this.loader = function (props) {
            var Loader = _this.originalComponents.loader;
            return React.createElement(Loader, __assign({}, props));
        };
        this.currentAdvancedCard = function (props) {
            var Card = _this.originalComponents.advancedCard;
            if (Card) {
                return React.createElement(Card, __assign({}, props));
            }
            return null;
        };
        this.currentAdvancedToolbarItem = function (props) {
            var AdvancedToolbarItem = _this.originalComponents.advancedToolbarItem;
            if (AdvancedToolbarItem) {
                return React.createElement(AdvancedToolbarItem, __assign({}, props));
            }
            return null;
        };
        this.originalComponents = originalComponents;
        this.AdvancedCategoryCard =
            customComponents && customComponents.advancedUICategoryCard ? customComponents.advancedUICategoryCard : null;
        this.AdvancedOptionCard =
            customComponents && customComponents.advancedUIItemCard ? customComponents.advancedUIItemCard : null;
        this.AdvancedToolbarItem =
            customComponents && customComponents.advancedUIToolbarItem ? customComponents.advancedUIToolbarItem : null;
        this.Loader = customComponents && customComponents.loader ? customComponents.loader : null;
        this.Buttons = customComponents && customComponents.buttons ? customComponents.buttons : null;
    }
    return CustomComponentsFactory;
}());

var Root$3 = styled.div(templateObject_1$15 || (templateObject_1$15 = __makeTemplateObject(["\n  position: relative;\n"], ["\n  position: relative;\n"])));
var ColorList = /** @class */ (function (_super) {
    __extends(ColorList, _super);
    function ColorList(props) {
        var _this = _super.call(this, props) || this;
        _this.onClick = function (identifier) { return function (e) {
            var _a = _this.props, activeColor = _a.activeColor, onAddSnapshot = _a.onAddSnapshot, config = _a.config;
            var _b = _this.state, showColorPicker = _b.showColorPicker, colorList = _b.colorList;
            var rgbColor = colorList.find(function (c) { return c.identifier === identifier; });
            if (activeColor === rgbColor.identifier && !showColorPicker) {
                var index = colorList.findIndex(function (namedColor) { return namedColor.identifier === identifier; });
                import('./index-f817cff7.js').then(function (_a) {
                    var ColorPicker = _a.ColorPicker;
                    _this.UIComponent = ColorPicker;
                    _this.forceUpdate();
                });
                var _c = e.currentTarget.getBoundingClientRect(), buttonLeft = _c.left, buttonWidth = _c.width;
                var _d = e.currentTarget.parentElement.getBoundingClientRect(), listLeft = _d.left, listWidth = _d.width;
                /** For arrow positioning */
                // get the left offset of the color list
                var offset = (config.measurements.color.colorPicker.width - listWidth) / 2;
                // middle of the color item
                var buttonOffset = buttonLeft - listLeft - buttonWidth / 2;
                // -1 for the border
                var arrowOffset = buttonOffset + offset - 1;
                _this.setState({
                    showColorPicker: true,
                    activeColorName: colorList[index].identifier,
                    arrowOffset: arrowOffset,
                });
            }
            else if (showColorPicker) {
                _this.setState({ showColorPicker: false });
            }
            else {
                _this.onChange(identifier)(rgbColor);
                if (onAddSnapshot) {
                    onAddSnapshot();
                }
            }
        }; };
        _this.onChange = function (key) { return function (_a) {
            var color = _a.color, colorString = _a.colorString;
            var onChange = _this.props.onChange;
            var colorList = _this.state.colorList;
            var index = colorList.findIndex(function (namedColor) { return namedColor.identifier === key; });
            var newColorList = __spread(colorList);
            newColorList[index] = {
                identifier: colorList[index].identifier,
                colorString: colorString,
                color: color,
            };
            _this.setState({ colorList: newColorList });
            onChange(color, colorList[index].identifier);
        }; };
        _this.onChangeColorPicker = function (_a) {
            var color = _a.color, colorString = _a.colorString;
            var activeColorName = _this.state.activeColorName;
            /** Normalize color */
            _this.onChange(activeColorName)({ color: [color[0] / 255, color[1] / 255, color[2] / 255, color[3]], colorString: colorString });
        };
        _this.closeColorPicker = function () {
            _this.setState({ showColorPicker: false });
        };
        _this.getColorPicker = function () {
            var _a = _this.props, parentId = _a.parentId, activeColor = _a.activeColor, labelsColor = _a.labelsColor, colorPickerDirection = _a.colorPickerDirection, onAddSnapshot = _a.onAddSnapshot;
            var _b = _this.state, showColorPicker = _b.showColorPicker, arrowOffset = _b.arrowOffset, colorList = _b.colorList;
            if (!_this.UIComponent) {
                return null;
            }
            var ColorPicker = _this.UIComponent;
            var color = colorList.filter(function (_a) {
                var identifier = _a.identifier;
                return identifier === activeColor;
            })[0].colorString;
            return (React.createElement(ColorPicker, { parentId: parentId, color: color, show: showColorPicker, direction: colorPickerDirection, arrowOffset: arrowOffset, labelHex: labelsColor.hex, labelR: labelsColor.r, labelG: labelsColor.g, labelB: labelsColor.b, labelSliderOpacity: labelsColor.sliderOpacity, labelSliderHue: labelsColor.sliderHue, onChange: _this.onChangeColorPicker, onRequestClose: _this.closeColorPicker, onAddSnapshot: onAddSnapshot }));
        };
        var colors = _this.props.colors;
        _this.state = {
            activeColorName: '',
            colorList: __spread(colors),
            showColorPicker: false,
            arrowOffset: 0,
        };
        _this.UIComponent = null;
        return _this;
    }
    ColorList.prototype.render = function () {
        var _this = this;
        var _a = this.props, activeColor = _a.activeColor, isDisabled = _a.isDisabled;
        var colorList = this.state.colorList;
        var items = colorList.map(function (namedColor) { return (React.createElement(Components.ColorItem, { key: namedColor.colorString + "-item-" + namedColor.identifier, isActive: namedColor.identifier === activeColor, isDisabled: isDisabled, onClick: _this.onClick(namedColor.identifier), color: namedColor.colorString, label: namedColor.identifier })); });
        return (React.createElement(Root$3, null,
            items,
            this.getColorPicker()));
    };
    ColorList.defaultProps = {
        colorPickerDirection: 'bottom',
        isDisabled: false,
    };
    ColorList = __decorate([
        inject('config'),
        observer
    ], ColorList);
    return ColorList;
}(React.Component));
var templateObject_1$15;

var OutlinedPrimaryButton = styled(BaseButton)(templateObject_1$16 || (templateObject_1$16 = __makeTemplateObject(["\n  width: 100%;\n  background: ", ";\n  color: ", ";\n  border: 1px solid ", ";\n  font-size: ", "px;\n  height: 32px;\n"], ["\n  width: 100%;\n  background: ", ";\n  color: ", ";\n  border: 1px solid ", ";\n  font-size: ", "px;\n  height: 32px;\n"])), function (props) { return props.theme.button.outlinedPrimaryBackground; }, function (props) { return props.theme.button.outlinedPrimaryForeground; }, function (props) { return props.theme.button.outlinedBorderColor; }, function (props) { return props.theme.measurements.fontSystem.button1.size; });
var templateObject_1$16;

var OutlinedSecondaryButton$1 = styled(BaseButton)(templateObject_1$17 || (templateObject_1$17 = __makeTemplateObject(["\n  width: 100%;\n  background: ", ";\n  color: ", ";\n  border: 1px solid ", ";\n  font-size: ", "px;\n  height: 32px;\n"], ["\n  width: 100%;\n  background: ", ";\n  color: ", ";\n  border: 1px solid ", ";\n  font-size: ", "px;\n  height: 32px;\n"])), function (props) { return props.theme.button.outlinedSecondaryBackground; }, function (props) { return props.theme.button.outlinedSecondaryForeground; }, function (props) { return props.theme.button.outlinedBorderColor; }, function (props) { return props.theme.measurements.fontSystem.button1.size; });
var templateObject_1$17;

var TextSecondaryButton$1 = styled(BaseButton)(templateObject_1$18 || (templateObject_1$18 = __makeTemplateObject(["\n  color: ", ";\n  font-size: ", "px;\n  height: 32px;\n  span.disabled {\n    display: none;\n  }\n  &:disabled,\n  &.disabled {\n    opacity: ", ";\n  }\n"], ["\n  color: ", ";\n  font-size: ", "px;\n  height: 32px;\n  span.disabled {\n    display: none;\n  }\n  &:disabled,\n  &.disabled {\n    opacity: ", ";\n  }\n"])), function (props) { return props.theme.button.textSecondaryForeground; }, function (props) { return props.theme.measurements.fontSystem.button1.size; }, function (props) { return props.theme.button.textInactiveOpacity; });
var templateObject_1$18;

var SmallCard = styled(BaseCard)(templateObject_1$19 || (templateObject_1$19 = __makeTemplateObject(["\n  width: ", "px;\n  height: ", "px;\n  margin-bottom: ", "px;\n  color: ", ";\n  &:nth-child(3n + 1),\n  &:nth-child(3n + 2) {\n    margin-right: ", "px;\n  }\n"], ["\n  width: ", "px;\n  height: ", "px;\n  margin-bottom: ", "px;\n  color: ", ";\n  &:nth-child(3n + 1),\n  &:nth-child(3n + 2) {\n    margin-right: ", "px;\n  }\n"])), function (props) { return props.theme.measurements.advancedCard.small.width; }, function (props) { return props.theme.measurements.advancedCard.small.height; }, function (props) { return props.theme.measurements.advancedSpacer; }, function (props) { return props.theme.card.foreground; }, function (props) { return props.theme.measurements.advancedSpacer; });
var templateObject_1$19;

var MediumCard = styled(BaseCard)(templateObject_1$1a || (templateObject_1$1a = __makeTemplateObject(["\n  width: ", "px;\n  height: ", "px;\n  margin-bottom: ", "px;\n  color: ", ";\n  &:nth-child(2n + 1) {\n    margin-right: ", "px;\n  }\n"], ["\n  width: ", "px;\n  height: ", "px;\n  margin-bottom: ", "px;\n  color: ", ";\n  &:nth-child(2n + 1) {\n    margin-right: ", "px;\n  }\n"])), function (props) { return props.theme.measurements.advancedCard.medium.width; }, function (props) { return props.theme.measurements.advancedCard.medium.height; }, function (props) { return props.theme.measurements.advancedSpacer; }, function (props) { return props.theme.card.foreground; }, function (props) { return props.theme.measurements.advancedSpacer; });
var templateObject_1$1a;

var LargeCard = styled(BaseCard)(templateObject_1$1b || (templateObject_1$1b = __makeTemplateObject(["\n  width: ", "px;\n  height: ", "px;\n  margin-bottom: ", "px;\n  color: ", ";\n"], ["\n  width: ", "px;\n  height: ", "px;\n  margin-bottom: ", "px;\n  color: ", ";\n"])), function (props) { return props.theme.measurements.advancedCard.large.width; }, function (props) { return props.theme.measurements.advancedCard.large.height; }, function (props) { return props.theme.measurements.advancedSpacer; }, function (props) { return props.theme.card.foreground; });
var templateObject_1$1b;

var Card = function (props) {
    var isLargeCard = props.type === CardType$1.LARGE;
    var isSmallCard = props.type === CardType$1.SMALL;
    var CardOfType = MediumCard;
    if (isLargeCard) {
        CardOfType = LargeCard;
    }
    else if (isSmallCard) {
        CardOfType = SmallCard;
    }
    return React.createElement(CardOfType, __assign({}, props));
};

var CardContainer = styled.div(templateObject_1$1c || (templateObject_1$1c = __makeTemplateObject(["\n  display: flex;\n  flex-wrap: wrap;\n"], ["\n  display: flex;\n  flex-wrap: wrap;\n"])));
var templateObject_1$1c;

var CardLabel = BaseCardLabel;

var ToolbarWrapper = styled.div(templateObject_3$n || (templateObject_3$n = __makeTemplateObject(["\n  z-index: ", ";\n  flex-shrink: 0;\n  background-color: ", ";\n  color: ", ";\n  ", "\n  width: ", "px;\n"], ["\n  z-index: ", ";\n  flex-shrink: 0;\n  background-color: ", ";\n  color: ", ";\n  ",
    "\n  width: ", "px;\n"])), function (props) { return props.theme.measurements.zIndex.toolbar; }, function (props) { return props.theme.toolbar.background; }, function (props) { return props.theme.toolbar.foreground; }, function (props) {
    return !props.reverse
        ? css(templateObject_1$1d || (templateObject_1$1d = __makeTemplateObject(["\n          border-right: 1px solid ", ";\n        "], ["\n          border-right: 1px solid ", ";\n        "])), props.theme.toolbar.borderColor) : css(templateObject_2$B || (templateObject_2$B = __makeTemplateObject(["\n          border-left: 1px solid ", ";\n        "], ["\n          border-left: 1px solid ", ";\n        "])), props.theme.toolbar.borderColor);
}, function (props) { return props.theme.measurements.advancedUIToolbar.width; });
var ToolbarList = styled.ul.attrs(function () { return ({
    role: 'menubar',
    'aria-label': 'Tool Navigation',
    'data-simplebar': 'init',
    'data-simplebar-auto-hide': 'false',
}); })(templateObject_4$e || (templateObject_4$e = __makeTemplateObject(["\n  margin: 0;\n  padding: 0;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  text-align: center;\n  list-style: none;\n  overflow-x: hidden;\n  overflow-y: overlay;\n  height: 100%;\n  .simplebar-content {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n"], ["\n  margin: 0;\n  padding: 0;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  text-align: center;\n  list-style: none;\n  overflow-x: hidden;\n  overflow-y: overlay;\n  height: 100%;\n  .simplebar-content {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n"])));
var Toolbar = /** @class */ (function (_super) {
    __extends(Toolbar, _super);
    function Toolbar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { reverse: false };
        return _this;
    }
    Toolbar.prototype.componentDidMount = function () {
        var element = document.getElementById('AdvancedToolbar');
        if (element) {
            var offsetLeft = element.offsetLeft;
            var windowHalfWidth = window.innerWidth / 2;
            if (offsetLeft > windowHalfWidth) {
                this.setState({ reverse: true });
            }
        }
    };
    Toolbar.prototype.render = function () {
        return (React.createElement(ToolbarWrapper, { reverse: this.state.reverse },
            React.createElement(ToolbarList, { id: "AdvancedToolbar" }, this.props.children(this.state.reverse))));
    };
    return Toolbar;
}(React.Component));
ToolbarWrapper.defaultProps = { theme: defaultStyledTheme };
ToolbarList.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$1d, templateObject_2$B, templateObject_3$n, templateObject_4$e;

var ItemLink = styled(TextSecondaryButton$1)(templateObject_3$o || (templateObject_3$o = __makeTemplateObject(["\n  width: inherit;\n  height: inherit;\n  color: inherit;\n  padding: 0;\n  margin: 0;\n  ", "\n"], ["\n  width: inherit;\n  height: inherit;\n  color: inherit;\n  padding: 0;\n  margin: 0;\n  ",
    "\n"])), isIE()
    ? css(templateObject_1$1e || (templateObject_1$1e = __makeTemplateObject(["\n        background-color: transparent;\n      "], ["\n        background-color: transparent;\n      "]))) : css(templateObject_2$C || (templateObject_2$C = __makeTemplateObject(["\n        background-color: inherit;\n      "], ["\n        background-color: inherit;\n      "]))));
var Item = styled.li.attrs({
    'aria-haspopup': true,
    'aria-hidden': true,
    role: 'menuitem',
})(templateObject_4$f || (templateObject_4$f = __makeTemplateObject(["\n  height: ", "px;\n  cursor: pointer;\n  position: relative;\n  ", " {\n    &:active,\n    &.active {\n      background-color: ", ";\n      color: ", ";\n    }\n  }\n"], ["\n  height: ", "px;\n  cursor: pointer;\n  position: relative;\n  ", " {\n    &:active,\n    &.active {\n      background-color: ", ";\n      color: ", ";\n    }\n  }\n"])), function (props) { return props.theme.measurements.advancedUIToolbar.itemHeight; }, ItemLink, function (props) { return props.theme.toolbar.activeBackground; }, function (props) { return props.theme.toolbar.activeForeground; });
var ToolbarItem = function (props) {
    var className = props.isActive ? 'active' : '';
    return (React.createElement(Item, { className: className },
        React.createElement(ItemLink, __assign({ "data-test-id": props.ariaLabel }, props))));
};
Item.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$1e, templateObject_2$C, templateObject_3$o, templateObject_4$f;

var EmptyItem = styled.li.attrs({
    role: 'none',
})(templateObject_1$1f || (templateObject_1$1f = __makeTemplateObject(["\n  height: ", "px;\n  cursor: pointer;\n  position: relative;\n"], ["\n  height: ", "px;\n  cursor: pointer;\n  position: relative;\n"])), function (props) { return props.theme.measurements.advancedUIToolbar.seperatorHeight; });
EmptyItem.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$1f;

var Root$4 = styled.div(templateObject_3$p || (templateObject_3$p = __makeTemplateObject(["\n  ", "\n  position: -ms-device-fixed;\n  top: ", "px;\n  left: ", "px;\n  z-index: ", ";\n  transition: opacity 0.5s ease-in-out, left 0.25s ease-in-out, right 0.25s ease-in-out, visibility 0.5s ease-in-out;\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n  cursor: pointer;\n  &:before {\n    content: ' ';\n    position: absolute;\n    top: 10px;\n    left: -8px;\n    width: 0;\n    height: 0;\n    border-right: 8px solid ", ";\n    border-bottom: 6px solid transparent;\n    border-top: 6px solid transparent;\n  }\n  &:after {\n    content: '", "';\n    position: absolute;\n    transition: margin-left 0.15s ease-in-out, opacity 0.15s ease-in-out;\n    color: ", ";\n    background: ", ";\n    padding: 8px 12px;\n    text-align: center;\n    vertical-align: super;\n    font-size: ", "px;\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    border-radius: ", "px;\n    white-space: nowrap;\n  }\n  &.reverse {\n    left: unset;\n    right: ", "px;\n    direction: rtl;\n    &:before {\n      border-left: 8px solid ", ";\n      border-right: unset;\n      right: -8px;\n      left: unset;\n      top: 10px;\n    }\n  }\n  &.show:not(.reverse) {\n    opacity: 1;\n    visibility: visible;\n    left: ", "px;\n  }\n  &.show.reverse {\n    opacity: 1;\n    visibility: visible;\n    right: ", "px;\n  }\n  span {\n    display: none;\n  }\n"], ["\n  ",
    "\n  position: -ms-device-fixed;\n  top: ", "px;\n  left: ", "px;\n  z-index: ", ";\n  transition: opacity 0.5s ease-in-out, left 0.25s ease-in-out, right 0.25s ease-in-out, visibility 0.5s ease-in-out;\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n  cursor: pointer;\n  &:before {\n    content: ' ';\n    position: absolute;\n    top: 10px;\n    left: -8px;\n    width: 0;\n    height: 0;\n    border-right: 8px solid ", ";\n    border-bottom: 6px solid transparent;\n    border-top: 6px solid transparent;\n  }\n  &:after {\n    content: '", "';\n    position: absolute;\n    transition: margin-left 0.15s ease-in-out, opacity 0.15s ease-in-out;\n    color: ", ";\n    background: ", ";\n    padding: 8px 12px;\n    text-align: center;\n    vertical-align: super;\n    font-size: ", "px;\n    letter-spacing: ", "px;\n    text-transform: ", ";\n    border-radius: ", "px;\n    white-space: nowrap;\n  }\n  &.reverse {\n    left: unset;\n    right: ", "px;\n    direction: rtl;\n    &:before {\n      border-left: 8px solid ", ";\n      border-right: unset;\n      right: -8px;\n      left: unset;\n      top: 10px;\n    }\n  }\n  &.show:not(.reverse) {\n    opacity: 1;\n    visibility: visible;\n    left: ", "px;\n  }\n  &.show.reverse {\n    opacity: 1;\n    visibility: visible;\n    right: ", "px;\n  }\n  span {\n    display: none;\n  }\n"])), isIE()
    ? css(templateObject_1$1g || (templateObject_1$1g = __makeTemplateObject(["\n          position: -ms-device-fixed;\n        "], ["\n          position: -ms-device-fixed;\n        "]))) : css(templateObject_2$D || (templateObject_2$D = __makeTemplateObject(["\n          position: fixed;\n        "], ["\n          position: fixed;\n        "]))), function (props) { return props.position.y - 5; }, function (props) { return props.position.x + props.theme.measurements.advancedUIToolbar.width - 10; }, function (props) { return props.theme.measurements.zIndex.toolbar; }, function (props) { return props.theme.tooltip.background; }, function (props) { return props.label; }, function (props) { return props.theme.tooltip.foreground; }, function (props) { return props.theme.tooltip.background; }, function (props) { return props.theme.measurements.fontSystem.label.size; }, function (props) { return props.theme.measurements.fontSystem.label.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.label.case; }, function (props) { return props.theme.shape.radiusSmall; }, function (props) { return props.position.x + props.theme.measurements.advancedUIToolbar.width - 10; }, function (props) { return props.theme.tooltip.background; }, function (props) { return props.position.x + props.theme.measurements.advancedUIToolbar.width + 16; }, function (props) { return props.position.x + props.theme.measurements.advancedUIToolbar.width + 16; });
var Tooltip = function (_a) {
    var show = _a.show, reverse = _a.reverse, position = _a.position, children = _a.children;
    var className = [show && 'show', reverse && 'reverse'].filter(Boolean).join(' ');
    var label = typeof children === 'string' ? children : '';
    return (React.createElement(Root$4, { "data-test-id": "Tooltip", className: className, position: position, label: label },
        React.createElement("span", null, label)));
};
Root$4.defaultProps = { theme: defaultStyledTheme };
Tooltip.defaultProps = {
    show: false,
};
var templateObject_1$1g, templateObject_2$D, templateObject_3$p;

var SidebarStyles = styled.div(templateObject_3$q || (templateObject_3$q = __makeTemplateObject(["\n  flex-shrink: 0;\n  height: 100%;\n  background: ", ";\n  position: relative;\n  overflow-x: hidden;\n  overflow-y: hidden;\n  width: 0;\n  display: flex;\n  flex-direction: column;\n  transition: width 0.4s ease-in;\n  &.open {\n    width: ", "px;\n  }\n  ", "\n  z-index: ", ";\n  /* for Firefox */\n  min-height: 0;\n"], ["\n  flex-shrink: 0;\n  height: 100%;\n  background: ", ";\n  position: relative;\n  overflow-x: hidden;\n  overflow-y: hidden;\n  width: 0;\n  display: flex;\n  flex-direction: column;\n  transition: width 0.4s ease-in;\n  &.open {\n    width: ", "px;\n  }\n  ",
    "\n  z-index: ", ";\n  /* for Firefox */\n  min-height: 0;\n"])), function (props) { return props.theme.toolControlBar.background; }, function (props) { return props.theme.measurements.advancedToolControlBar.width; }, function (props) {
    return !props.reverse
        ? css(templateObject_1$1h || (templateObject_1$1h = __makeTemplateObject(["\n          border-right: 1px solid ", ";\n        "], ["\n          border-right: 1px solid ", ";\n        "])), props.theme.toolControlBar.borderColor) : css(templateObject_2$E || (templateObject_2$E = __makeTemplateObject(["\n          border-left: 1px solid ", ";\n        "], ["\n          border-left: 1px solid ", ";\n        "])), props.theme.toolControlBar.borderColor);
}, function (props) { return props.theme.measurements.zIndex.toolControlBar; });
var Sidebar = /** @class */ (function (_super) {
    __extends(Sidebar, _super);
    function Sidebar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { reverse: false };
        return _this;
    }
    Sidebar.prototype.componentDidMount = function () {
        var element = document.getElementById('Sidebar');
        if (element) {
            var offsetLeft = element.offsetLeft;
            var windowHalfWidth = window.innerWidth / 2;
            if (offsetLeft > windowHalfWidth) {
                this.setState({ reverse: true });
            }
        }
    };
    Sidebar.prototype.render = function () {
        return (React.createElement(SidebarStyles, { id: "Sidebar", reverse: this.state.reverse, className: "open" }, this.props.children));
    };
    return Sidebar;
}(React.Component));
var templateObject_1$1h, templateObject_2$E, templateObject_3$q;

var Title = styled.h1(templateObject_1$1i || (templateObject_1$1i = __makeTemplateObject(["\n  flex-grow: 0;\n  width: 100%;\n  padding: 0;\n  margin: 0;\n  height: ", "px;\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  background: ", ";\n  color: ", ";\n  border-bottom: 1px solid ", ";\n  text-align: center;\n  font-weight: 500;\n  line-height: 48px;\n"], ["\n  flex-grow: 0;\n  width: 100%;\n  padding: 0;\n  margin: 0;\n  height: ", "px;\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  background: ", ";\n  color: ", ";\n  border-bottom: 1px solid ", ";\n  text-align: center;\n  font-weight: 500;\n  line-height: 48px;\n"])), function (props) { return props.theme.measurements.mainCanvasActionBar.height - 2; }, function (props) { return props.theme.measurements.fontSystem.headline1.size; }, function (props) { return props.theme.measurements.fontSystem.headline1.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.headline1.case; }, function (props) { return props.theme.toolControlBar.background; }, function (props) { return props.theme.toolControlBar.titleForeground; }, function (props) { return props.theme.toolControlBar.separatorColor; });
Title.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$1i;

var FixedContentStyles = styled.div(templateObject_1$1j || (templateObject_1$1j = __makeTemplateObject(["\n  position: relative;\n  flex-grow: 0;\n  flex-shrink: 0;\n  height: ", "px;\n  opacity: ", ";\n  visibility: ", ";\n  overflow: ", ";\n  transition: ", ";\n  background: ", ";\n  color: ", ";\n  &.overflow {\n    overflow: visible;\n  }\n"], ["\n  position: relative;\n  flex-grow: 0;\n  flex-shrink: 0;\n  height: ", "px;\n  opacity: ", ";\n  visibility: ", ";\n  overflow: ", ";\n  transition: ",
    ";\n  background: ", ";\n  color: ", ";\n  &.overflow {\n    overflow: visible;\n  }\n"
    /* eslint-disable */
])), function (_a) {
    var height = _a.height;
    return height;
}, function (_a) {
    var opacity = _a.opacity;
    return opacity;
}, function (_a) {
    var visibility = _a.visibility;
    return visibility;
}, function (_a) {
    var shoulAnimateOverflow = _a.shoulAnimateOverflow;
    return (shoulAnimateOverflow ? 'hidden' : 'visible');
}, function (_a) {
    var shouldAnimateHeight = _a.shouldAnimateHeight;
    return shouldAnimateHeight ? "opacity 0.5s ease-in, height 0.4s ease-out" : "opacity 0.5s ease-in";
}, function (props) { return props.theme.toolControlBar.background; }, function (props) { return props.theme.toolControlBar.inputLabelForeground; });
/* eslint-disable */
var Inner$1 = styled.div(templateObject_2$F || (templateObject_2$F = __makeTemplateObject(["\n  position: relative;\n  padding: ", ";\n"], ["\n  position: relative;\n  padding: ", ";\n"])), function (props) { return props.theme.measurements.advancedToolControlBar.padding; });
var FixedContent = /** @class */ (function (_super) {
    __extends(FixedContent, _super);
    function FixedContent(props) {
        var _this = _super.call(this, props) || this;
        _this.contentRef = null;
        _this.overflow = function () {
            var show = _this.props.show;
            if (show && _this.contentRef.current) {
                _this.contentRef.current.classList.add('overflow');
            }
        };
        _this.contentRef = React.createRef();
        _this.state = {
            height: 0,
            mounted: false,
        };
        return _this;
    }
    FixedContent.prototype.componentDidMount = function () {
        var overflowAfterExpand = this.props.overflowAfterExpand;
        if (this.contentRef.current) {
            if (overflowAfterExpand) {
                this.contentRef.current.addEventListener('transitionend', this.overflow);
            }
            this.setState({
                height: this.contentRef.current.scrollHeight,
                // only show trigger the animation if the component is mounted, else opacity and visibility will not be visible
                mounted: true,
            });
        }
    };
    FixedContent.prototype.componentWillUnmount = function () {
        if (this.contentRef.current) {
            this.contentRef.current.removeEventListener('transitionend', this.overflow);
        }
    };
    FixedContent.prototype.render = function () {
        var _a = this.props, show = _a.show, shoulAnimateOverflow = _a.shoulAnimateOverflow, shouldAnimateHeight = _a.shouldAnimateHeight, className = _a.className, children = _a.children;
        var _b = this.state, height = _b.height, mounted = _b.mounted;
        var showContent = mounted && ((show && shoulAnimateOverflow) || !shoulAnimateOverflow);
        var elementHeight = showContent ? height : 0;
        var opacity = showContent ? 1 : 0;
        var visibility = showContent ? 'visible' : 'hidden';
        return (React.createElement(FixedContentStyles, { "data-test-id": "ToolControlBar", ref: this.contentRef, height: elementHeight, opacity: opacity, visibility: visibility, className: className, shouldAnimateHeight: shouldAnimateHeight, shoulAnimateOverflow: shoulAnimateOverflow },
            React.createElement(Inner$1, null, children)));
    };
    FixedContent.defaultProps = {
        show: true,
        shoulAnimateOverflow: true,
        shouldAnimateHeight: true,
    };
    return FixedContent;
}(React.Component));
FixedContentStyles.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$1j, templateObject_2$F;

/* eslint-disable */
/**
 * Note:
 * Keep the padding here as multiples of spacer as
 * Card width depends on these calculations
 *
 * Using width 100% doesn't work well with flexbox and simplebar
 */
var ScrollableContent = styled.div.attrs({
    'data-simplebar': 'init',
    'data-simplebar-auto-hide': 'false',
})(templateObject_1$1k || (templateObject_1$1k = __makeTemplateObject(["\n  flex-grow: 1;\n  position: relative;\n  box-sizing: border-box;\n  padding: ", ";\n  width: ", "px;\n  overflow: visible;\n  /* for Firefox */\n  min-height: 0;\n  transition: height 0.4s cubic-bezier(0.17, 0.04, 0.03, 0.94);\n  background: ", ";\n  color: ", ";\n\n  ", "\n  .simplebar-placeholder {\n    height: 0px !important;\n  }\n"], ["\n  flex-grow: 1;\n  position: relative;\n  box-sizing: border-box;\n  padding: ", ";\n  width: ", "px;\n  overflow: visible;\n  /* for Firefox */\n  min-height: 0;\n  transition: height 0.4s cubic-bezier(0.17, 0.04, 0.03, 0.94);\n  background: ", ";\n  color: ", ";\n\n  ", "\n  .simplebar-placeholder {\n    height: 0px !important;\n  }\n"
    /* eslint-enable */
])), function (props) { return props.theme.measurements.advancedToolControlBar.padding; }, function (props) { return (props.theme.measurements.advancedToolControlBar.width); }, function (props) { return props.theme.toolControlBar.background; }, function (props) { return props.theme.toolControlBar.inputLabelForeground; }, States.HiddenScrollbar);
ScrollableContent.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$1k;

var SubHeading = styled.h2(templateObject_1$1l || (templateObject_1$1l = __makeTemplateObject(["\n  color: ", ";\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  font-weight: 500;\n  height: ", "px;\n  line-height: ", "px;\n"], ["\n  color: ", ";\n  font-size: ", "px;\n  letter-spacing: ", "px;\n  text-transform: ", ";\n  font-weight: 500;\n  height: ", "px;\n  line-height: ", "px;\n"])), function (props) { return props.theme.toolControlBar.titleForeground; }, function (props) { return props.theme.measurements.fontSystem.headline2.size; }, function (props) { return props.theme.measurements.fontSystem.headline2.letterSpacing; }, function (props) { return props.theme.measurements.fontSystem.headline2.case; }, function (props) { return 2 * props.theme.measurements.advancedSpacer; }, function (props) { return 2 * props.theme.measurements.advancedSpacer; });
SubHeading.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$1l;

var Separator = styled.div(templateObject_2$G || (templateObject_2$G = __makeTemplateObject(["\n  &:after {\n    content: '';\n    position: absolute;\n    bottom: 0px;\n    ", "\n    border-bottom: 2px solid ", ";\n  }\n"], ["\n  &:after {\n    content: '';\n    position: absolute;\n    bottom: 0px;\n    ",
    "\n    border-bottom: 2px solid ", ";\n  }\n"])), function (props) {
    return props.full
        ? css(templateObject_1$1m || (templateObject_1$1m = __makeTemplateObject(["\n            left: -", "px;\n            width: calc(100% + ", "px);\n          "], ["\n            left: -", "px;\n            width: calc(100% + ", "px);\n          "])), (3 * props.theme.measurements.advancedSpacer) / 2, 3 * props.theme.measurements.advancedSpacer) : "\n      left: " + (3 * props.theme.measurements.advancedSpacer) / 2 + "px;\n      width: calc(100% - " + 3 * props.theme.measurements.advancedSpacer + "px);\n    ";
}, function (props) { return props.theme.toolControlBar.separatorColor; });
Separator.defaultProps = { theme: defaultStyledTheme };
var templateObject_1$1m, templateObject_2$G;

var AdvancedUIComponents = {
    Card: Card,
    CardContainer: CardContainer,
    CardLabel: CardLabel,
    Toolbar: {
        Index: Toolbar,
        Item: ToolbarItem,
        Separator: EmptyItem,
        Tooltip: Tooltip,
    },
    Button: {
        OutlinedSecondary: OutlinedSecondaryButton$1,
        OutlinedPrimary: OutlinedPrimaryButton,
        TextSecondary: TextSecondaryButton$1,
    },
    Itemsbar: ScrollableContent,
    BarSeparator: '',
    ItemsSeparator: Separator,
    Controlsbar: FixedContent,
    Sidebar: {
        Index: Sidebar,
        Heading: Title,
        SubHeading: SubHeading,
    },
};

var ToolbarItem$1 = /** @class */ (function (_super) {
    __extends(ToolbarItem, _super);
    function ToolbarItem(props) {
        var _this = _super.call(this, props) || this;
        _this.ref = null;
        _this.updatePosition = function () {
            var isReverse = _this.props.isReverse;
            var tooltipPosition = { x: 0, y: 0 };
            if (_this.ref.current) {
                var _a = _this.ref.current.getBoundingClientRect(), top_1 = _a.top, height = _a.height, left = _a.left, right = _a.right;
                tooltipPosition.y = top_1 + height / 4;
                tooltipPosition.x = isReverse ? window.innerWidth - right : left;
            }
            _this.setState({ tooltipPosition: tooltipPosition });
        };
        _this.mouseOver = function (tool) {
            _this.updatePosition();
            _this.setState({ hoverTool: tool });
        };
        _this.mouseOut = function () {
            _this.setState({ hoverTool: null });
        };
        _this.state = {
            hoverTool: null,
            tooltipPosition: { x: 0, y: 0 },
        };
        _this.ref = React.createRef();
        return _this;
    }
    ToolbarItem.prototype.componentDidMount = function () {
        this.updatePosition();
    };
    ToolbarItem.prototype.componentDidUpdate = function (prevProps) {
        var isReverse = this.props.isReverse;
        if (isReverse !== prevProps.isReverse) {
            this.updatePosition();
        }
    };
    ToolbarItem.prototype.render = function () {
        var _this = this;
        var _a = this.props, tool = _a.tool, isActive = _a.isActive, isReverse = _a.isReverse, icon = _a.icon, label = _a.label, onClick = _a.onClick;
        var _b = this.state, hoverTool = _b.hoverTool, tooltipPosition = _b.tooltipPosition;
        return (React.createElement(RelativeDiv, { ref: this.ref, onMouseOver: function () { return _this.mouseOver(tool); }, onMouseOut: function () { return _this.mouseOut(); } },
            React.createElement(AdvancedUIComponents.Toolbar.Item, { ariaLabel: label, isActive: isActive, onClick: function () { return onClick(tool); } }, icon),
            React.createElement(AdvancedUIComponents.Toolbar.Tooltip, { position: tooltipPosition, reverse: isReverse, show: hoverTool === tool }, label)));
    };
    return ToolbarItem;
}(React.Component));
var RelativeDiv = styled.div(templateObject_1$1n || (templateObject_1$1n = __makeTemplateObject(["\n  position: relative;\n"], ["\n  position: relative;\n"])));
var templateObject_1$1n;

var ToolbarItemWrapper = /** @class */ (function (_super) {
    __extends(ToolbarItemWrapper, _super);
    function ToolbarItemWrapper() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.renderIcon = function (toolName) {
            var ToolIcon = ToolbarIcons[toolName];
            return React.createElement(ToolIcon, null) || null;
        };
        _this.update = function (tool) {
            _this.props.active.selectTool(tool);
        };
        return _this;
    }
    ToolbarItemWrapper.prototype.getToolTitle = function (tool) {
        return this.props.config.locale[tool].title;
    };
    ToolbarItemWrapper.prototype.render = function () {
        var activeTool = this.props.active.tool;
        var tool = this.props.tool;
        if (tool) {
            var item = this.props.custom.getAdvancedToolbarItem({
                isActive: tool === activeTool,
                isReverse: this.props.isReverse,
                icon: this.renderIcon(tool),
                onClick: this.update.bind(this, tool),
                tool: tool,
                label: this.getToolTitle(tool),
            });
            return item;
        }
        return React.createElement(AdvancedUIComponents.Toolbar.Separator, null);
    };
    ToolbarItemWrapper = __decorate([
        inject('active', 'config', 'custom'),
        observer
    ], ToolbarItemWrapper);
    return ToolbarItemWrapper;
}(React.Component));

var ToolBarComponent = /** @class */ (function (_super) {
    __extends(ToolBarComponent, _super);
    function ToolBarComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.renderTools = function (isReverse) {
            return _this.props.config.tools.map(function (tool, index) { return (React.createElement(ToolbarItemWrapper, { key: tool || index, tool: tool, isReverse: isReverse })); });
        };
        return _this;
    }
    ToolBarComponent.prototype.render = function () {
        return React.createElement(AdvancedUIComponents.Toolbar.Index, null, this.renderTools);
    };
    ToolBarComponent = __decorate([
        inject('config'),
        observer
    ], ToolBarComponent);
    return ToolBarComponent;
}(React.Component));

var Controls = function (_a) {
    var library = _a.library, active = _a.active;
    var placeholderSearch = library.locale.controls.placeholderSearch;
    var _b = library, config = _b.config, libraryProvider = _b.libraryProvider;
    var onFilesAdded = function (e) {
        var files = e.target.files;
        if (files.length) {
            var reader = new FileReader();
            reader.onload = function (evt) {
                active.newImage(evt.target.result);
            };
            reader.readAsDataURL(files[0]);
        }
    };
    var onWebcamClick = function () {
        active.selectWebcam(true);
    };
    var uploadImage = function () {
        var input = document.getElementById('fileUpload');
        if (input) {
            input.click();
        }
    };
    var uploadButton = function () {
        return config.enableUpload ? (React.createElement(AdvancedUIComponents.Button.OutlinedPrimary, { ariaLabel: library.locale.controls.buttonUpload, onClick: uploadImage },
            library.locale.controls.buttonUpload,
            React.createElement(Components.Input.File, { onChange: onFilesAdded }))) : null;
    };
    var WebcamButton = function () {
        return config.enableWebcam ? (React.createElement(AdvancedUIComponents.Button.OutlinedSecondary, { ariaLabel: library.locale.controls.buttonWebcamOpen, onClick: onWebcamClick }, library.locale.controls.buttonWebcamOpen)) : null;
    };
    var fetchImages = function (query) {
        library.fetchImages(query);
    };
    return (React.createElement(AdvancedUIComponents.Controlsbar, { shouldAnimateHeight: false, shoulAnimateOverflow: false },
        React.createElement(Components.Spacer, null),
        libraryProvider ? (React.createElement(React.Fragment, null,
            React.createElement(Components.Input.Search, { onChange: fetchImages, placeholder: placeholderSearch }),
            React.createElement(Components.Spacer, { count: 2 }))) : null,
        uploadButton(),
        React.createElement(Components.Spacer, null),
        WebcamButton(),
        React.createElement(AdvancedUIComponents.ItemsSeparator, null)));
};
var LibraryControls = inject('library', 'active')(observer(Controls));

var Div$2 = styled.div(templateObject_3$r || (templateObject_3$r = __makeTemplateObject(["\n  transition: max-height 0.8s ease-out, transform 0.8s ease-out;\n  background: ", ";\n  visibility: hidden;\n  opacity: 0;\n  display: none;\n  flex-wrap: wrap;\n  &.show {\n    opacity: 1;\n    visibility: visible;\n    ", "\n  }\n"], ["\n  transition: max-height 0.8s ease-out, transform 0.8s ease-out;\n  background: ", ";\n  visibility: hidden;\n  opacity: 0;\n  display: none;\n  flex-wrap: wrap;\n  &.show {\n    opacity: 1;\n    visibility: visible;\n    ",
    "\n  }\n"])), function (props) { return props.theme.toolControlBar.background; }, isIE()
    ? css(templateObject_1$1o || (templateObject_1$1o = __makeTemplateObject(["\n          display: block;\n        "], ["\n          display: block;\n        "]))) : css(templateObject_2$H || (templateObject_2$H = __makeTemplateObject(["\n          display: flex;\n        "], ["\n          display: flex;\n        "]))));
var Items = function (_a) {
    var active = _a.active, library = _a.library, custom = _a.custom;
    var _b = library, query = _b.query, selectedCategoryIdentifier = _b.selectedCategoryIdentifier, categories = _b.categories, images = _b.images;
    var onImageClick = function (identifier) {
        active.newImage(identifier);
    };
    var onCatgoryClick = function (categoryIdentifier) {
        library.toggleCategorySelection(categoryIdentifier);
    };
    var renderItemCard = function (card, index) {
        return custom.getAdvancedOptionCard({
            tool: Tool.LIBRARY,
            type: CardType.MEDIUM,
            onClick: function () { return onImageClick(card.identifier); },
            key: card.identifier,
            image: card.coverImage,
            label: card.defaultName,
            style: { animationDelay: index * 0.08 + "s" },
            children: React.createElement(AdvancedUIComponents.CardLabel, { hidden: true }, card.defaultName),
        });
    };
    var renderCategoryCard = function (card) {
        var isActive = selectedCategoryIdentifier === card.identifier;
        return (React.createElement("div", { key: card.identifier },
            custom.getAdvancedCategoryCard({
                tool: Tool.LIBRARY,
                type: CardType.LARGE,
                onClick: function () { return onCatgoryClick(card.identifier); },
                image: card.coverImage,
                label: card.defaultName,
                style: { animationDelay: (card.delay || 0) + "s" },
                children: (React.createElement(AdvancedUIComponents.CardLabel, { withBackground: true, caret: true, isActive: isActive }, card.defaultName)),
            }),
            React.createElement(Div$2, { className: isActive ? 'show' : '', key: card.identifier + "-items" }, card.items.map(renderItemCard))));
    };
    var noResults = library.locale.controls.noResults;
    var renderImages = function () {
        return images.length ? images.map(renderItemCard) : React.createElement("p", null, noResults);
    };
    return (React.createElement(AdvancedUIComponents.Itemsbar, null,
        React.createElement(AdvancedUIComponents.CardContainer, null, query ? renderImages() : categories.map(renderCategoryCard))));
};
var LibraryItems = inject('library', 'active', 'custom')(observer(Items));
var templateObject_1$1o, templateObject_2$H, templateObject_3$r;

var LibraryOptionsBar = function (_a) {
    var library = _a.library;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, library.locale.title),
        React.createElement(LibraryControls, null),
        React.createElement(LibraryItems, null)));
};
var LibraryOptionsBar$1 = inject('library')(observer(LibraryOptionsBar));

var Controls$1 = function (_a) {
    var filterTool = _a.filterTool;
    var labels = filterTool.locale.controls;
    var state = filterTool.state;
    var onRelease = function () {
        filterTool.toolSnapshot();
    };
    var onResetClick = function () {
        filterTool.reset();
    };
    return (React.createElement(AdvancedUIComponents.Controlsbar, { show: filterTool.isOptionSelected },
        React.createElement(Components.Input.Form, null,
            React.createElement(AdvancedUIComponents.Button.OutlinedSecondary, { ariaLabel: labels.buttonReset, onClick: onResetClick }, labels.buttonReset),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Slider, { "aria-hidden": !filterTool.isOptionSelected, name: labels.sliderIntensity, value: state.intensity, min: 0, max: 1, onChange: filterTool.changeIntensity, onMouseUp: onRelease, onTouchEnd: onRelease, snap: state.isDuotone ? 0.5 : null }),
            React.createElement(Components.Spacer, null)),
        React.createElement(AdvancedUIComponents.ItemsSeparator, null)));
};
var FilterControls = inject('filterTool')(observer(Controls$1));

var Div$3 = styled.div(templateObject_3$s || (templateObject_3$s = __makeTemplateObject(["\n  background: ", ";\n  visibility: hidden;\n  opacity: 0;\n  transform-origin: 0 0;\n  display: none;\n  flex-wrap: wrap;\n  &.show {\n    opacity: 1;\n    visibility: visible;\n    ", "\n  }\n"], ["\n  background: ", ";\n  visibility: hidden;\n  opacity: 0;\n  transform-origin: 0 0;\n  display: none;\n  flex-wrap: wrap;\n  &.show {\n    opacity: 1;\n    visibility: visible;\n    ",
    "\n  }\n"])), function (props) { return props.theme.toolControlBar.background; }, isIE()
    ? css(templateObject_1$1p || (templateObject_1$1p = __makeTemplateObject(["\n          display: block;\n        "], ["\n          display: block;\n        "]))) : css(templateObject_2$I || (templateObject_2$I = __makeTemplateObject(["\n          display: flex;\n        "], ["\n          display: flex;\n        "]))));
var Items$1 = /** @class */ (function (_super) {
    __extends(Items, _super);
    function Items() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { displayStyle: 'none' };
        _this.onFilterCilck = function (filter) {
            _this.filterTool.selectFilter(filter.identifier, filter.defaultIntensity);
        };
        _this.onCatgoryClick = function (id) {
            _this.filterTool.toggleCategorySelection(id);
        };
        _this.renderItemCard = function (card) {
            return _this.custom.getAdvancedOptionCard({
                tool: Tool.FILTER,
                type: CardType.MEDIUM,
                onClick: function () { return _this.onFilterCilck(card); },
                key: card.identifier,
                image: card.thumbnail || card.thumbnailURI,
                label: card.name || card.name,
                style: { animationDelay: (card.delay || 0) + "s" },
                isActive: _this.filterTool.identifier === card.identifier,
                children: React.createElement(AdvancedUIComponents.CardLabel, { withBackground: true }, card.name),
            });
        };
        _this.renderCategoryCard = function (card) {
            var selectedCategoryIdentifier = _this.filterTool.selectedCategoryIdentifier;
            var isActive = selectedCategoryIdentifier === card.identifier;
            return (React.createElement("div", { key: card.identifier },
                _this.custom.getAdvancedCategoryCard({
                    tool: Tool.FILTER,
                    type: CardType.LARGE,
                    onClick: function () { return _this.onCatgoryClick(card.identifier); },
                    image: card.thumbnailURI,
                    label: card.name || card.name,
                    style: { animationDelay: (card.delay || 0) + "s" },
                    children: (React.createElement(AdvancedUIComponents.CardLabel, { withBackground: true, caret: true, isActive: isActive }, card.name)),
                }),
                React.createElement(Div$3, { className: isActive ? 'show' : '' }, card.items.map(_this.renderItemCard))));
        };
        return _this;
    }
    Object.defineProperty(Items.prototype, "filterTool", {
        get: function () {
            return this.props.filterTool;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Items.prototype, "custom", {
        get: function () {
            return this.props.custom;
        },
        enumerable: true,
        configurable: true
    });
    Items.prototype.render = function () {
        var _a = this.filterTool, categories = _a.categories, flattenCategories = _a.flattenCategories, entities = _a.entities;
        return (React.createElement(AdvancedUIComponents.Itemsbar, { key: "filterToolItemsbar" },
            React.createElement(AdvancedUIComponents.CardContainer, null, flattenCategories ? entities.map(this.renderItemCard) : categories.map(this.renderCategoryCard))));
    };
    return Items;
}(React.Component));
var FilterItems = inject('filterTool', 'custom')(observer(Items$1));
var templateObject_1$1p, templateObject_2$I, templateObject_3$s;

var FilterOptionsBar = function (_a) {
    var filterTool = _a.filterTool;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, filterTool.locale.title),
        React.createElement(FilterControls, null),
        React.createElement(FilterItems, null)));
};
var FilterOptionsBar$1 = inject('filterTool')(observer(FilterOptionsBar));

var Controls$2 = function (_a) {
    var focusTool = _a.focusTool;
    var labels = focusTool.locale.controls;
    var onRelease = function () {
        focusTool.toolSnapshot(labels.sliderIntensity);
    };
    var onResetClick = function () {
        focusTool.reset();
    };
    return (React.createElement(AdvancedUIComponents.Controlsbar, { show: focusTool.isOptionSelected },
        React.createElement(Components.Input.Form, null,
            React.createElement(AdvancedUIComponents.Button.OutlinedSecondary, { ariaLabel: labels.buttonReset, onClick: onResetClick }, labels.buttonReset),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Slider, { "aria-hidden": !focusTool.isOptionSelected, name: labels.sliderIntensity, value: focusTool.intensity, min: FocusToolStore.minIntensity, max: focusTool.maxIntensity, divider: 1, onChange: focusTool.changeIntensity, onMouseUp: onRelease, onTouchEnd: onRelease })),
        React.createElement(Components.Spacer, { count: 1 }),
        React.createElement(AdvancedUIComponents.ItemsSeparator, null)));
};
var FocusControls = inject('focusTool')(observer(Controls$2));

var Items$2 = function (_a) {
    var focusTool = _a.focusTool, custom = _a.custom;
    var entities = focusTool.entities;
    var renderFocusOption = function (option) {
        return custom.getAdvancedOptionCard({
            tool: Tool.FOCUS,
            type: CardType.LARGE,
            onClick: function () { return focusTool.selectFocus(option.identifier); },
            key: option.identifier,
            image: option.thumbnailURI,
            isActive: option.identifier === focusTool.identifier,
            label: option.name || option.name,
            style: { animationDelay: (option.delay || 0) + "s" },
            children: React.createElement(AdvancedUIComponents.CardLabel, { withBackground: true }, option.name),
        });
    };
    return (React.createElement(AdvancedUIComponents.Itemsbar, null,
        React.createElement(AdvancedUIComponents.CardContainer, null, entities.map(renderFocusOption))));
};
var FocusItems = inject('focusTool', 'custom')(observer(Items$2));

var FocusOptionsBar = function (_a) {
    var focusTool = _a.focusTool;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, focusTool.locale.title),
        React.createElement(FocusControls, null),
        React.createElement(FocusItems, null)));
};
var FocusOptionsBar$1 = inject('focusTool')(observer(FocusOptionsBar));

var Items$3 = function (_a) {
    var adjustmentsTool = _a.adjustmentsTool;
    var _b = adjustmentsTool, categories = _b.categories, allItems = _b.items, config = _b.config;
    var onRelease = function () {
        adjustmentsTool.toolSnapshot();
    };
    var edit = function (type, value) {
        adjustmentsTool.editAdjustments({ type: type, value: value });
    };
    var renderEntities = function (item) { return (React.createElement("div", { key: item.identifier },
        React.createElement(Components.Input.Slider, { adjust: true, key: item.identifier, name: item.name, value: adjustmentsTool[item.identifier], onChange: function (value) { return edit(item.identifier, value); }, onMouseUp: onRelease, onTouchEnd: onRelease, snap: 0 }),
        React.createElement(Components.Spacer, { count: 2 }))); };
    var getCategories = function (category, index) {
        return (category.items && (React.createElement("div", { style: { position: 'relative' }, key: category.identifier },
            index !== 0 ? React.createElement(Components.Spacer, { count: 2 }) : null,
            React.createElement(AdvancedUIComponents.Sidebar.SubHeading, null, category.name),
            category.items.map(renderEntities),
            React.createElement(Components.Spacer, { count: 2 }),
            index !== categories.length - 1 ? React.createElement(AdvancedUIComponents.ItemsSeparator, { full: true }) : null))) ||
            null;
    };
    var getItems = function (items) { return React.createElement("div", { style: { position: 'relative' } }, items.map(renderEntities)); };
    return (React.createElement(AdvancedUIComponents.Itemsbar, null, config.flattenCategories ? (getItems(allItems)) : (React.createElement(React.Fragment, null,
        categories.map(getCategories),
        getItems(categories.filter(function (t) { return !t.items; }))))));
};
var AdjustItems = inject('adjustmentsTool')(observer(Items$3));

var Controls$3 = function (_a) {
    var adjustmentsTool = _a.adjustmentsTool;
    var labels = adjustmentsTool.locale.controls;
    var onResetClick = function () {
        adjustmentsTool.reset();
    };
    return (React.createElement(AdvancedUIComponents.Controlsbar, { show: adjustmentsTool.isDirty },
        React.createElement(AdvancedUIComponents.Button.OutlinedSecondary, { ariaLabel: labels.buttonReset, onClick: onResetClick }, labels.buttonReset),
        React.createElement(AdvancedUIComponents.ItemsSeparator, null)));
};
var AdjustControls = inject('adjustmentsTool')(observer(Controls$3));

var AdjustOptionsBar = function (_a) {
    var adjustmentsTool = _a.adjustmentsTool;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, adjustmentsTool.locale.title),
        React.createElement(AdjustControls, null),
        React.createElement(AdjustItems, null)));
};
var AdjustOptionsBar$1 = inject('adjustmentsTool')(observer(AdjustOptionsBar));

var Controls$4 = function (_a) {
    var overlayTool = _a.overlayTool;
    var labels = overlayTool.locale.controls;
    var allBlendModes = overlayTool.allBlendModes;
    var blendMode = overlayTool.blendMode;
    var onRelease = function () {
        overlayTool.toolSnapshot();
    };
    var changeBlendMode = function (newBlendMode) {
        overlayTool.changeBlendMode(newBlendMode);
    };
    var onResetClick = function () {
        overlayTool.reset();
    };
    return (React.createElement(AdvancedUIComponents.Controlsbar, { show: overlayTool.isOptionSelected },
        React.createElement(AdvancedUIComponents.Button.OutlinedSecondary, { ariaLabel: labels.buttonReset, onClick: onResetClick }, labels.buttonReset),
        React.createElement(Components.Spacer, { count: 2 }),
        React.createElement(Components.Input.CarouselSlider, { label: labels.carouselBlendMode, defaultIdentifier: blendMode, onSelect: changeBlendMode, list: allBlendModes }),
        React.createElement(Components.Spacer, { count: 2 }),
        React.createElement(Components.Input.Slider, { "aria-hidden": !overlayTool.isOptionSelected, name: labels.sliderOpacity, value: overlayTool.opacity, min: 0, max: 1, onChange: overlayTool.changeOpacity, onMouseUp: onRelease, onTouchEnd: onRelease }),
        React.createElement(Components.Spacer, null),
        React.createElement(AdvancedUIComponents.ItemsSeparator, null)));
};
var OverlayControls = inject('overlayTool')(observer(Controls$4));

var Items$4 = function (_a) {
    var overlayTool = _a.overlayTool, custom = _a.custom;
    var renderOverlay = function (option) {
        return custom.getAdvancedOptionCard({
            tool: Tool.OVERLAY,
            type: CardType.MEDIUM,
            image: option.thumbnailURI,
            onClick: function () { return overlayTool.selectOverlay(option.identifier); },
            key: option.identifier,
            isActive: option.identifier === overlayTool.identifier,
            label: option.name,
            style: { animationDelay: (option.delay || 0) + "s" },
            children: React.createElement(AdvancedUIComponents.CardLabel, { withBackground: true }, option.name),
        });
    };
    return (React.createElement(AdvancedUIComponents.Itemsbar, null,
        React.createElement(AdvancedUIComponents.CardContainer, null, overlayTool.entities.map(renderOverlay))));
};
var OverlayItems = inject('overlayTool', 'custom')(observer(Items$4));

var OverlayOptionsBar = function (_a) {
    var overlayTool = _a.overlayTool;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, overlayTool.locale.title),
        React.createElement(OverlayControls, null),
        React.createElement(OverlayItems, null)));
};
var OverlayOptionsBar$1 = inject('overlayTool')(observer(OverlayOptionsBar));

var FileInput = styled.input.attrs({
    type: 'file',
    id: 'fileUpload',
    accept: 'image/*',
    multiple: true,
})(templateObject_1$1q || (templateObject_1$1q = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), States.VisuallyHidden);
var Controls$5 = function (_a) {
    var stickerTool = _a.stickerTool;
    var labels = stickerTool.locale.controls;
    var labelsColor = stickerTool.localeColor.colorPicker;
    var colorList = StickerToolStore.defaultColors;
    var tintColor = stickerTool.activeTintColor;
    var onRelease = function () {
        stickerTool.toolSnapshot();
    };
    var onUploadClick = function () {
        var input = document.getElementById('fileUpload');
        if (input) {
            input.value = null;
            input.click();
        }
    };
    var onFilesAdded = function (e) {
        var files = e.target.files;
        stickerTool.addFiles(files);
    };
    var getCustomStickerButton = function () {
        if (stickerTool.isCustomStickerEnabled) {
            return (React.createElement(AdvancedUIComponents.Button.OutlinedPrimary, { ariaLabel: labels.buttonUpload, onClick: onUploadClick },
                labels.buttonUpload,
                React.createElement(FileInput, { onChange: onFilesAdded })));
        }
        return null;
    };
    var isDisabled = !stickerTool.isStickerSelected || (!stickerTool.tintable && stickerTool.isStickerSelected);
    return (React.createElement(AdvancedUIComponents.Controlsbar, { shouldAnimateHeight: false, shoulAnimateOverflow: false, overflowAfterExpand: true },
        React.createElement(Components.Input.Form, null,
            getCustomStickerButton(),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Slider, { isDisabled: !stickerTool.isStickerSelected, name: labels.sliderOpacity, value: stickerTool.opacity, min: 0, max: 1, onChange: stickerTool.changeOpacity, onMouseUp: onRelease, onTouchEnd: onRelease }),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Selection, { isDisabled: isDisabled, label: labels.selectColor },
                React.createElement(ColorList, { parentId: labels.selectColor, activeColor: tintColor, colors: colorList, labelsColor: labelsColor, isDisabled: isDisabled, onChange: stickerTool.changeTintColor, onAddSnapshot: stickerTool.tintColorSnapshot }))),
        React.createElement(AdvancedUIComponents.ItemsSeparator, null)));
};
var StickerControls = inject('stickerTool')(observer(Controls$5));
var templateObject_1$1q;

var Div$4 = styled.div(templateObject_3$t || (templateObject_3$t = __makeTemplateObject(["\n  opacity: 0;\n  visibility: hidden;\n  display: none;\n  flex-wrap: wrap;\n  &.show {\n    opacity: 1;\n    visibility: visible;\n    ", "\n  }\n"], ["\n  opacity: 0;\n  visibility: hidden;\n  display: none;\n  flex-wrap: wrap;\n  &.show {\n    opacity: 1;\n    visibility: visible;\n    ",
    "\n  }\n"])), isIE()
    ? css(templateObject_1$1r || (templateObject_1$1r = __makeTemplateObject(["\n          display: block;\n        "], ["\n          display: block;\n        "]))) : css(templateObject_2$J || (templateObject_2$J = __makeTemplateObject(["\n          display: flex;\n        "], ["\n          display: flex;\n        "]))));
var Items$5 = function (_a) {
    var stickerTool = _a.stickerTool, custom = _a.custom;
    var _b = stickerTool, categories = _b.categories, selectedCategoryIdentifier = _b.selectedCategoryIdentifier, flattenCategories = _b.flattenCategories, entities = _b.entities;
    var renderItemCard = function (card) {
        return custom.getAdvancedOptionCard({
            tool: Tool.STICKER,
            type: CardType.SMALL,
            onClick: function () { return stickerTool.add(card.identifier); },
            image: card.thumbnailURI,
            key: card.identifier,
            label: card.name || card.name,
            style: { backgroundSize: '75%', animationDelay: (card.delay * 0.3 || 0) + "s" },
            children: React.createElement(AdvancedUIComponents.CardLabel, { hidden: true }, card.name),
        });
    };
    var renderCategoryCard = function (card) {
        var isActive = selectedCategoryIdentifier === card.identifier;
        return (React.createElement("div", { key: card.identifier },
            custom.getAdvancedCategoryCard({
                tool: Tool.STICKER,
                type: CardType.LARGE,
                onClick: function () { return stickerTool.toggleCategorySelection(card.identifier); },
                image: card.thumbnailURI,
                label: card.name || card.name,
                style: { animationDelay: (card.delay || 0) + "s" },
                children: (React.createElement(AdvancedUIComponents.CardLabel, { withBackground: true, caret: true, isActive: isActive }, card.name)),
            }),
            React.createElement(Div$4, { className: isActive ? 'show' : '', key: card.identifier + "-items" }, card.items.map(renderItemCard))));
    };
    return (React.createElement(AdvancedUIComponents.Itemsbar, null,
        React.createElement(AdvancedUIComponents.CardContainer, null, flattenCategories ? entities.map(renderItemCard) : categories.map(renderCategoryCard))));
};
var StickerItems = inject('stickerTool', 'custom')(observer(Items$5));
var templateObject_1$1r, templateObject_2$J, templateObject_3$t;

var StickerOptionsBar = function (_a) {
    var stickerTool = _a.stickerTool;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, stickerTool.locale.title),
        React.createElement(StickerControls, null),
        React.createElement(StickerItems, null)));
};
var StickerOptionsBar$1 = inject('stickerTool')(observer(StickerOptionsBar));

var Button$3 = styled(AdvancedUIComponents.Button.TextSecondary)(templateObject_1$1s || (templateObject_1$1s = __makeTemplateObject(["\n  padding: 1px 3px 2px;\n  color: ", ";\n"], ["\n  padding: 1px 3px 2px;\n  color: ", ";\n"])), function (props) { return props.theme.textInput.foreground; });
var Controls$6 = function (_a) {
    var textTool = _a.textTool;
    var labels = textTool.locale.controls;
    var labelsColor = textTool.localeColor.colorPicker;
    var _b = textTool, fontFamilies = _b.fontFamilies, alignment = _b.alignment, isTextSelected = _b.isTextSelected, fontFamily = _b.fontFamily, fontStyle = _b.fontStyle, fontWeight = _b.fontWeight;
    var colorList = TextToolStore.defaultColors;
    var backgroundColorList = TextToolStore.defaultBackgroundColors;
    var alignmentList = ['left', 'center', 'right'];
    var onRelease = function () {
        textTool.toolSnapshot();
    };
    var onNewClick = function () {
        textTool.add();
    };
    var onChangeFontSize = function (value) {
        var fontSize = value ? parseFloat(value) : 0;
        textTool.setFontSize(Math.max(10, Math.min(690, fontSize)));
    };
    var AlignmentList = alignmentList.map(function (item) {
        var Icon = AlignIcons[item];
        return (React.createElement(Button$3, { isDisabled: !isTextSelected, ariaLabel: "Align " + item, isActive: item === alignment, key: item, onClick: function () { return textTool.changeAlignment(item); } },
            React.createElement(Icon, null)));
    });
    var fontList = fontFamilies.map(function (font) { return ({
        label: font.fontFamily + " " + TextToolStore.getDisplayFontStyle(font),
        fontWeight: font.fontWeight || '',
        fontStyle: font.fontStyle || '',
        fontFamily: font.fontFamily || '',
        value: font.identifier,
    }); });
    var selectedItem = fontList.filter(function (_a) {
        var value = _a.value;
        return value === textTool.identifier;
    })[0];
    return (React.createElement(AdvancedUIComponents.Controlsbar, { show: true, overflowAfterExpand: true, shouldAnimateHeight: false },
        React.createElement(Components.Input.Form, null,
            React.createElement(AdvancedUIComponents.Button.OutlinedPrimary, { ariaLabel: labels.buttonNew, onClick: onNewClick }, labels.buttonNew),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Dropdown, { isDisabled: !isTextSelected, style: { fontFamily: fontFamily, fontStyle: fontStyle, fontWeight: fontWeight }, itemStyle: function (item) { return ({
                    fontFamily: item.fontFamily,
                    fontStyle: item.fontStyle,
                    fontWeight: item.fontWeight,
                }); }, label: labels.dropdownFontFamily, list: fontList, onSelect: textTool.changeFont, selectedItem: selectedItem.label }),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Inline, null,
                React.createElement(Components.Input.NummericInput, { value: textTool.fontSize.toFixed(0), onSubmit: onChangeFontSize, label: labels.textFontSize, isDisabled: !isTextSelected }),
                React.createElement(Components.Input.Selection, { isDisabled: !isTextSelected, inline: true, label: labels.selectAlignment }, AlignmentList)),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Div$5, null,
                React.createElement(AdvancedUIComponents.ItemsSeparator, { full: true })),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Selection, { isDisabled: !isTextSelected, label: labels.selectFontColor },
                React.createElement(ColorList, { parentId: labels.selectFontColor, activeColor: textTool.activeTextColor, colors: colorList, labelsColor: labelsColor, isDisabled: !isTextSelected, onChange: textTool.changeColor, onAddSnapshot: textTool.colorSnapshot })),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Selection, { isDisabled: !isTextSelected, label: labels.selectBackgroundColor },
                React.createElement(ColorList, { parentId: labels.selectBackgroundColor, activeColor: textTool.activeBackgroundColor, colors: backgroundColorList, labelsColor: labelsColor, isDisabled: !isTextSelected, onChange: textTool.changeBackgroundColor, onAddSnapshot: textTool.backgroundColorSnapshot })),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Div$5, null,
                React.createElement(AdvancedUIComponents.ItemsSeparator, { full: true })),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Slider, { isDisabled: !isTextSelected, name: labels.sliderLineSpacing, value: textTool.lineHeight, min: 0.5, max: 3, onChange: textTool.changeLineHeight, onMouseUp: onRelease, onTouchEnd: onRelease, snap: 1, divider: 1, decimal: 1 }),
            React.createElement(Components.Spacer, { count: 1 }))));
};
var TextControls = inject('textTool')(observer(Controls$6));
var Div$5 = styled.div(templateObject_2$K || (templateObject_2$K = __makeTemplateObject(["\n  position: relative;\n"], ["\n  position: relative;\n"])));
var Inline = styled.div(templateObject_3$u || (templateObject_3$u = __makeTemplateObject(["\n  .dropdown {\n    min-width: 50%;\n  }\n  .selection {\n    padding-left: 8px;\n    width: 50%;\n    .label {\n      padding-left: 8px;\n    }\n  }\n  display: flex;\n  justify-content: space-between;\n"], ["\n  .dropdown {\n    min-width: 50%;\n  }\n  .selection {\n    padding-left: 8px;\n    width: 50%;\n    .label {\n      padding-left: 8px;\n    }\n  }\n  display: flex;\n  justify-content: space-between;\n"])));
var templateObject_1$1s, templateObject_2$K, templateObject_3$u;

var TextOptionsBar = function (_a) {
    var textTool = _a.textTool;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, textTool.locale.title),
        React.createElement(TextControls, null),
        React.createElement(AdvancedUIComponents.Itemsbar, null)));
};
var TextOptionsBar$1 = inject('textTool')(observer(TextOptionsBar));

var Controls$7 = function (_a) {
    var textDesignTool = _a.textDesignTool;
    var labels = textDesignTool.locale.controls;
    var labelsColor = textDesignTool.localeColor.colorPicker;
    var colors = TextDesignToolStore.colors;
    var isTextSelected = textDesignTool.isTextDesignSelected;
    var onNewClick = function () {
        textDesignTool.add();
    };
    var onToggleClick = function () {
        textDesignTool.changeSeed();
    };
    return (React.createElement(AdvancedUIComponents.Controlsbar, { shoulAnimateOverflow: false, shouldAnimateHeight: false },
        React.createElement(Components.Input.Form, null,
            React.createElement(AdvancedUIComponents.Button.OutlinedPrimary, { ariaLabel: labels.buttonNew, onClick: onNewClick }, labels.buttonNew),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(AdvancedUIComponents.Button.OutlinedSecondary, { ariaLabel: labels.buttonShuffle, isDisabled: !isTextSelected, onClick: onToggleClick }, labels.buttonShuffle),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Selection, { isDisabled: !isTextSelected, label: labels.selectColor },
                React.createElement(ColorList, { parentId: labels.selectColor, activeColor: textDesignTool.activeTextColor, colors: colors, labelsColor: labelsColor, isDisabled: !isTextSelected, onChange: textDesignTool.changeColor, onAddSnapshot: textDesignTool.colorSnapshot }))),
        React.createElement(AdvancedUIComponents.ItemsSeparator, null)));
};
var TextControls$1 = inject('textDesignTool')(observer(Controls$7));

var Items$6 = function (_a) {
    var textDesignTool = _a.textDesignTool, custom = _a.custom;
    var entities = textDesignTool.entities;
    var identifier = textDesignTool.identifier;
    var onClick = function (id) {
        textDesignTool.changeIdentifier(id);
    };
    var renderTextDesign = function (text) {
        return custom.getAdvancedOptionCard({
            tool: Tool.TEXT_DESIGN,
            isDisabled: !textDesignTool.isTextDesignSelected,
            type: CardType.MEDIUM,
            isActive: identifier === text.identifier,
            key: text.identifier,
            onClick: function () { return onClick(text.identifier); },
            image: text.thumbnailURI,
            style: { animationDelay: (text.delay || 0) + "s", backgroundSize: '60%' },
            label: text.name || '',
            children: React.createElement(AdvancedUIComponents.CardLabel, { hidden: true }, text.name),
        });
    };
    return (React.createElement(AdvancedUIComponents.Itemsbar, null,
        React.createElement(AdvancedUIComponents.CardContainer, null, entities.map(renderTextDesign))));
};
var TextItems = inject('textDesignTool', 'custom')(observer(Items$6));

var TextOptionsBar$2 = function (_a) {
    var textDesignTool = _a.textDesignTool;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, textDesignTool.locale.title),
        React.createElement(TextControls$1, null),
        React.createElement(TextItems, null)));
};
var TextDesignOptionsBar = inject('textDesignTool')(observer(TextOptionsBar$2));

var Items$7 = function (_a) {
    var frameTool = _a.frameTool, custom = _a.custom;
    var entities = frameTool.entities;
    var selectedIdentifier = frameTool.state ? frameTool.state.identifier : null;
    var renderFrame = function (option) {
        return custom.getAdvancedOptionCard({
            tool: Tool.FRAME,
            type: CardType.MEDIUM,
            image: option.thumbnailURI,
            onClick: function () { return frameTool.selectFrame(option.identifier); },
            key: option.identifier,
            isActive: option.identifier === selectedIdentifier,
            style: { backgroundSize: '75%', animationDelay: (option.delay || 0) + "s" },
            label: option.name,
            children: React.createElement(AdvancedUIComponents.CardLabel, { hidden: true }, option.name),
        });
    };
    return (React.createElement(AdvancedUIComponents.Itemsbar, null,
        React.createElement(AdvancedUIComponents.CardContainer, null, entities.map(renderFrame))));
};
var FrameItems = inject('frameTool', 'custom')(observer(Items$7));

var Controls$8 = function (_a) {
    var frameTool = _a.frameTool;
    var labels = frameTool.locale.controls;
    var labelsColor = frameTool.localeColor.colorPicker;
    var tintable = frameTool.tintable;
    var colorList = FrameToolStore.colors;
    var onResetClick = function () {
        frameTool.reset();
    };
    var onRelease = function (description) {
        frameTool.toolSnapshot(description);
    };
    return (React.createElement(AdvancedUIComponents.Controlsbar, { show: frameTool.isOptionSelected, overflowAfterExpand: true },
        React.createElement(AdvancedUIComponents.Button.OutlinedSecondary, { ariaLabel: labels.buttonReset, onClick: onResetClick }, labels.buttonReset),
        React.createElement(Components.Spacer, { count: 2 }),
        React.createElement(Components.Input.Slider, { "aria-hidden": !frameTool.isOptionSelected, name: labels.sliderOpacity, value: frameTool.opacity, min: 0, max: 1, onChange: frameTool.changeOpacity, onMouseUp: function () {
                onRelease(labels.sliderOpacity);
            }, onTouchEnd: function () {
                onRelease(labels.sliderOpacity);
            } }),
        React.createElement(Components.Spacer, { count: 2 }),
        React.createElement(Components.Input.Slider, { "aria-hidden": !frameTool.isOptionSelected, name: labels.sliderSize, value: frameTool.size, min: frameTool.minSize, max: frameTool.maxSize, divider: 1, onChange: frameTool.changeWidth, onMouseUp: function () {
                onRelease(labels.sliderSize);
            }, onTouchEnd: function () {
                onRelease(labels.sliderSize);
            } }),
        React.createElement(Components.Spacer, { count: 2 }),
        React.createElement(Components.Input.Selection, { isDisabled: !tintable, label: labels.selectColor },
            React.createElement(ColorList, { parentId: labels.selectColor, activeColor: frameTool.activeColor, colors: colorList, labelsColor: labelsColor, isDisabled: !tintable, onChange: frameTool.changeColor, onAddSnapshot: frameTool.colorSnapshot })),
        React.createElement(AdvancedUIComponents.ItemsSeparator, null)));
};
var FrameControls = inject('frameTool')(observer(Controls$8));

var FrameOptionsBar = function (_a) {
    var frameTool = _a.frameTool;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, frameTool.locale.title),
        React.createElement(FrameControls, null),
        React.createElement(FrameItems, null)));
};
var FrameOptionsBar$1 = inject('frameTool')(observer(FrameOptionsBar));

var Controls$9 = function (_a) {
    var brushTool = _a.brushTool;
    var brushControlLocale = brushTool.locale.controls;
    var labelsColor = brushTool.localeColor.colorPicker;
    var colorList = BrushToolStore.colors;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Controlsbar, { show: brushTool.isDirty },
            React.createElement(AdvancedUIComponents.Button.OutlinedSecondary, { ariaLabel: brushControlLocale.buttonReset, onClick: brushTool.reset }, brushControlLocale.buttonReset),
            React.createElement(AdvancedUIComponents.ItemsSeparator, null)),
        React.createElement(AdvancedUIComponents.Controlsbar, { overflowAfterExpand: true },
            React.createElement(Components.Input.Selection, { label: brushControlLocale.selectColor },
                React.createElement(ColorList, { parentId: brushControlLocale.selectColor, activeColor: brushTool.activeColor, colors: colorList, labelsColor: labelsColor, onChange: brushTool.changeColor })),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Slider, { name: brushControlLocale.sliderSize, value: brushTool.size, min: 1, max: 100, divider: 1, onChange: brushTool.changeSize }),
            React.createElement(Components.Spacer, { count: 3 }),
            React.createElement(Components.Input.Slider, { name: brushControlLocale.sliderHardness, value: brushTool.hardness, min: 0, max: 1, onChange: brushTool.changeHardness }),
            React.createElement(Components.Spacer, null))));
};
var BrushControls = inject('brushTool')(observer(Controls$9));

var BrushOptionsBar = function (_a) {
    var brushTool = _a.brushTool;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, brushTool.locale.title),
        React.createElement(BrushControls, null),
        React.createElement(AdvancedUIComponents.Itemsbar, null)));
};
var BrushOptionsBar$1 = inject('brushTool')(observer(BrushOptionsBar));

var Controls$a = function (_a) {
    var transformTool = _a.transformTool;
    var labels = transformTool.locale.controls;
    var _b = transformTool, forceDimensions = _b.forceDimensions, lockResolution = _b.lockResolution, localOutputHeight = _b.localOutputHeight, localOutputWidth = _b.localOutputWidth;
    var onResetClick = function () {
        transformTool.reset();
    };
    return (React.createElement(AdvancedUIComponents.Controlsbar, { shouldAnimateHeight: false },
        React.createElement(Components.Input.Form, null,
            React.createElement(AdvancedUIComponents.Button.OutlinedSecondary, { ariaLabel: labels.buttonReset, onClick: onResetClick }, labels.buttonReset),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(Components.Input.Checkbox, { isDisabled: forceDimensions, value: lockResolution, label: labels.checkboxKeepResolution, onChange: transformTool.changeLockResolution }),
            React.createElement(Components.Spacer, { count: 2 }),
            React.createElement(TransformScaleInput, { isDisabled: forceDimensions, showLabel: true, valueHeight: localOutputHeight, valueWidth: localOutputWidth, onBlurWidth: transformTool.onBlurWidth, onBlurHeight: transformTool.onBlurHeight, onChangeHeight: transformTool.changeLocalOutputHeight, onChangeWidth: transformTool.changeLocalOutputWidth, label: labels.inputCropSize, labelHeight: labels.inputHeight, labelWidth: labels.inputWidth }),
            React.createElement(Components.Spacer, { count: 1 })),
        React.createElement(AdvancedUIComponents.ItemsSeparator, null)));
};
var TransformControls = inject('transformTool')(observer(Controls$a));

var Items$8 = function (_a) {
    var transformTool = _a.transformTool, custom = _a.custom, editor = _a.editor;
    var _b = transformTool, categories = _b.categories, allItems = _b.items, identifier = _b.identifier, config = _b.config;
    var renderItems = function (option) {
        var isActive = option.identifier === identifier;
        var _a = editor.configStore, theme = _a.theme, measurements = _a.measurements;
        if (option.thumbnailURI && transformTool.checkImage(option.thumbnailURI)) {
            return custom.getAdvancedOptionCard({
                tool: Tool.TRANSFORM,
                type: CardType.MEDIUM,
                isActive: isActive,
                onClick: function () { return transformTool.changeIdentifier(option.identifier, true); },
                key: option.identifier,
                style: { backgroundSize: '80%', animationDelay: (option.delay || 0) + "s" },
                image: option.thumbnailURI,
                label: option.name || option.name,
                children: React.createElement(AdvancedUIComponents.CardLabel, null, option.name),
            });
        }
        var isCommonCrop = option.identifier.includes('imgly_transform_common');
        var cropImage = TransformIcons.crops[option.identifier] || TransformIcons.crops.imgly_transform_common_custom;
        var Component = React.createElement(cropImage, {
            width: measurements.advancedCard.medium.width - (isCommonCrop ? 42 : 0) + "px",
            height: measurements.advancedCard.medium.height - (isCommonCrop ? 42 : 0) + "px",
            main: theme.transform.crops.main,
            highlight: theme.transform.crops.highlight,
            shadow: theme.transform.crops.shadow,
        });
        return custom.getAdvancedOptionCard({
            tool: Tool.TRANSFORM,
            type: CardType.MEDIUM,
            isActive: isActive,
            onClick: function () { return transformTool.changeIdentifier(option.identifier, true); },
            key: option.identifier,
            style: { animationDelay: (option.delay || 0) + "s", backgroundSize: 'unset' },
            image: "'data:image/svg+xml," + encodeURIComponent(renderToStaticMarkup(Component)) + "'",
            label: option.name || option.name,
            children: React.createElement(AdvancedUIComponents.CardLabel, null, option.name),
        });
    };
    var getCategories = function (category, index) {
        return (category.items && (React.createElement("div", { style: { position: 'relative' }, key: category.identifier },
            index !== 0 ? React.createElement(Components.Spacer, { count: 2 }) : null,
            React.createElement(AdvancedUIComponents.Sidebar.SubHeading, null, category.name),
            React.createElement(AdvancedUIComponents.CardContainer, null, category.items.map(renderItems)),
            React.createElement(Components.Spacer, { count: 2 }),
            index !== categories.length - 1 ? React.createElement(AdvancedUIComponents.ItemsSeparator, { full: true }) : null))) ||
            null;
    };
    var getItems = function (items) { return (React.createElement("div", { style: { position: 'relative' } },
        React.createElement(AdvancedUIComponents.CardContainer, null, items.map(renderItems)))); };
    return (React.createElement(AdvancedUIComponents.Itemsbar, null, config.flattenCategories ? (getItems(allItems)) : (React.createElement(React.Fragment, null,
        categories.map(getCategories),
        getItems(categories.filter(function (t) { return !t.items; }))))));
};
var TransformItems = inject('transformTool', 'custom', 'editor')(observer(Items$8));

var TransformOptionsBar = function (_a) {
    var transformTool = _a.transformTool;
    return (React.createElement(React.Fragment, null,
        React.createElement(AdvancedUIComponents.Sidebar.Heading, null, transformTool.locale.title),
        React.createElement(TransformControls, null),
        React.createElement(TransformItems, null)));
};
var TransformOptionsBar$1 = inject('transformTool')(observer(TransformOptionsBar));

var ToolOptionsBarComponent = /** @class */ (function (_super) {
    __extends(ToolOptionsBarComponent, _super);
    function ToolOptionsBarComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ToolOptionsBarComponent.prototype.render = function () {
        var activeTool = this.props.active.tool;
        return (React.createElement(AdvancedUIComponents.Sidebar.Index, null,
            React.createElement(Components.Switch.Index, { type: activeTool },
                React.createElement(Components.Switch.Case, { value: Tool.LIBRARY },
                    React.createElement(LibraryOptionsBar$1, null)),
                React.createElement(Components.Switch.Case, { value: Tool.FILTER },
                    React.createElement(FilterOptionsBar$1, null)),
                React.createElement(Components.Switch.Case, { value: Tool.FOCUS },
                    React.createElement(FocusOptionsBar$1, null)),
                React.createElement(Components.Switch.Case, { value: Tool.ADJUSTMENT },
                    React.createElement(AdjustOptionsBar$1, null)),
                React.createElement(Components.Switch.Case, { value: Tool.OVERLAY },
                    React.createElement(OverlayOptionsBar$1, null)),
                React.createElement(Components.Switch.Case, { value: Tool.STICKER },
                    React.createElement(StickerOptionsBar$1, null)),
                React.createElement(Components.Switch.Case, { value: Tool.TEXT },
                    React.createElement(TextOptionsBar$1, null)),
                React.createElement(Components.Switch.Case, { value: Tool.TEXT_DESIGN },
                    React.createElement(TextDesignOptionsBar, null)),
                React.createElement(Components.Switch.Case, { value: Tool.FRAME },
                    React.createElement(FrameOptionsBar$1, null)),
                React.createElement(Components.Switch.Case, { value: Tool.BRUSH },
                    React.createElement(BrushOptionsBar$1, null)),
                React.createElement(Components.Switch.Case, { value: Tool.TRANSFORM },
                    React.createElement(TransformOptionsBar$1, null)))));
    };
    ToolOptionsBarComponent = __decorate([
        inject('active'),
        observer
    ], ToolOptionsBarComponent);
    return ToolOptionsBarComponent;
}(React.Component));

var Disable = styled.div(templateObject_1$1t || (templateObject_1$1t = __makeTemplateObject(["\n  position: absolute;\n  height: 100%;\n  width: ", "px;\n  top: 0;\n  background: ", ";\n  z-index: ", ";\n"], ["\n  position: absolute;\n  height: 100%;\n  width: ",
    "px;\n  top: 0;\n  background: ", ";\n  z-index: ", ";\n"])), function (props) {
    return props.theme.measurements.advancedUIToolbar.width + props.theme.measurements.advancedToolControlBar.width;
}, function (props) { return props.theme.webcam.backdrop; }, function (props) { return props.theme.measurements.zIndex.disable; });
var Advanced = /** @class */ (function (_super) {
    __extends(Advanced, _super);
    function Advanced() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { hasError: false };
        return _this;
    }
    Advanced.getDerivedStateFromError = function (error) {
        // eslint-disable-next-line no-console
        console.error(error);
        // Update state so the next render will show the fallback UI.
        return { hasError: true };
    };
    Advanced.prototype.render = function () {
        var _a = this.props, config = _a.config, active = _a.active;
        return config.isOrderDefault ? (React.createElement(Components.Container, null,
            active.isWebcam ? React.createElement(Disable, { style: { left: 0 } }) : null,
            React.createElement(Modal$1, null),
            React.createElement(ToolBarComponent, null),
            React.createElement(ToolOptionsBarComponent, null),
            React.createElement(CanvasArea, null,
                React.createElement(CanvasBar$2, null),
                React.createElement(CanvasContainer$1, null)))) : (React.createElement(Components.Container, null,
            active.isWebcam ? React.createElement(Disable, { style: { right: 0 } }) : null,
            React.createElement(Modal$1, null),
            React.createElement(CanvasArea, null,
                React.createElement(CanvasBar$2, null),
                React.createElement(CanvasContainer$1, null)),
            React.createElement(ToolOptionsBarComponent, null),
            React.createElement(ToolBarComponent, null)));
    };
    return Advanced;
}(React.Component));
var Layout = inject('config', 'active')(observer(Advanced));
var templateObject_1$1t;

var AdvancedUI = /** @class */ (function (_super) {
    __extends(AdvancedUI, _super);
    function AdvancedUI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AdvancedUI.prototype.componentDidMount = function () {
        this.editor = this.props.editor;
        this.storeProps = this.props.storeProps;
        var factory = new CustomComponentsFactory(this.editor.configStore.config.custom.components, {
            advancedCard: AdvancedUIComponents.Card,
            advancedToolbarItem: ToolbarItem$1,
            loader: Components.Loader,
        });
        var custom = {
            getAdvancedCategoryCard: factory.getAdvancedCategoryCard,
            getAdvancedOptionCard: factory.getAdvancedOptionCard,
            getAdvancedToolbarItem: factory.getAdvancedToolbarItem,
            getLoader: factory.getLoader,
            getButton: factory.getButton,
        };
        this.storeProps.custom = custom;
        this.forceUpdate();
    };
    AdvancedUI.prototype.render = function () {
        return this.storeProps ? (React.createElement(Provider, __assign({}, this.storeProps),
            React.createElement(ThemeProvider, { theme: __assign({}, this.editor.configStore.theme, { measurements: this.editor.configStore.measurements }) },
                React.createElement(Layout, null)))) : null;
    };
    return AdvancedUI;
}(React.Component));



var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AdvancedUI: AdvancedUI,
    defaultConfig: defaultConfig,
    deepmergeAll: deepmergeAll
});

export { BaseCardLabel as $, AdjustmentIdentifier as A, BlendMode as B, CanvasAction as C, TransformConfiguration as D, ExportConfiguration as E, FilterConfiguration as F, TransformIdentifier as G, EventEmitter as H, ImageFormat as I, Vector2 as J, uuid as K, LibraryCategory as L, __spread as M, __makeTemplateObject as N, OverlayConfiguration as O, PhotoEditorSDKUI as P, BaseButton as Q, ResponsiveButton as R, SnappingConfiguration as S, Tool as T, UIEvent as U, VideoFormat as V, BaseCard as W, CardType$1 as X, States as Y, __rest as Z, __assign as _, PhotoEditorSDKUIComponent as a, defaultStyledTheme as a0, ButtonGroupItem as a1, __extends as a2, Animations as a3, ButtonGroupWrapper as a4, Components as a5, inject as a6, observer as a7, ToolbarIcons as a8, SimpleBar as a9, CardType as aa, AdjustmentIcons as ab, TextToolStore as ac, TransformIcons as ad, __decorate as ae, ToolControlBarIcons as af, FocusToolStore as ag, ColorList as ah, StickerToolStore as ai, AlignIcons as aj, TextDesignToolStore as ak, FrameToolStore as al, BrushToolStore as am, TransformScaleInput as an, FlipRotateControls$1 as ao, Modal$1 as ap, CanvasArea as aq, CanvasBar$2 as ar, CanvasContainer$1 as as, CustomComponentsFactory as at, Provider as au, __values as av, lodash_debounce as aw, deepmergeAll as b, isExistingCategory as c, defaultConfig as d, VideoCodec as e, SerializationExportType as f, ExportFormat as g, Configuration as h, isExistingItem as i, AdjustmentConfiguration as j, isDuoToneFilterAsset as k, isLUTFilterAsset as l, FocusConfiguration as m, FocusIdentifier as n, FrameConfiguration as o, LibraryImage as p, LibraryConfiguration as q, LibraryProvider as r, StickerConfiguration as s, isStickerAssetDynamic as t, isStickerCategoryDynamic as u, TextConfiguration as v, isWebFontAsset as w, isGoogleFontAsset as x, BrushConfiguration as y, TextDesignConfiguration as z };
